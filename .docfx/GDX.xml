<?xml version="1.0"?>
<doc>
    <assembly>
        <name>GDX</name>
    </assembly>
    <members>
        <member name="T:GDX.Localization">
            <summary>
                A collection of localization related helper utilities.
            </summary>
        </member>
        <member name="T:GDX.Localization.Language">
            <summary>
                A list of supported languages.
            </summary>
            <remarks>
                This does not differentiate between things like French Canadian and French.
            </remarks>
        </member>
        <member name="F:GDX.Localization.UtcTimestampFormat">
            <summary>
                The UTC ISO 8601 compliant System.DateTime.ToString(System.String).
            </summary>
        </member>
        <member name="F:GDX.Localization.LocalTimestampFormat">
            <summary>
                The local ISO 8601 compliant System.DateTime.ToString(System.String).
            </summary>
        </member>
        <member name="F:GDX.Localization.s_readableByteSizes">
            <summary>
                An array of strings representative for file size formats.
            </summary>
        </member>
        <member name="M:GDX.Localization.GetHumanReadableFileSize(System.Int64)">
            <summary>
                Creates a more human readable System.String of a byte size.
            </summary>
            <example>
                A byte size of 1024, will return a string of 1 KB.
            </example>
            <param name="base2Size">The number of bytes (binary) to measure.</param>
            <returns>A human readable version of the provided base2Size.</returns>
        </member>
        <member name="M:GDX.Localization.GetISO639_1(GDX.Localization.Language)">
            <summary>
                <para>Get the ISO 639-1 language code for targetLanguage.</para>
            </summary>
            <remarks>Two additional non-compliant values may be returned DEV or DEFAULT.</remarks>
            <param name="targetLanguage">The target GDX.Localization.Language.</param>
            <returns>The language code.</returns>
        </member>
        <member name="M:GDX.Localization.GetIETF(GDX.Localization.Language)">
            <summary>
                <para>Get the IETF language code for targetLanguage.</para>
            </summary>
            <remarks>Two additional non-compliant values may be returned DEV or DEFAULT.</remarks>
            <param name="targetLanguage">The target GDX.Localization.Language.</param>
            <returns>The language code.</returns>
        </member>
        <member name="M:GDX.Localization.GetSystemLanguage">
            <summary>
                Get the GDX.Localization.Language equivalent of the UnityEngine.SystemLanguage.
            </summary>
            <returns>The appropriate GDX.Localization.Language, or default.</returns>
        </member>
        <member name="M:GDX.Localization.GetTimestampFormat(GDX.Localization.Language)">
            <summary>
                Get the localized System.DateTime.System.DateTime.ToString(System.String) for
                targetLanguage.
            </summary>
            <param name="targetLanguage">The target GDX.Localization.Language.</param>
            <returns>The format System.String.</returns>
        </member>
        <member name="M:GDX.Localization.SetDefaultCulture">
            <summary>
                Sets the current threads culture to a defined setting in GDX.GDXConfig.
            </summary>
            <remarks>
                Can be used to avoid issues with culture settings without a Gregorian Calendar. Configurable to automatically
                execute after assemblies are loaded.
            </remarks>
        </member>
        <member name="T:GDX.SemanticVersion">
            <summary>
                A Semantic Versioning structure.
            </summary>
            <remarks>https://semver.org/</remarks>
        </member>
        <member name="F:GDX.SemanticVersion.s_versionIndicators">
            <summary>
                An array of System.Char used to split versions.
            </summary>
        </member>
        <member name="F:GDX.SemanticVersion.Major">
            <summary>
                Major Version.
            </summary>
            <remarks>Is incremented when you make incompatible API changes.</remarks>
        </member>
        <member name="F:GDX.SemanticVersion.Minor">
            <summary>
                Minor Version.
            </summary>
            <remarks>Is incremented when you add functionality in a backwards-compatible manner.</remarks>
        </member>
        <member name="F:GDX.SemanticVersion.Patch">
            <summary>
                Patch Version
            </summary>
            <remarks>Is incremented when you make backwards-compatible fixes.</remarks>
        </member>
        <member name="M:GDX.SemanticVersion.#ctor(System.String)">
            <summary>
                Create a GDX.SemanticVersion based on a formatted System.String.
            </summary>
            <param name="version">A formatted version semantic version string (2020.1.0).</param>
        </member>
        <member name="M:GDX.SemanticVersion.op_GreaterThan(GDX.SemanticVersion,GDX.SemanticVersion)">
            <summary>
                Determine if GDX.SemanticVersion is greater than another GDX.SemanticVersion.
            </summary>
            <param name="lhs">Left-hand side GDX.SemanticVersion.</param>
            <param name="rhs">Right-hand side GDX.SemanticVersion.</param>
            <returns>Returns the result of a GREATER THAN operation on two GDX.SemanticVersion values.</returns>
        </member>
        <member name="M:GDX.SemanticVersion.op_GreaterThanOrEqual(GDX.SemanticVersion,GDX.SemanticVersion)">
            <summary>
                Determine if GDX.SemanticVersion is greater than or equal to another GDX.SemanticVersion.
            </summary>
            <param name="lhs">Left-hand side GDX.SemanticVersion.</param>
            <param name="rhs">Right-hand side GDX.SemanticVersion.</param>
            <returns>
                Returns the result of a GREATER THAN OR EQUAL operation on two GDX.SemanticVersion
                values.
            </returns>
        </member>
        <member name="M:GDX.SemanticVersion.op_LessThanOrEqual(GDX.SemanticVersion,GDX.SemanticVersion)">
            <summary>
                Determine if GDX.SemanticVersion is less than or equal to another GDX.SemanticVersion.
            </summary>
            <param name="lhs">Left-hand side GDX.SemanticVersion.</param>
            <param name="rhs">Right-hand side GDX.SemanticVersion.</param>
            <returns>
                Returns the result of a LESS THAN OR EQUAL operation on two GDX.SemanticVersion
                values.
            </returns>
        </member>
        <member name="M:GDX.SemanticVersion.op_LessThan(GDX.SemanticVersion,GDX.SemanticVersion)">
            <summary>
                Determine if GDX.SemanticVersion is less than another GDX.SemanticVersion.
            </summary>
            <param name="lhs">Left-hand side GDX.SemanticVersion.</param>
            <param name="rhs">Right-hand side GDX.SemanticVersion.</param>
            <returns>Returns the result of a LESS THAN operation on two GDX.SemanticVersion values.</returns>
        </member>
        <member name="M:GDX.SemanticVersion.op_Equality(GDX.SemanticVersion,GDX.SemanticVersion)">
            <summary>
                Determine if GDX.SemanticVersion is equal to another GDX.SemanticVersion.
            </summary>
            <param name="lhs">Left-hand side GDX.SemanticVersion.</param>
            <param name="rhs">Right-hand side GDX.SemanticVersion.</param>
            <returns>Returns the result of a EQUALITY operation on two GDX.SemanticVersion values.</returns>
        </member>
        <member name="M:GDX.SemanticVersion.op_Inequality(GDX.SemanticVersion,GDX.SemanticVersion)">
            <summary>
                Determine if GDX.SemanticVersion does not equal than another GDX.SemanticVersion.
            </summary>
            <param name="lhs">Left-hand side GDX.SemanticVersion.</param>
            <param name="rhs">Right-hand side GDX.SemanticVersion.</param>
            <returns>Returns the result of a NOT EQUAL operation on two GDX.SemanticVersion values.</returns>
        </member>
        <member name="M:GDX.SemanticVersion.Equals(System.Object)">
            <summary>
                Does the obj equal this GDX.SemanticVersion.
            </summary>
            <param name="obj">An System.Object to compare against.</param>
            <returns>Returns the result of an EQUALITY operation.</returns>
        </member>
        <member name="M:GDX.SemanticVersion.GetHashCode">
            <summary>
                Get the hash code of the GDX.SemanticVersion.
            </summary>
            <returns>A System.Int32 value.</returns>
        </member>
        <member name="M:GDX.SemanticVersion.Equals(GDX.SemanticVersion)">
            <summary>
                Does the otherSemanticVersion equal the GDX.SemanticVersion.
            </summary>
            <param name="otherSemanticVersion"></param>
            <returns>
                The results of checking the GDX.SemanticVersion.Major/GDX.SemanticVersion.Minor/
                GDX.SemanticVersion.Patch for equality.
            </returns>
        </member>
        <member name="T:GDX.Developer.Conditionals">
            <summary>
                Constant indicators about conditional supports within the GDX package. Helpful indicators of which features are
                available through preprocessor gating.
            </summary>
        </member>
        <member name="F:GDX.Developer.Conditionals.HasAddressablesPackage">
            <summary>
                Is a compatible version of the Addressables package present in the project?
            </summary>
        </member>
        <member name="F:GDX.Developer.Conditionals.HasBurstPackage">
            <summary>
                Is a compatible version of the Burst package present in the project?
            </summary>
        </member>
        <member name="F:GDX.Developer.Conditionals.HasMathematicsPackage">
            <summary>
                Is a compatible version of the Mathematics package present in the project?
            </summary>
        </member>
        <member name="F:GDX.Developer.Conditionals.HasPlatformsPackage">
            <summary>
                Is a compatible version of the Platforms package present in the project?
            </summary>
        </member>
        <member name="F:GDX.Developer.Conditionals.HasVisualScriptingPackage">
            <summary>
                Is a compatible version of the Visual Scripting package present in the project?
            </summary>
        </member>
        <member name="T:GDX.Developer.CommandLineParser">
            <summary>
                A simplified commandline parser that handles arguments which follow the <c>--FLAG</c> or <c>--KEY=VALUE</c> format.
                Automatically initialized during normal runtime operations, however can be manually triggered for author time
                use cases as well.
            </summary>
            <remarks>
                <para>
                    The prefix and divider are configurable via the GDX.GDXConfig, however the always, the <c>FLAG</c>
                    and <c>KEY</c> will be Uppercase.
                </para>
            </remarks>
        </member>
        <member name="F:GDX.Developer.CommandLineParser.Arguments">
            <summary>
                The processed arguments found after parsing the arguments
            </summary>
        </member>
        <member name="F:GDX.Developer.CommandLineParser.Flags">
            <summary>
                The processed flags found in the arguments.
            </summary>
        </member>
        <member name="M:GDX.Developer.CommandLineParser.ParseArguments">
            <summary>
                Process the environment's commandline arguments into GDX.Developer.CommandLineParser.Arguments and GDX.Developer.CommandLineParser.Flags.
            </summary>
            <remarks>
                <para>This is automatically executed during runtime.</para>
            </remarks>
        </member>
        <member name="M:GDX.Developer.CommandLineParser.ProcessArguments(System.String[],System.Boolean)">
            <summary>
                Process an array of arguments into GDX.Developer.CommandLineParser.Arguments and GDX.Developer.CommandLineParser.Flags.
            </summary>
            <param name="argumentArray">An array of arguments to process.</param>
            <param name="shouldClear">Should the storage containers be cleared.</param>
        </member>
        <member name="T:GDX.IListExtensions">
            <summary>
                System.Collections.Generic.IList`1 Based Extension Methods
            </summary>
        </member>
        <member name="M:GDX.IListExtensions.AddUniqueItem``1(System.Collections.Generic.IList{``0},``0)">
            <summary>
                Add an item to a System.Collections.Generic.IList`1, but only if it is not already contained.
            </summary>
            <param name="targetList">The System.Collections.Generic.IList`1 to add too.</param>
            <param name="targetItem">The target object to add..</param>
            <typeparam name="T">The type of the System.Collections.Generic.IList`1.</typeparam>
            <returns>true/false if this operation was able to add the item.</returns>
        </member>
        <member name="M:GDX.IListExtensions.AddUniqueValue``1(System.Collections.Generic.IList{``0},``0)">
            <summary>
                Add a value to a System.Collections.Generic.IList`1, but only if it is not already contained.
            </summary>
            <param name="targetList">The System.Collections.Generic.IList`1 to add too.</param>
            <param name="targetValue">The target value to add..</param>
            <typeparam name="T">The type of the System.Collections.Generic.IList`1.</typeparam>
            <returns>true/false if this operation was able to add the value.</returns>
        </member>
        <member name="M:GDX.IListExtensions.ContainsItem``1(System.Collections.Generic.IList{``0},``0)">
            <summary>
                <para>Does targetList contain targetItem?</para>
            </summary>
            <remarks>Avoids using System.Collections.Generic.EqualityComparer`1.</remarks>
            <param name="targetList">The System.Collections.Generic.IList`1 to look in.</param>
            <param name="targetItem">The target object to look for.</param>
            <typeparam name="T">The type of the System.Collections.Generic.IList`1.</typeparam>
            <returns>true/false</returns>
        </member>
        <member name="M:GDX.IListExtensions.ContainsValue``1(System.Collections.Generic.IList{``0},System.Object)">
            <summary>
                <para>Does targetList contain targetValue?</para>
            </summary>
            <remarks>
                WARNING: This will box the targetValue. You should probably write your own explicit
                implementation.
            </remarks>
            <param name="targetList">The System.Collections.Generic.IList`1 to look in.</param>
            <param name="targetValue">The value to look for.</param>
            <typeparam name="T">The type of the System.Collections.Generic.IList`1.</typeparam>
            <returns>true/false</returns>
        </member>
        <member name="M:GDX.IListExtensions.RemoveFirstItem``1(System.Collections.Generic.IList{``0},``0)">
            <summary>
                <para>Removes the first targetItem from the provided targetList.</para>
            </summary>
            <remarks>Avoids using System.Collections.Generic.EqualityComparer`1.</remarks>
            <param name="targetList">The target System.Collections.Generic.IList`1.</param>
            <param name="targetItem">The target object to remove from the targetList.</param>
            <typeparam name="T">The type of the System.Collections.Generic.IList`1.</typeparam>
            <returns>true/false if the item was removed.</returns>
        </member>
        <member name="M:GDX.IListExtensions.RemoveFirstValue``1(System.Collections.Generic.IList{``0},System.Object)">
            <summary>
                Removes the first targetValue from the provided targetList.
            </summary>
            <remarks>
                <para>
                    WARNING: This will box the targetValue. You should probably write your own explicit
                    implementation.
                </para>
            </remarks>
            <param name="targetList">The target System.Collections.Generic.IList`1.</param>
            <param name="targetValue">The value to remove from the targetList.</param>
            <typeparam name="T">The type of the System.Collections.Generic.IList`1.</typeparam>
            <returns>true/false if a value was removed.</returns>
        </member>
        <member name="M:GDX.IListExtensions.RemoveItems``1(System.Collections.Generic.IList{``0},``0)">
            <summary>
                <para>Removes all targetItem from the provided targetList.</para>
            </summary>
            <remarks>Avoids using System.Collections.Generic.EqualityComparer`1.</remarks>
            <param name="targetList">The target System.Collections.Generic.IList`1.</param>
            <param name="targetItem">The target object to remove from the targetList.</param>
            <typeparam name="T">The type of the System.Collections.Generic.IList`1.</typeparam>
            <returns>true/false if the item was removed.</returns>
        </member>
        <member name="M:GDX.IListExtensions.RemoveValues``1(System.Collections.Generic.IList{``0},System.Object)">
            <summary>
                Removes all targetValue from the provided targetList.
            </summary>
            <remarks>
                <para>
                    WARNING: This will box the targetValue. You should probably write your own explicit
                    implementation.
                </para>
            </remarks>
            <param name="targetList">The target System.Collections.Generic.IList`1.</param>
            <param name="targetValue">The value to remove from the targetList.</param>
            <typeparam name="T">The type of the System.Collections.Generic.IList`1.</typeparam>
            <returns>true/false if values were removed.</returns>
        </member>
        <member name="M:GDX.IListExtensions.RemoveItemSwap``1(System.Collections.Generic.IList{``0},System.Int32)">
            <summary>
                <para>
                    Replaces the object found at the provided index with the last object in
                    targetList, then removes the last item from the targetList.
                </para>
            </summary>
            <remarks>
                This make sure that you are always removing from the end of a
                System.Collections.Generic.IList`1.
            </remarks>
            <param name="targetList">The target System.Collections.Generic.IList`1.</param>
            <param name="index">The index of the item to remove.</param>
            <typeparam name="T">The type of the System.Collections.Generic.IList`1.</typeparam>
        </member>
        <member name="M:GDX.IListExtensions.RemoveLastItem``1(System.Collections.Generic.IList{``0},``0)">
            <summary>
                <para>Removes the last targetItem from the provided targetList.</para>
            </summary>
            <remarks>Avoids using System.Collections.Generic.EqualityComparer`1.</remarks>
            <param name="targetList">The target System.Collections.Generic.IList`1.</param>
            <param name="targetItem">The target object to remove from the targetList.</param>
            <typeparam name="T">The type of the System.Collections.Generic.IList`1.</typeparam>
            <returns>true/false if the item was removed.</returns>
        </member>
        <member name="M:GDX.IListExtensions.RemoveLastValue``1(System.Collections.Generic.IList{``0},System.Object)">
            <summary>
                Removes the last targetValue from the provided targetList.
            </summary>
            <remarks>
                <para>
                    WARNING: This will box the targetValue. You should probably write your own explicit
                    implementation.
                </para>
            </remarks>
            <param name="targetList">The target System.Collections.Generic.IList`1.</param>
            <param name="targetValue">The value to remove from the targetList.</param>
            <typeparam name="T">The type of the System.Collections.Generic.IList`1.</typeparam>
            <returns>true/false if a value was removed.</returns>
        </member>
        <member name="M:GDX.IListExtensions.Shuffle``1(System.Collections.Generic.IList{``0})">
            <summary>
                Shuffle the items in the targetList.
            </summary>
            <remarks>Requires UnityEngine.CoreModule.dll to function correctly.</remarks>
            <param name="targetList">The target System.Collections.Generic.IList`1.</param>
            <typeparam name="T">The type of the System.Collections.Generic.IList`1.</typeparam>
        </member>
        <member name="T:GDX.Collections.Generic.NativeArray2D`1">
            <summary>
                A 2-dimension Unity.Collections.NativeArray`1 backed array.
            </summary>
            <remarks>
                The GDX.Collections.Generic.NativeArray2D`1 is backed by a Unity.Collections.NativeArray`1 which requires
                UnityEngine.CoreModule.dll.
            </remarks>
            <typeparam name="T">Type of objects.</typeparam>
        </member>
        <member name="F:GDX.Collections.Generic.NativeArray2D`1.Array">
            <summary>
                The backing Unity.Collections.NativeArray`1.
            </summary>
        </member>
        <member name="F:GDX.Collections.Generic.NativeArray2D`1.ColumnCount">
            <summary>
                The length of each pseudo-array in the dataset.
            </summary>
            <remarks>CAUTION! Changing this will alter the understanding of the data.</remarks>
        </member>
        <member name="F:GDX.Collections.Generic.NativeArray2D`1.RowCount">
            <summary>
                The number of pseudo-arrays created to support the dimensionality.
            </summary>
            <remarks>CAUTION! Changing this will alter the understanding of the data.</remarks>
        </member>
        <member name="M:GDX.Collections.Generic.NativeArray2D`1.#ctor(System.Int32,System.Int32,Unity.Collections.Allocator,Unity.Collections.NativeArrayOptions)">
            <summary>
                Create a GDX.Collections.Generic.NativeArray2D`1.
            </summary>
            <param name="columnCount">The number of columns (X).</param>
            <param name="rowCount">The number of rows (Y).</param>
            <param name="allocator">The Unity.Collections.Allocator type to use.</param>
            <param name="nativeArrayOptions">Should the memory be cleared on allocation?</param>
        </member>
        <member name="P:GDX.Collections.Generic.NativeArray2D`1.Item(System.Int32,System.Int32)">
            <summary>
                Get a typed object at a specific 2-dimensional index in GDX.Collections.Generic.NativeArray2D`1.Array.
            </summary>
            <param name="x">The column number (X).</param>
            <param name="y">The row number (Y).</param>
        </member>
        <member name="M:GDX.Collections.Generic.NativeArray2D`1.AddRows(System.Int32,Unity.Collections.Allocator,Unity.Collections.NativeArrayOptions)">
            <summary>
                Add additional rows to the dataset.
            </summary>
            <param name="numberOfNewRows">The number of rows/arrays to add.</param>
            <param name="allocator">The Unity.Collections.Allocator type to use.</param>
            <param name="nativeArrayOptions">Should the memory be cleared on allocation?</param>
        </member>
        <member name="M:GDX.Collections.Generic.NativeArray2D`1.Dispose">
            <summary>
                Properly dispose of GDX.Collections.Generic.NativeArray2D`1.Array.
            </summary>
        </member>
        <member name="M:GDX.Collections.Generic.NativeArray2D`1.AddColumns(System.Int32,Unity.Collections.Allocator,Unity.Collections.NativeArrayOptions)">
            <summary>
                Add additional columns to the dataset.
            </summary>
            <param name="numberOfNewColumns">The number of columns add.</param>
            <param name="allocator">The Unity.Collections.Allocator type to use.</param>
            <param name="nativeArrayOptions">Should the memory be cleared on allocation?</param>
        </member>
        <member name="T:GDX.Collections.Generic.SerializableDictionary`2">
            <summary>
                A Unity serializable System.Collections.Generic.Dictionary`2.
            </summary>
            <remarks>
                <para>
                    This will NOT work with System.Object based objects, use UnityEngine.Object if
                    you must. While .NET has solutions for creating custom serialization paths, Unity uses its own system to
                    serialize data into YAML structures. This also assumes that the types provided can be serialized by Unity.
                </para>
                <para>
                    The process of serializing and deserializing this dictionary should not be considered performant.
                </para>
            </remarks>
            <typeparam name="TKey">The dictionary's key System.Type.</typeparam>
            <typeparam name="TValue">The dictionary's value System.Type.</typeparam>
        </member>
        <member name="F:GDX.Collections.Generic.SerializableDictionary`2.isSerializable">
            <summary>
                Is the dictionary completely capable of being serialized by Unity?
            </summary>
            <remarks>This field is determined/cached in the constructor.</remarks>
        </member>
        <member name="F:GDX.Collections.Generic.SerializableDictionary`2.serializedLength">
            <summary>
                The length of the serialized data arrays.
            </summary>
        </member>
        <member name="F:GDX.Collections.Generic.SerializableDictionary`2.serializedKeys">
            <summary>
                An array of all of the keys, in order, used to recreate the base System.Collections.Generic.Dictionary`2.
            </summary>
        </member>
        <member name="F:GDX.Collections.Generic.SerializableDictionary`2.serializedValues">
            <summary>
                An array of all of the values, in order, used to recreate the base System.Collections.Generic.Dictionary`2.
            </summary>
        </member>
        <member name="M:GDX.Collections.Generic.SerializableDictionary`2.#ctor">
            <summary>
                Type constructor.
            </summary>
        </member>
        <member name="M:GDX.Collections.Generic.SerializableDictionary`2.GetSerializedDataLength">
            <summary>
                Get the length of the serialized data arrays.
            </summary>
            <returns>An integer value representing the count.</returns>
        </member>
        <member name="M:GDX.Collections.Generic.SerializableDictionary`2.IsNullableKey">
            <summary>
                Is the dictionaries key nullable?
            </summary>
            <returns>true/false if nullable.</returns>
        </member>
        <member name="M:GDX.Collections.Generic.SerializableDictionary`2.IsSerializableType(System.Type)">
            <summary>
                Is the type capable of being serialized by the
                GDX.Collections.Generic.SerializableDictionary`2, utilizing Unity's own serialization system?
            </summary>
            <returns>true/false if the type is valid.</returns>
        </member>
        <member name="M:GDX.Collections.Generic.SerializableDictionary`2.LoadSerializedData(System.Boolean)">
            <summary>
                Load the data into the System.Collections.Generic.Dictionary`2 cached in the serialized data.
            </summary>
            <param name="clearAfterLoad">Should the serialized data be cleared after loading?</param>
        </member>
        <member name="M:GDX.Collections.Generic.SerializableDictionary`2.OnAfterDeserialize">
            <summary>
                Rehydrate the serialized data arrays back into a cohesive System.Collections.Generic.Dictionary`2.
            </summary>
            <remarks>Invoked by Unity, calls GDX.Collections.Generic.SerializableDictionary`2.LoadSerializedData(System.Boolean).</remarks>
        </member>
        <member name="M:GDX.Collections.Generic.SerializableDictionary`2.OnBeforeSerialize">
            <summary>
                Build out serialized data arrays and associative data, used to rehydrate during deserialization.
            </summary>
            <remarks>Invoked by Unity, calls GDX.Collections.Generic.SerializableDictionary`2.SaveSerializedData.</remarks>
        </member>
        <member name="M:GDX.Collections.Generic.SerializableDictionary`2.OverwriteSerializedData(`0[],`1[])">
            <summary>
                Overwrite data in the serialized arrays with the provided data.
            </summary>
            <param name="keyArray">An array of keys.</param>
            <param name="valueArray">An array of values.</param>
        </member>
        <member name="M:GDX.Collections.Generic.SerializableDictionary`2.SaveSerializedData">
            <summary>
                Fill serializable arrays from dictionary data.
            </summary>
            <remarks>We will always create the arrays so the property drawers function nicely.</remarks>
        </member>
        <member name="T:GDX.Collections.Generic.NativeSimpleList`1">
            <summary>
                A Unity.Collections.NativeArray`1 backed GDX.Collections.Generic.SimpleList`1.
            </summary>
            <remarks>
                The GDX.Collections.Generic.NativeSimpleList`1 is backed by a Unity.Collections.NativeArray`1 which
                requires
                UnityEngine.CoreModule.dll.
            </remarks>
            <typeparam name="T">The type of System.Objects contained within.</typeparam>
        </member>
        <member name="F:GDX.Collections.Generic.NativeSimpleList`1.Array">
            <summary>
                Internal array of backed data for the GDX.Collections.Generic.SimpleList`1.
            </summary>
        </member>
        <member name="F:GDX.Collections.Generic.NativeSimpleList`1.Count">
            <summary>
                Number of elements.
            </summary>
            <remarks>CAUTION! Changing this will alter the understanding of the data.</remarks>
        </member>
        <member name="M:GDX.Collections.Generic.NativeSimpleList`1.#ctor(System.Int32,Unity.Collections.Allocator,Unity.Collections.NativeArrayOptions)">
            <summary>
                Create a GDX.Collections.Generic.SimpleList`1 with an initial capacity.
            </summary>
            <param name="capacity">An initial sizing for the GDX.Collections.Generic.NativeSimpleList`1.Array.</param>
            <param name="allocator">The Unity.Collections.Allocator type to use.</param>
            <param name="nativeArrayOptions">Should the memory be cleared on allocation?</param>
        </member>
        <member name="M:GDX.Collections.Generic.NativeSimpleList`1.#ctor(Unity.Collections.NativeArray{`0})">
            <summary>
                Create a GDX.Collections.Generic.NativeSimpleList`1 providing an existing arrayToUse.
            </summary>
            <param name="arrayToUse">An existing array to use in the GDX.Collections.Generic.NativeSimpleList`1.</param>
        </member>
        <member name="M:GDX.Collections.Generic.NativeSimpleList`1.#ctor(Unity.Collections.NativeArray{`0},System.Int32)">
            <summary>
                Create a GDX.Collections.Generic.NativeSimpleList`1 providing an existing arrayToUse and setting the
                GDX.Collections.Generic.NativeSimpleList`1.Count.
            </summary>
            <param name="arrayToUse">An existing array to use in the GDX.Collections.Generic.NativeSimpleList`1.</param>
            <param name="count">An existing element count.</param>
        </member>
        <member name="M:GDX.Collections.Generic.NativeSimpleList`1.AddUnchecked(`0)">
            <summary>
                Add an item to the GDX.Collections.Generic.NativeSimpleList`1 without checking the GDX.Collections.Generic.NativeSimpleList`1.Array size.
            </summary>
            <param name="item">A typed System.Object to add.</param>
        </member>
        <member name="M:GDX.Collections.Generic.NativeSimpleList`1.AddWithExpandCheck(`0,Unity.Collections.Allocator,Unity.Collections.NativeArrayOptions)">
            <summary>
                Add an item to the GDX.Collections.Generic.NativeSimpleList`1, checking if GDX.Collections.Generic.NativeSimpleList`1.Array needs to be resized.
            </summary>
            <param name="item">A typed System.Object to add.</param>
            <param name="allocator">The Unity.Collections.Allocator type to use.</param>
            <param name="nativeArrayOptions">Should the memory be cleared on allocation?</param>
        </member>
        <member name="M:GDX.Collections.Generic.NativeSimpleList`1.Clear">
            <summary>
                Clear out the GDX.Collections.Generic.NativeSimpleList`1.Array in GDX.Collections.Generic.NativeSimpleList`1 and sets the GDX.Collections.Generic.NativeSimpleList`1.Count to 0.
            </summary>
        </member>
        <member name="M:GDX.Collections.Generic.NativeSimpleList`1.Dispose">
            <summary>
                Properly dispose of the GDX.Collections.Generic.NativeSimpleList`1.
            </summary>
        </member>
        <member name="M:GDX.Collections.Generic.NativeSimpleList`1.Insert(`0,System.Int32,Unity.Collections.Allocator,Unity.Collections.NativeArrayOptions)">
            <summary>
                Insert an item into the GDX.Collections.Generic.NativeSimpleList`1, checking if GDX.Collections.Generic.NativeSimpleList`1.Array needs to be resized.
            </summary>
            <param name="item">A typed System.Object to insert.</param>
            <param name="index">The index in GDX.Collections.Generic.NativeSimpleList`1.Array to add the item at.</param>
            <param name="allocator">The Unity.Collections.Allocator type to use.</param>
            <param name="nativeArrayOptions">Should the memory be cleared on allocation?</param>
        </member>
        <member name="M:GDX.Collections.Generic.NativeSimpleList`1.RemoveAt(System.Int32)">
            <summary>
                Remove an item from the GDX.Collections.Generic.NativeSimpleList`1 at a specific index.
            </summary>
            <param name="index">The target index.</param>
        </member>
        <member name="M:GDX.Collections.Generic.NativeSimpleList`1.RemoveFromBack">
            <summary>
                Remove the last element in the GDX.Collections.Generic.NativeSimpleList`1.
            </summary>
        </member>
        <member name="T:GDX.Collections.Generic.SimpleList`1">
            <summary>
                A System.Collections.Generic.List`1-like data structure.
            </summary>
            <typeparam name="T">The type of the System.Objects contained within.</typeparam>
        </member>
        <member name="F:GDX.Collections.Generic.SimpleList`1.Array">
            <summary>
                Internal array of backed data for the GDX.Collections.Generic.SimpleList`1.
            </summary>
        </member>
        <member name="F:GDX.Collections.Generic.SimpleList`1.Count">
            <summary>
                The current number of occupied elements in the GDX.Collections.Generic.CircularBuffer`1.
            </summary>
            <remarks>CAUTION! Changing this will alter the understanding of the data.</remarks>
        </member>
        <member name="M:GDX.Collections.Generic.SimpleList`1.#ctor(System.Int32)">
            <summary>
                Create a GDX.Collections.Generic.SimpleList`1 with an initial capacity.
            </summary>
            <param name="capacity">An initial sizing for the GDX.Collections.Generic.SimpleList`1.Array.</param>
        </member>
        <member name="M:GDX.Collections.Generic.SimpleList`1.#ctor(`0[])">
            <summary>
                Create a GDX.Collections.Generic.SimpleList`1 providing an existing arrayToUse.
            </summary>
            <param name="arrayToUse">An existing array to use in the GDX.Collections.Generic.SimpleList`1.</param>
        </member>
        <member name="M:GDX.Collections.Generic.SimpleList`1.#ctor(`0[],System.Int32)">
            <summary>
                Create a GDX.Collections.Generic.SimpleList`1 providing an existing arrayToUse and setting the
                GDX.Collections.Generic.SimpleList`1.Count.
            </summary>
            <param name="arrayToUse">An existing array to use in the GDX.Collections.Generic.SimpleList`1.</param>
            <param name="count">An existing element count.</param>
        </member>
        <member name="M:GDX.Collections.Generic.SimpleList`1.AddUnchecked(`0)">
            <summary>
                Add an item to the GDX.Collections.Generic.SimpleList`1 without checking the GDX.Collections.Generic.SimpleList`1.Array size.
            </summary>
            <param name="item">A typed System.Object to add.</param>
        </member>
        <member name="M:GDX.Collections.Generic.SimpleList`1.AddWithExpandCheck(`0)">
            <summary>
                Add an item to the GDX.Collections.Generic.SimpleList`1, checking if GDX.Collections.Generic.SimpleList`1.Array needs to be resized.
            </summary>
            <param name="item">A typed System.Object to add.</param>
        </member>
        <member name="M:GDX.Collections.Generic.SimpleList`1.AddWithExpandCheck(`0,System.Int32)">
            <summary>
                Add an item to the GDX.Collections.Generic.SimpleList`1, checking if GDX.Collections.Generic.SimpleList`1.Array needs to be resized.
            </summary>
            <param name="item">A typed System.Object to add.</param>
            <param name="howMuchToExpand">How much to expand the array by.</param>
        </member>
        <member name="M:GDX.Collections.Generic.SimpleList`1.Clear">
            <summary>
                Clear out the GDX.Collections.Generic.SimpleList`1.Array in GDX.Collections.Generic.SimpleList`1 and sets the GDX.Collections.Generic.SimpleList`1.Count to 0.
            </summary>
        </member>
        <member name="M:GDX.Collections.Generic.SimpleList`1.Insert(`0,System.Int32)">
            <summary>
                Insert an item into the GDX.Collections.Generic.SimpleList`1, checking if GDX.Collections.Generic.SimpleList`1.Array needs to be resized.
            </summary>
            <param name="item">A typed System.Object to insert.</param>
            <param name="index">The index in GDX.Collections.Generic.SimpleList`1.Array to add the item at.</param>
        </member>
        <member name="M:GDX.Collections.Generic.SimpleList`1.RemoveAt(System.Int32)">
            <summary>
                Remove an item from the GDX.Collections.Generic.SimpleList`1 at a specific index.
            </summary>
            <param name="index">The target index.</param>
        </member>
        <member name="M:GDX.Collections.Generic.SimpleList`1.RemoveFromBack">
            <summary>
                Remove the last element in the GDX.Collections.Generic.SimpleList`1.
            </summary>
        </member>
        <member name="M:GDX.Collections.Generic.SimpleList`1.Reserve(System.Int32)">
            <summary>
                Resizes the GDX.Collections.Generic.SimpleList`1.Array, ensuring there are the provided number of empty spots in it.
            </summary>
            <param name="numberToReserve">Number of desired empty spots.</param>
        </member>
        <member name="T:GDX.Collections.Generic.NativeUniformArray3D`1">
            <summary>
                A 3-Dimensional Unity.Collections.NativeArray`1 backed array.
            </summary>
            <remarks>
                The GDX.Collections.Generic.NativeArray2D`1 is backed by a Unity.Collections.NativeArray`1 which requires
                UnityEngine.CoreModule.dll.
            </remarks>
            <typeparam name="T">Type of objects.</typeparam>
        </member>
        <member name="F:GDX.Collections.Generic.NativeUniformArray3D`1.Array">
            <summary>
                The backing Unity.Collections.NativeArray`1.
            </summary>
        </member>
        <member name="F:GDX.Collections.Generic.NativeUniformArray3D`1.Length">
            <summary>
                The length of GDX.Collections.Generic.NativeUniformArray3D`1.Array.
            </summary>
        </member>
        <member name="F:GDX.Collections.Generic.NativeUniformArray3D`1.Stride">
            <summary>
                The stride of each dimensional segment in GDX.Collections.Generic.NativeUniformArray3D`1.Array.
            </summary>
        </member>
        <member name="F:GDX.Collections.Generic.NativeUniformArray3D`1._strideSquared">
            <summary>
                Cached squared version of GDX.Collections.Generic.NativeUniformArray3D`1.Stride.
            </summary>
        </member>
        <member name="M:GDX.Collections.Generic.NativeUniformArray3D`1.#ctor(System.Int32,Unity.Collections.Allocator,Unity.Collections.NativeArrayOptions)">
            <summary>
                Create a GDX.Collections.Generic.NativeUniformArray3D`1 with a uniform dimensional length.
            </summary>
            <remarks></remarks>
            <param name="stride">X length, Y length and Z length will all be set to this value.</param>
            <param name="allocator">The Unity.Collections.Allocator type to use.</param>
            <param name="nativeArrayOptions">Should the memory be cleared on allocation?</param>
        </member>
        <member name="P:GDX.Collections.Generic.NativeUniformArray3D`1.Item(System.Int32,System.Int32,System.Int32)">
            <summary>
                Access a specific location in the voxel.
            </summary>
            <param name="x">X location index.</param>
            <param name="y">Y location index.</param>
            <param name="z">Z location index.</param>
        </member>
        <member name="P:GDX.Collections.Generic.NativeUniformArray3D`1.Item(Unity.Mathematics.int3)">
            <summary>
                Access a specific location in the voxel.
            </summary>
            <param name="index">A 3-Dimensional index.</param>
        </member>
        <member name="M:GDX.Collections.Generic.NativeUniformArray3D`1.Dispose">
            <summary>
                Properly dispose of the GDX.Collections.Generic.NativeUniformArray3D`1.
            </summary>
        </member>
        <member name="M:GDX.Collections.Generic.NativeUniformArray3D`1.GetFromIndex(System.Int32)">
            <summary>
                Get the 3-Dimensional index of a flat array index.
            </summary>
            <param name="idx">A flat array index.</param>
            <returns>A 3-Dimensional voxel index.</returns>
        </member>
        <member name="T:GDX.Collections.Generic.NativeSimpleQueue`1">
            <summary>
                A Unity.Collections.NativeArray`1 backed simplified first-in, first-out (FIFO) data structure.
            </summary>
            <remarks>
                The GDX.Collections.Generic.NativeSimpleQueue`1 is backed by a Unity.Collections.NativeArray`1 which requires
                UnityEngine.CoreModule.dll.
            </remarks>
            <typeparam name="T">The type of System.Objects contained within.</typeparam>
        </member>
        <member name="F:GDX.Collections.Generic.NativeSimpleQueue`1.MinimumGrow">
            <summary>
                The minimum growth amount of the internal GDX.Collections.Generic.NativeSimpleQueue`1.Array's length.
            </summary>
        </member>
        <member name="F:GDX.Collections.Generic.NativeSimpleQueue`1.Array">
            <summary>
                Internal Unity.Collections.NativeArray`1 of backed data for the GDX.Collections.Generic.NativeSimpleQueue`1.
            </summary>
        </member>
        <member name="F:GDX.Collections.Generic.NativeSimpleQueue`1.Count">
            <summary>
                Number of elements.
            </summary>
        </member>
        <member name="F:GDX.Collections.Generic.NativeSimpleQueue`1.EndIndex">
            <summary>
                Last valid element (tail) index in the queue.
            </summary>
        </member>
        <member name="F:GDX.Collections.Generic.NativeSimpleQueue`1.FirstIndex">
            <summary>
                First valid element (head) index in the queue.
            </summary>
        </member>
        <member name="M:GDX.Collections.Generic.NativeSimpleQueue`1.#ctor(System.Int32,Unity.Collections.Allocator,Unity.Collections.NativeArrayOptions)">
            <summary>
                Create a new GDX.Collections.Generic.NativeSimpleQueue`1.
            </summary>
            <param name="capacity">The maximum number of items allowed in the GDX.Collections.Generic.NativeSimpleQueue`1</param>
            <param name="allocator">The Unity.Collections.Allocator type to use.</param>
            <param name="nativeArrayOptions">Should the memory be cleared on allocation?</param>
        </member>
        <member name="M:GDX.Collections.Generic.NativeSimpleQueue`1.Clear">
            <summary>
                Clear the GDX.Collections.Generic.NativeSimpleQueue`1.
            </summary>
        </member>
        <member name="M:GDX.Collections.Generic.NativeSimpleQueue`1.Dequeue">
            <summary>
                Pop (remove and return) the first element from the GDX.Collections.Generic.NativeSimpleQueue`1.
            </summary>
            <returns>The first element.</returns>
        </member>
        <member name="M:GDX.Collections.Generic.NativeSimpleQueue`1.Dispose">
            <summary>
                Properly dispose of the GDX.Collections.Generic.NativeSimpleQueue`1.
            </summary>
        </member>
        <member name="M:GDX.Collections.Generic.NativeSimpleQueue`1.Enqueue(`0,Unity.Collections.Allocator,Unity.Collections.NativeArrayOptions)">
            <summary>
                Add an item to the GDX.Collections.Generic.NativeSimpleQueue`1 at its end..
            </summary>
            <param name="item">The typed System.Object to add.</param>
            <param name="allocator">The Unity.Collections.Allocator type to use.</param>
            <param name="nativeArrayOptions">Should the memory be cleared on allocation?</param>
        </member>
        <member name="M:GDX.Collections.Generic.NativeSimpleQueue`1.GetElementAt(System.Int32)">
            <summary>
                Retrieve the element at the provided index.
            </summary>
            <param name="index">The target System.Object index.</param>
            <returns>The target element.</returns>
        </member>
        <member name="M:GDX.Collections.Generic.NativeSimpleQueue`1.Peek">
            <summary>
                Retrieve the first element from the GDX.Collections.Generic.NativeSimpleQueue`1.
            </summary>
            <returns>The first element.</returns>
        </member>
        <member name="M:GDX.Collections.Generic.NativeSimpleQueue`1.TrimExcess(Unity.Collections.Allocator,Unity.Collections.NativeArrayOptions)">
            <summary>
                Shrink the capacity of the GDX.Collections.Generic.NativeSimpleQueue`1 to fit its contents.
            </summary>
            <param name="allocator">The Unity.Collections.Allocator type to use.</param>
            <param name="nativeArrayOptions">Should the memory be cleared on allocation?</param>
        </member>
        <member name="M:GDX.Collections.Generic.NativeSimpleQueue`1.SetCapacity(System.Int32,Unity.Collections.Allocator,Unity.Collections.NativeArrayOptions)">
            <summary>
                Resize the capacity of the GDX.Collections.Generic.NativeSimpleQueue`1.
            </summary>
            <param name="capacity">The desired capacity for the GDX.Collections.Generic.NativeSimpleQueue`1</param>
            <param name="allocator">The Unity.Collections.Allocator type to use.</param>
            <param name="nativeArrayOptions">Should the memory be cleared on allocation?</param>
        </member>
        <member name="T:GDX.Collections.Generic.CircularBuffer`1">
            <summary>
                A sized buffer which loops back over itself as elements are used.
            </summary>
            <typeparam name="T">The type of System.Objects contained within.</typeparam>
        </member>
        <member name="F:GDX.Collections.Generic.CircularBuffer`1.Array">
            <summary>
                Internal array of backed data for the GDX.Collections.Generic.CircularBuffer`1.
            </summary>
        </member>
        <member name="F:GDX.Collections.Generic.CircularBuffer`1.Capacity">
            <summary>
                The cached array length for GDX.Collections.Generic.CircularBuffer`1.Array.
            </summary>
        </member>
        <member name="F:GDX.Collections.Generic.CircularBuffer`1.Count">
            <summary>
                The current size of occupied elements in the GDX.Collections.Generic.CircularBuffer`1.
            </summary>
            <remarks>CAUTION! Changing this will alter the understanding of the data.</remarks>
        </member>
        <member name="F:GDX.Collections.Generic.CircularBuffer`1.EndIndex">
            <summary>
                The index of the last item in GDX.Collections.Generic.CircularBuffer`1.Array.
            </summary>
            <remarks>CAUTION! Changing this will alter the understanding of the data.</remarks>
        </member>
        <member name="F:GDX.Collections.Generic.CircularBuffer`1.StartIndex">
            <summary>
                The index of the first item in GDX.Collections.Generic.CircularBuffer`1.Array.
            </summary>
            <remarks>CAUTION! Changing this will alter the understanding of the data.</remarks>
        </member>
        <member name="M:GDX.Collections.Generic.CircularBuffer`1.#ctor(System.Int32)">
            <summary>
                Create a GDX.Collections.Generic.CircularBuffer`1 with a capacity.
            </summary>
            <param name="capacity">The maximum number of items allowed in the GDX.Collections.Generic.CircularBuffer`1</param>
        </member>
        <member name="M:GDX.Collections.Generic.CircularBuffer`1.#ctor(System.Int32,`0[])">
            <summary>
                Create a GDX.Collections.Generic.CircularBuffer`1 with a capacity, filling with
                targetItems.
            </summary>
            <param name="capacity">The maximum number of items allowed in the GDX.Collections.Generic.CircularBuffer`1</param>
            <param name="targetItems">An array of values to fill the GDX.Collections.Generic.CircularBuffer`1 with.</param>
            <exception cref="T:System.ArgumentException">
                Invalid number of entries provided to the GDX.Collections.Generic.CircularBuffer`1
                constructor.
            </exception>
            <exception cref="T:System.ArgumentNullException">No items were provided to the GDX.Collections.Generic.CircularBuffer`1 constructor.</exception>
        </member>
        <member name="P:GDX.Collections.Generic.CircularBuffer`1.Item(System.Int32)">
            <summary>
                Access item at pseudoIndex.
            </summary>
            <param name="pseudoIndex"></param>
            <exception cref="T:System.IndexOutOfRangeException">Provided index is out of buffers range.</exception>
        </member>
        <member name="M:GDX.Collections.Generic.CircularBuffer`1.GetEnumerator">
            <summary>
                Get GDX.Collections.Generic.CircularBuffer`1.Array Enumerator.
            </summary>
            <returns>A System.Collections.Generic.IEnumerator`1 for the GDX.Collections.Generic.CircularBuffer`1.Array.</returns>
        </member>
        <member name="M:GDX.Collections.Generic.CircularBuffer`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
                Get GDX.Collections.Generic.CircularBuffer`1 Enumerator.
            </summary>
            <returns>A System.Collections.Generic.IEnumerator`1 for the GDX.Collections.Generic.CircularBuffer`1.</returns>
        </member>
        <member name="M:GDX.Collections.Generic.CircularBuffer`1.Add(`0)">
            <summary>
                Add an item to the GDX.Collections.Generic.CircularBuffer`1.Array.
            </summary>
            <param name="item">The typed System.Object to add.</param>
        </member>
        <member name="M:GDX.Collections.Generic.CircularBuffer`1.Clear">
            <summary>
                Clear all values of the GDX.Collections.Generic.CircularBuffer`1.Array.
            </summary>
        </member>
        <member name="M:GDX.Collections.Generic.CircularBuffer`1.GetBack">
            <summary>
                Get the last item in the GDX.Collections.Generic.CircularBuffer`1.Array.
            </summary>
            <returns>The last typed object in GDX.Collections.Generic.CircularBuffer`1.Array.</returns>
        </member>
        <member name="M:GDX.Collections.Generic.CircularBuffer`1.GetFront">
            <summary>
                Get the first item in the GDX.Collections.Generic.CircularBuffer`1.Array.
            </summary>
            <returns>The first typed object in GDX.Collections.Generic.CircularBuffer`1.Array.</returns>
        </member>
        <member name="M:GDX.Collections.Generic.CircularBuffer`1.IsEmpty">
            <summary>
                Does the GDX.Collections.Generic.CircularBuffer`1.Array have any items in it?
            </summary>
            <returns>true/false</returns>
        </member>
        <member name="M:GDX.Collections.Generic.CircularBuffer`1.IsFull">
            <summary>
                Is the GDX.Collections.Generic.CircularBuffer`1.Array at capacity?
            </summary>
            <returns>true/false</returns>
        </member>
        <member name="M:GDX.Collections.Generic.CircularBuffer`1.PopBack">
            <summary>
                Remove an item from the end of the GDX.Collections.Generic.CircularBuffer`1.Array.
            </summary>
        </member>
        <member name="M:GDX.Collections.Generic.CircularBuffer`1.PopFront">
            <summary>
                Remove an item from the start of the GDX.Collections.Generic.CircularBuffer`1.Array.
            </summary>
        </member>
        <member name="M:GDX.Collections.Generic.CircularBuffer`1.PushBack(`0)">
            <summary>
                Add an item to the end of the GDX.Collections.Generic.CircularBuffer`1.Array.
            </summary>
            <param name="targetItem">The item to add to the end of GDX.Collections.Generic.CircularBuffer`1.Array.</param>
        </member>
        <member name="M:GDX.Collections.Generic.CircularBuffer`1.PushFront(`0)">
            <summary>
                Add an item to the start of the GDX.Collections.Generic.CircularBuffer`1.Array.
            </summary>
            <param name="targetItem">The item to add to the start of GDX.Collections.Generic.CircularBuffer`1.Array.</param>
        </member>
        <member name="M:GDX.Collections.Generic.CircularBuffer`1.ToArray">
            <summary>
                Copy GDX.Collections.Generic.CircularBuffer`1.Array to an array of the same type.
            </summary>
            <returns>A copied version of the GDX.Collections.Generic.CircularBuffer`1.Array as an array.</returns>
        </member>
        <member name="M:GDX.Collections.Generic.CircularBuffer`1.ArrayOne">
            <summary>
                Get the first array segment of the desired ordered array in the GDX.Collections.Generic.CircularBuffer`1.Array.
            </summary>
            <remarks>
                This is done because the arrays actual order may wrap around from the end of GDX.Collections.Generic.CircularBuffer`1.Array, to the start.
            </remarks>
            <returns>An System.ArraySegment`1 representing the first part of the ordered data in GDX.Collections.Generic.CircularBuffer`1.Array.</returns>
        </member>
        <member name="M:GDX.Collections.Generic.CircularBuffer`1.ArrayTwo">
            <summary>
                Get the second array segment of the desired ordered array in the GDX.Collections.Generic.CircularBuffer`1.Array.
            </summary>
            <remarks>
                This is done because the arrays actual order may wrap around from the end of GDX.Collections.Generic.CircularBuffer`1.Array, to the start.
            </remarks>
            <returns>An System.ArraySegment`1 representing the end part of the ordered data in GDX.Collections.Generic.CircularBuffer`1.Array.</returns>
        </member>
        <member name="T:GDX.Collections.BitArray8">
            <summary>
                A 8-bit array.
            </summary>
            <example>
                Useful for packing a bunch of data with known indices tightly.
                <code>
                    if(myBitArray8[1])
                    {
                        BeAwesome();
                    }
                </code>
            </example>
        </member>
        <member name="F:GDX.Collections.BitArray8.Bits0">
            <summary>
                First reserved System.Byte memory block (8-bits).
            </summary>
            <remarks>Indices 0-7</remarks>
        </member>
        <member name="M:GDX.Collections.BitArray8.#ctor(System.Byte)">
            <summary>
                Create a new GDX.Collections.BitArray8 based on provided bits0.
            </summary>
            <param name="bits0">An existing value to be used to create the backing data for a GDX.Collections.BitArray8</param>
        </member>
        <member name="P:GDX.Collections.BitArray8.Item(System.Byte)">
            <summary>
                Access bit in array.
            </summary>
            <param name="index">Target bit index.</param>
        </member>
        <member name="T:GDX.Collections.BitArray16">
            <summary>
                A 16-bit array.
            </summary>
            <example>
                Useful for packing a bunch of data with known indices tightly.
                <code>
                    if(myBitArray16[1])
                    {
                        BeAwesome();
                    }
                </code>
            </example>
        </member>
        <member name="F:GDX.Collections.BitArray16.Bits0">
            <summary>
                First reserved System.UInt16 memory block (16-bits).
            </summary>
            <remarks>Indices 0-15</remarks>
        </member>
        <member name="M:GDX.Collections.BitArray16.#ctor(System.UInt16)">
            <summary>
                Create a new GDX.Collections.BitArray16 based on provided bits0.
            </summary>
            <param name="bits0">An existing value to be used to create the backing data for a GDX.Collections.BitArray16</param>
        </member>
        <member name="P:GDX.Collections.BitArray16.Item(System.Byte)">
            <summary>
                Access bit in array.
            </summary>
            <param name="index">Target bit index.</param>
        </member>
        <member name="T:GDX.Collections.BitArray256">
            <summary>
                A 256-bit array.
            </summary>
            <example>
                Useful for packing a bunch of data with known indices tightly.
                <code>
                    if(myBitArray256[1])
                    {
                        BeAwesome();
                    }
                </code>
            </example>
        </member>
        <member name="F:GDX.Collections.BitArray256.Bits0">
            <summary>
                First reserved System.Int32 memory block.
            </summary>
            <remarks>Indices 0-31</remarks>
        </member>
        <member name="F:GDX.Collections.BitArray256.Bits1">
            <summary>
                Second reserved System.Int32 memory block.
            </summary>
            <remarks>Indices 32-63</remarks>
        </member>
        <member name="F:GDX.Collections.BitArray256.Bits2">
            <summary>
                Third reserved System.Int32 memory block.
            </summary>
            <remarks>Indices 64-95</remarks>
        </member>
        <member name="F:GDX.Collections.BitArray256.Bits3">
            <summary>
                Fourth reserved System.Int32 memory block.
            </summary>
            <remarks>Indices 96-127</remarks>
        </member>
        <member name="F:GDX.Collections.BitArray256.Bits4">
            <summary>
                Fifth reserved System.Int32 memory block.
            </summary>
            <remarks>Indices 128-159</remarks>
        </member>
        <member name="F:GDX.Collections.BitArray256.Bits5">
            <summary>
                Sixth reserved System.Int32 memory block.
            </summary>
            <remarks>Indices 160-191</remarks>
        </member>
        <member name="F:GDX.Collections.BitArray256.Bits6">
            <summary>
                Seventh reserved System.Int32 memory block.
            </summary>
            <remarks>Indices 192-223</remarks>
        </member>
        <member name="F:GDX.Collections.BitArray256.Bits7">
            <summary>
                Eighth reserved System.Int32 memory block.
            </summary>
            <remarks>Indices 224-255</remarks>
        </member>
        <member name="P:GDX.Collections.BitArray256.Item(System.Int32)">
            <summary>
                Access bit in array.
            </summary>
            <param name="index">Target bit index.</param>
        </member>
        <member name="T:GDX.Collections.Pooling.ListManagedPool">
            <summary>
                A System.Object System.Collections.Generic.List`1 backed pool implementation.
            </summary>
        </member>
        <member name="F:GDX.Collections.Pooling.ListManagedPool.AllowCreateMoreFlag">
            <summary>
                The GDX.Collections.Pooling.ListManagedPool.Flags index used to determine if the GDX.Collections.Pooling.ListManagedPool is able to create
                more items as necessary.
            </summary>
        </member>
        <member name="F:GDX.Collections.Pooling.ListManagedPool.AllowManagedTeardownFlag">
            <summary>
                The GDX.Collections.Pooling.ListManagedPool.Flags index used to if GDX.Collections.Pooling.ListManagedPool.TearDown can be called by a manager.
            </summary>
        </member>
        <member name="F:GDX.Collections.Pooling.ListManagedPool.AllowReuseFlag">
            <summary>
                The GDX.Collections.Pooling.ListManagedPool.Flags index used to determine if items should be reused when the pool is starved.
            </summary>
        </member>
        <member name="F:GDX.Collections.Pooling.ListManagedPool.PrewarmPoolFlag">
            <summary>
                The GDX.Collections.Pooling.ListManagedPool.Flags index used to determine if the pool should create items during its constructor.
            </summary>
        </member>
        <member name="F:GDX.Collections.Pooling.ListManagedPool._baseObject">
            <summary>
                The object which the pool is based off of, used as a model when creating new items.
            </summary>
        </member>
        <member name="F:GDX.Collections.Pooling.ListManagedPool._containerObject">
            <summary>
                The object which serves as a container for all objects of the pool.
            </summary>
            <remarks>Used more by implementations of pools, then this base class.</remarks>
        </member>
        <member name="F:GDX.Collections.Pooling.ListManagedPool._createItemFunc">
            <summary>
                A defined function to create items for the pool.
            </summary>
        </member>
        <member name="F:GDX.Collections.Pooling.ListManagedPool._inItems">
            <summary>
                A collection of items that are currently contained in the pool for use when spawning items upon request.
            </summary>
        </member>
        <member name="F:GDX.Collections.Pooling.ListManagedPool._key">
            <summary>
                The absolutely unique identifier for this pool.
            </summary>
        </member>
        <member name="F:GDX.Collections.Pooling.ListManagedPool._maximumObjects">
            <summary>
                The Maximum number of objects to be managed by the pool.
            </summary>
        </member>
        <member name="F:GDX.Collections.Pooling.ListManagedPool._minimumObjects">
            <summary>
                The minimum number of objects to be managed by the pool.
            </summary>
        </member>
        <member name="F:GDX.Collections.Pooling.ListManagedPool._outItems">
            <summary>
                A collection of items that are currently considered out of the pool, that have been spawned.
            </summary>
        </member>
        <member name="F:GDX.Collections.Pooling.ListManagedPool._inCount">
            <summary>
                A cached count of the number of items contained in GDX.Collections.Pooling.ListManagedPool._inItems.
            </summary>
        </member>
        <member name="F:GDX.Collections.Pooling.ListManagedPool._outCount">
            <summary>
                A cached count of the number of items contained in GDX.Collections.Pooling.ListManagedPool._outItems.
            </summary>
        </member>
        <member name="F:GDX.Collections.Pooling.ListManagedPool.Flags">
            <summary>
                A GDX.Collections.BitArray8 used to store pool based flags, as well as provide additional spots for implementations.
            </summary>
            <remarks>
                Index 0-3 (GDX.Collections.Pooling.ListManagedPool.AllowCreateMoreFlag, GDX.Collections.Pooling.ListManagedPool.AllowManagedTeardownFlag,
                GDX.Collections.Pooling.ListManagedPool.AllowReuseFlag, and GDX.Collections.Pooling.ListManagedPool.PrewarmPoolFlag) are used by the
                GDX.Collections.Pooling.ListManagedPool itself, leaving 4-7 for additional use.
            </remarks>
        </member>
        <member name="F:GDX.Collections.Pooling.ListManagedPool.OnDestroyItem">
            <summary>
                A <c>delegate</c> call made when an item is destroyed by the GDX.Collections.Pooling.ListManagedPool.
            </summary>
        </member>
        <member name="F:GDX.Collections.Pooling.ListManagedPool.OnReturnedToPool">
            <summary>
                A <c>delegate</c> call made when an item is returned to the GDX.Collections.Pooling.ListManagedPool.
            </summary>
        </member>
        <member name="F:GDX.Collections.Pooling.ListManagedPool.OnSpawnedFromPool">
            <summary>
                A <c>delegate</c> call made when an item is spawned from the GDX.Collections.Pooling.ListManagedPool.
            </summary>
        </member>
        <member name="F:GDX.Collections.Pooling.ListManagedPool.OnTearDown">
            <summary>
                A <c>delegate</c> call made when a pool is tearing down, before the items are pooled.
            </summary>
        </member>
        <member name="M:GDX.Collections.Pooling.ListManagedPool.#ctor(System.Object,System.Func{GDX.Collections.Pooling.ListManagedPool,System.Object},System.Int32,System.Int32,System.Object,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
                Create a GDX.Collections.Pooling.ListManagedPool.
            </summary>
            <param name="baseObject">The object which going to be cloned.</param>
            <param name="createItemFunc">The function used to create new items for the pool.</param>
            <param name="minimumObjects">The minimum number of objects to be managed by the pool.</param>
            <param name="maximumObjects">The maximum number of objects to be managed by the pool.</param>
            <param name="containerObject">A reference to an object which should be used as the container for created items.</param>
            <param name="prewarmPool">Should this pool create its items during the constructor?</param>
            <param name="allowCreateMore">Can more items be created as needed when starved for items?</param>
            <param name="allowReuseWhenCapped">Should we reuse oldest items when starving for items?</param>
            <param name="allowManagedTearDown">Does the pool allow a managed tear down event call?</param>
        </member>
        <member name="M:GDX.Collections.Pooling.ListManagedPool.CreateItem">
            <inheritdoc />
        </member>
        <member name="M:GDX.Collections.Pooling.ListManagedPool.ForceRemove(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:GDX.Collections.Pooling.ListManagedPool.Get(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:GDX.Collections.Pooling.ListManagedPool.GetBaseObject">
            <inheritdoc />
        </member>
        <member name="M:GDX.Collections.Pooling.ListManagedPool.GetKey">
            <inheritdoc />
        </member>
        <member name="M:GDX.Collections.Pooling.ListManagedPool.HasMinimumPooledItems">
            <inheritdoc />
        </member>
        <member name="M:GDX.Collections.Pooling.ListManagedPool.IsAllowedManagedTearDown">
            <inheritdoc />
        </member>
        <member name="M:GDX.Collections.Pooling.ListManagedPool.IsManaged(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:GDX.Collections.Pooling.ListManagedPool.IsPooled(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:GDX.Collections.Pooling.ListManagedPool.Return(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:GDX.Collections.Pooling.ListManagedPool.ReturnAll(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:GDX.Collections.Pooling.ListManagedPool.TearDown">
            <inheritdoc />
        </member>
        <member name="M:GDX.Collections.Pooling.ListManagedPool.Finalize">
            <summary>
                The GDX.Collections.Pooling.ListManagedPool destructor which unregisters itself from GDX.Collections.Pooling.ManagedPools.
            </summary>
        </member>
        <member name="T:GDX.Collections.Pooling.IManagedPool">
            <summary>
                An interface describing the functionality needed for a pool to be understood by GDX.Collections.Pooling.ManagedPools.
            </summary>
        </member>
        <member name="M:GDX.Collections.Pooling.IManagedPool.CreateItem">
            <summary>
                Create a pooled item and add it to the GDX.Collections.Pooling.IManagedPool.
            </summary>
        </member>
        <member name="M:GDX.Collections.Pooling.IManagedPool.ForceRemove(System.Object)">
            <summary>
                Remove an item from an GDX.Collections.Pooling.IManagedPool immediately, removing it from tracking and
                not calling any actions on it.
            </summary>
            <param name="item">The target System.Object to attempt to remove.</param>
        </member>
        <member name="M:GDX.Collections.Pooling.IManagedPool.Get(System.Boolean)">
            <summary>
                Get the next available item from an GDX.Collections.Pooling.IManagedPool.
            </summary>
            <returns>An item if available, otherwise null.</returns>
        </member>
        <member name="M:GDX.Collections.Pooling.IManagedPool.GetBaseObject">
            <summary>
                Return the System.Object which the pool is built from.
            </summary>
            <returns>The System.Object the GDX.Collections.Pooling.IManagedPool is modelled around.</returns>
        </member>
        <member name="M:GDX.Collections.Pooling.IManagedPool.GetKey">
            <summary>
                Get the unique identifier for the GDX.Collections.Pooling.IManagedPool.
            </summary>
            <returns>A unique identifier.</returns>
        </member>
        <member name="M:GDX.Collections.Pooling.IManagedPool.HasMinimumPooledItems">
            <summary>
                Does the GDX.Collections.Pooling.IManagedPool contain the minimum number of items.
            </summary>
            <returns>true/false if enough items are found contained in the GDX.Collections.Pooling.IManagedPool.</returns>
        </member>
        <member name="M:GDX.Collections.Pooling.IManagedPool.IsAllowedManagedTearDown">
            <summary>
                Should theGDX.Collections.Pooling.IManagedPool destroy itself when GDX.Collections.Pooling.ManagedPools requests a tear down?
            </summary>
            <returns>true/false if flagged to allow for managed tear down / clean up.</returns>
        </member>
        <member name="M:GDX.Collections.Pooling.IManagedPool.IsManaged(System.Object)">
            <summary>
                Is the item managed by this GDX.Collections.Pooling.IManagedPool?
            </summary>
            <param name="item">The System.Object to evaluate.</param>
            <returns>true/false if the item is managed by the GDX.Collections.Pooling.IManagedPool.</returns>
        </member>
        <member name="M:GDX.Collections.Pooling.IManagedPool.IsPooled(System.Object)">
            <summary>
                Is the provided item found in the GDX.Collections.Pooling.IManagedPool's internal available pool of
                objects?
            </summary>
            <param name="item">The item to evaluate.</param>
        </member>
        <member name="M:GDX.Collections.Pooling.IManagedPool.Return(System.Object)">
            <summary>
                Return the item to the GDX.Collections.Pooling.IManagedPool's internal collection.
            </summary>
            <param name="item">The item to return to the GDX.Collections.Pooling.IManagedPool.</param>
        </member>
        <member name="M:GDX.Collections.Pooling.IManagedPool.ReturnAll(System.Boolean)">
            <summary>
                Return all spawned System.Objects to the GDX.Collections.Pooling.IManagedPool.
            </summary>
            <remarks>Shrinking the pools helps with pools that have grown out of necessity past their maximum size</remarks>
            <param name="shouldShrink">Should the GDX.Collections.Pooling.IManagedPool be shrunk to its original maximum size?</param>
        </member>
        <member name="M:GDX.Collections.Pooling.IManagedPool.TearDown">
            <summary>
                Destroy all System.Objects associated with the GDX.Collections.Pooling.IManagedPool.
            </summary>
        </member>
        <member name="T:GDX.Collections.Pooling.GameObjectPool">
            <summary>
                UnityEngine.GameObject based functionality extending the GDX.Collections.Pooling.ListManagedPool to better support
                UnityEngine.GameObject patterns.
            </summary>
        </member>
        <member name="F:GDX.Collections.Pooling.GameObjectPool.HasInterfaceFlag">
            <summary>
                The GDX.Collections.Pooling.ListManagedPool flags index used to determine if the object which is used to create new objects
                has the GDX.Collections.Pooling.IGameObjectPoolItem interface on a root component.
            </summary>
        </member>
        <member name="M:GDX.Collections.Pooling.GameObjectPool.CreatePool(UnityEngine.GameObject,UnityEngine.Transform,System.Int32,System.Int32,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
                Create a UnityEngine.GameObject based GDX.Collections.Pooling.ListManagedPool for the provided
                gameObject.
            </summary>
            <param name="gameObject">The object which going to be cloned.</param>
            <param name="parent">The container object.</param>
            <param name="minimumObjects">The minimum number of objects to be pooled.</param>
            <param name="maximumObjects">The maximum number of objects to be pooled.</param>
            <param name="allowCreateMore">Can more items be created as needed when starved for items?</param>
            <param name="allowReuseWhenCapped">Should we reuse oldest items when starving for items?</param>
            <param name="allowManagedTearDown">Does the pool allow a managed tear down event call?</param>
        </member>
        <member name="M:GDX.Collections.Pooling.GameObjectPool.Get(GDX.Collections.Pooling.ListManagedPool,System.Boolean)">
            <summary>
                Get the next available item from the pool.
            </summary>
            <param name="pool">The GDX.Collections.Pooling.ListManagedPool created with GDX.Collections.Pooling.GameObjectPool to pull an item from.</param>
            <param name="triggerOnSpawnedFromPool">Should the GDX.Collections.Pooling.GameObjectPool.OnSpawnedFromPoolAction(GDX.Collections.Pooling.ListManagedPool,System.Object) be called when getting this item.</param>
            <returns>A UnityEngine.GameObject from the GDX.Collections.Pooling.ListManagedPool, or null if no item is available.</returns>
        </member>
        <member name="M:GDX.Collections.Pooling.GameObjectPool.Get(GDX.Collections.Pooling.ListManagedPool,UnityEngine.Transform,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
                Get the next available item from the pool and parent it to a UnityEngine.Transform.
            </summary>
            <param name="pool">The GDX.Collections.Pooling.ListManagedPool created with GDX.Collections.Pooling.GameObjectPool to pull an item from.</param>
            <param name="parent">The transform parent on the item pulled from the GDX.Collections.Pooling.ListManagedPool.</param>
            <param name="worldPositionStays">Ensure that the world position of the item pulled from the GDX.Collections.Pooling.ListManagedPool remains the same through parenting.</param>
            <param name="zeroLocalPosition">Set the local position of the item pulled from the GDX.Collections.Pooling.ListManagedPool to being P:UnityEngine.Vector3.zero after parenting.</param>
            <param name="triggerOnSpawnedFromPool">Should the GDX.Collections.Pooling.GameObjectPool.OnSpawnedFromPoolAction(GDX.Collections.Pooling.ListManagedPool,System.Object) be called when getting this item.</param>
            <returns>A UnityEngine.GameObject from the GDX.Collections.Pooling.ListManagedPool, or null if no item is available.</returns>
        </member>
        <member name="M:GDX.Collections.Pooling.GameObjectPool.Get(GDX.Collections.Pooling.ListManagedPool,UnityEngine.Transform,UnityEngine.Vector3,UnityEngine.Quaternion,System.Boolean)">
            <summary>
                Get the next available item from the pool, parent it to a UnityEngine.Transform, and then set it's local position and rotation.
            </summary>
            <param name="pool">The GDX.Collections.Pooling.ListManagedPool created with GDX.Collections.Pooling.GameObjectPool to pull an item from.</param>
            <param name="parent">The transform parent on the item pulled from the GDX.Collections.Pooling.ListManagedPool.</param>
            <param name="localPosition">The local position to set on the item pulled from the GDX.Collections.Pooling.ListManagedPool after parenting.</param>
            <param name="localRotation">The local rotation to set on the item pulled from the GDX.Collections.Pooling.ListManagedPool after parenting.</param>
            <param name="triggerOnSpawnedFromPool">Should the GDX.Collections.Pooling.GameObjectPool.OnSpawnedFromPoolAction(GDX.Collections.Pooling.ListManagedPool,System.Object) be called when getting this item.</param>
            <returns>A UnityEngine.GameObject from the GDX.Collections.Pooling.ListManagedPool, or null if no item is available.</returns>
        </member>
        <member name="M:GDX.Collections.Pooling.GameObjectPool.Get(GDX.Collections.Pooling.ListManagedPool,UnityEngine.Transform,UnityEngine.Vector3,UnityEngine.Vector3,System.Boolean)">
            <summary>
                Get the next available item from the pool, parent it to a UnityEngine.Transform, and then setting it's local position and where it is looking.
            </summary>
            <param name="pool">The GDX.Collections.Pooling.ListManagedPool created with GDX.Collections.Pooling.GameObjectPool to pull an item from.</param>
            <param name="parent">The transform parent on the item pulled from the GDX.Collections.Pooling.ListManagedPool.</param>
            <param name="localPosition">The local position to set on the item pulled from the GDX.Collections.Pooling.ListManagedPool after parenting.</param>
            <param name="worldLookAtPosition">The world position to have the item pulled from the GDX.Collections.Pooling.ListManagedPool look at</param>
            <param name="triggerOnSpawnedFromPool">Should the GDX.Collections.Pooling.GameObjectPool.OnSpawnedFromPoolAction(GDX.Collections.Pooling.ListManagedPool,System.Object) be called when getting this item.</param>
            <returns>A UnityEngine.GameObject from the GDX.Collections.Pooling.ListManagedPool, or null if no item is available.</returns>
        </member>
        <member name="M:GDX.Collections.Pooling.GameObjectPool.Get(GDX.Collections.Pooling.ListManagedPool,UnityEngine.Vector3,UnityEngine.Vector3,System.Boolean)">
            <summary>
                Get the next available item from the pool, and set its world position and where it is looking.
            </summary>
            <param name="pool">The GDX.Collections.Pooling.ListManagedPool created with GDX.Collections.Pooling.GameObjectPool to pull an item from.</param>
            <param name="worldPosition">The world position to set on the item pulled from the GDX.Collections.Pooling.ListManagedPool.</param>
            <param name="worldLookAtPosition">The world position to have the item pulled from the GDX.Collections.Pooling.ListManagedPool look at</param>
            <param name="triggerOnSpawnedFromPool">Should the GDX.Collections.Pooling.GameObjectPool.OnSpawnedFromPoolAction(GDX.Collections.Pooling.ListManagedPool,System.Object) be called when getting this item.</param>
            <returns>A UnityEngine.GameObject from the GDX.Collections.Pooling.ListManagedPool, or null if no item is available.</returns>
        </member>
        <member name="M:GDX.Collections.Pooling.GameObjectPool.Get(GDX.Collections.Pooling.ListManagedPool,UnityEngine.Vector3,UnityEngine.Quaternion,System.Boolean)">
            <summary>
                Get the next available item from the pool, and set its world position and rotation.
            </summary>
            <param name="pool">The GDX.Collections.Pooling.ListManagedPool created with GDX.Collections.Pooling.GameObjectPool to pull an item from.</param>
            <param name="worldPosition">The world position to set on the item pulled from the GDX.Collections.Pooling.ListManagedPool.</param>
            <param name="worldRotation">The world rotation to set on the item pulled from the GDX.Collections.Pooling.ListManagedPool.</param>
            <param name="triggerOnSpawnedFromPool">Should the GDX.Collections.Pooling.GameObjectPool.OnSpawnedFromPoolAction(GDX.Collections.Pooling.ListManagedPool,System.Object) be called when getting this item.</param>
            <returns>A UnityEngine.GameObject from the GDX.Collections.Pooling.ListManagedPool, or null if no item is available.</returns>
        </member>
        <member name="M:GDX.Collections.Pooling.GameObjectPool.Get(GDX.Collections.Pooling.ListManagedPool,UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Transform,System.Boolean)">
            <summary>
                Get the next available item from the pool, and set its world position and rotation after parenting.
            </summary>
            <param name="pool">The GDX.Collections.Pooling.ListManagedPool created with GDX.Collections.Pooling.GameObjectPool to pull an item from.</param>
            <param name="worldPosition">The world position to set on the item pulled from the GDX.Collections.Pooling.ListManagedPool after parenting.</param>
            <param name="worldRotation">The world rotation to set on the item pulled from the GDX.Collections.Pooling.ListManagedPool after parenting.</param>
            <param name="parent">The transform parent on the item pulled from the GDX.Collections.Pooling.ListManagedPool.</param>
            <param name="triggerOnSpawnedFromPool">Should the GDX.Collections.Pooling.GameObjectPool.OnSpawnedFromPoolAction(GDX.Collections.Pooling.ListManagedPool,System.Object) be called when getting this item.</param>
            <returns>A UnityEngine.GameObject from the GDX.Collections.Pooling.ListManagedPool, or null if no item is available.</returns>
        </member>
        <member name="M:GDX.Collections.Pooling.GameObjectPool.Get(GDX.Collections.Pooling.ListManagedPool,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Transform,System.Boolean)">
            <summary>
                Get the next available item from the pool, and set its world position and look at position after parenting.
            </summary>
            <param name="pool">The GDX.Collections.Pooling.ListManagedPool created with GDX.Collections.Pooling.GameObjectPool to pull an item from.</param>
            <param name="worldPosition">The world position to set on the item pulled from the GDX.Collections.Pooling.ListManagedPool after parenting.</param>
            <param name="worldLookAtPosition">The world position to have the item pulled from the GDX.Collections.Pooling.ListManagedPool look at after parenting.</param>
            <param name="parent">The transform parent on the item pulled from the GDX.Collections.Pooling.ListManagedPool.</param>
            <param name="triggerOnSpawnedFromPool">Should the GDX.Collections.Pooling.GameObjectPool.OnSpawnedFromPoolAction(GDX.Collections.Pooling.ListManagedPool,System.Object) be called when getting this item.</param>
            <returns>A UnityEngine.GameObject from the GDX.Collections.Pooling.ListManagedPool, or null if no item is available.</returns>
        </member>
        <member name="M:GDX.Collections.Pooling.GameObjectPool.GetOrCreatePool(UnityEngine.GameObject,UnityEngine.Transform,System.Int32,System.Int32,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
                Gets a pool for the gameObject, or creates a new GDX.Collections.Pooling.ListManagedPool for it.
            </summary>
            <param name="gameObject">The object which going to be cloned.</param>
            <param name="parent">The container object.</param>
            <param name="minimumObjects">The minimum number of objects to be pooled.</param>
            <param name="maximumObjects">The maximum number of objects to be pooled.</param>
            <param name="allowCreateMore">Can more items be created as needed when starved for items?</param>
            <param name="allowReuseWhenCapped">Should we reuse oldest items when starving for items?</param>
            <param name="allowManagedTearDown">Does the pool allow a managed tear down event call?</param>
        </member>
        <member name="M:GDX.Collections.Pooling.GameObjectPool.CreateItem(GDX.Collections.Pooling.ListManagedPool)">
            <summary>
                Create a new item for the pool.
            </summary>
            <param name="pool">The GDX.Collections.Pooling.ListManagedPool to create an item for, and assign too.</param>
            <returns>The newly created item.</returns>
        </member>
        <member name="M:GDX.Collections.Pooling.GameObjectPool.OnDestroyItemAction(System.Object)">
            <summary>
                The subscribed action called when an item is requested to be destroyed..
            </summary>
            <param name="item">The item being destroyed.</param>
        </member>
        <member name="M:GDX.Collections.Pooling.GameObjectPool.OnReturnedToPoolAction(GDX.Collections.Pooling.ListManagedPool,System.Object)">
            <summary>
                The subscribed action called when an item is returned to the pool.
            </summary>
            <param name="pool">The GDX.Collections.Pooling.ListManagedPool which the item is being returned to.</param>
            <param name="item">The item being returned to the pool.</param>
        </member>
        <member name="M:GDX.Collections.Pooling.GameObjectPool.OnSpawnedFromPoolAction(GDX.Collections.Pooling.ListManagedPool,System.Object)">
            <summary>
                The subscribed action called when an item is spawned from the pool.
            </summary>
            <param name="pool">The GDX.Collections.Pooling.ListManagedPool which has had the item spawned from.</param>
            <param name="item">The spawned item.</param>
        </member>
        <member name="M:GDX.Collections.Pooling.GameObjectPool.OnTearDownAction(GDX.Collections.Pooling.ListManagedPool)">
            <summary>
                The subscribed action called when the pool is asked to GDX.Collections.Pooling.IManagedPool.TearDown before items were returned to the pool.
            </summary>
            <param name="pool">The GDX.Collections.Pooling.ListManagedPool being torn down.</param>
        </member>
        <member name="T:GDX.Collections.Pooling.ManagedPoolBuilder">
            <summary>
                A time-slicing builder behaviour for GDX.Collections.Pooling.IManagedPool.
            </summary>
            <remarks>A demonstration of usage can be found in GDX.Collections.Pooling.GameObjectPool.</remarks>
        </member>
        <member name="F:GDX.Collections.Pooling.ManagedPoolBuilder.InstantiatesPerFrame">
            <summary>
                The number of instantiates to make per frame.
            </summary>
            <remarks>
                During defined loading periods this value could be increased for faster allocations,
                and then returned to a much more performant value afterwards.
            </remarks>
        </member>
        <member name="F:GDX.Collections.Pooling.ManagedPoolBuilder.DestroyBuilderOnFinish">
            <summary>
                Should the GDX.Collections.Pooling.ManagedPoolBuilder destroy itself when finished?
            </summary>
        </member>
        <member name="F:GDX.Collections.Pooling.ManagedPoolBuilder.s_builderObject">
            <summary>
                A cached reference to the UnityEngine.GameObject the builder created for itself.
            </summary>
        </member>
        <member name="F:GDX.Collections.Pooling.ManagedPoolBuilder.s_targetPools">
            <summary>
                A System.Collections.Generic.List`1 of GDX.Collections.Pooling.IManagedPool which are being built out.
            </summary>
        </member>
        <member name="F:GDX.Collections.Pooling.ManagedPoolBuilder.s_targetPoolsCount">
            <summary>
                A cached numerical count of the number of GDX.Collections.Pooling.IManagedPool contained in GDX.Collections.Pooling.ManagedPoolBuilder.s_targetPools.
            </summary>
        </member>
        <member name="M:GDX.Collections.Pooling.ManagedPoolBuilder.LateUpdate">
            <summary>
                Unity's LateUpdate event
            </summary>
        </member>
        <member name="M:GDX.Collections.Pooling.ManagedPoolBuilder.AddManagedPool(GDX.Collections.Pooling.IManagedPool)">
            <summary>
                Add an GDX.Collections.Pooling.IManagedPool to the builder to be built out.
            </summary>
            <param name="targetManagedPool">The GDX.Collections.Pooling.IManagedPool to build out.</param>
        </member>
        <member name="M:GDX.Collections.Pooling.ManagedPoolBuilder.RemoveManagedPool(GDX.Collections.Pooling.IManagedPool)">
            <summary>
                Remove an GDX.Collections.Pooling.IManagedPool from the builder.
            </summary>
            <param name="targetManagedPool">The GDX.Collections.Pooling.IManagedPool to be removed.</param>
        </member>
        <member name="M:GDX.Collections.Pooling.ManagedPoolBuilder.Tick">
            <summary>
                Extracted tick update for the builder; creating a limited number of items per tick.
            </summary>
        </member>
        <member name="T:GDX.Collections.Pooling.IGameObjectPoolItem">
            <summary>
                An interface describing the functionality needed for an item to be understood by GDX.Collections.Pooling.GameObjectPool,
                if callbacks are to be made.
            </summary>
        </member>
        <member name="M:GDX.Collections.Pooling.IGameObjectPoolItem.GetParentPool">
            <summary>
                Return the GDX.Collections.Pooling.IManagedPool which the GDX.Collections.Pooling.IGameObjectPoolItem is currently managed by.
            </summary>
            <remarks>It is possible that a pooled item may exist without a parent in some custom scenario.</remarks>
            <returns>
                An GDX.Collections.Pooling.IManagedPool if the GDX.Collections.Pooling.IGameObjectPoolItem is attached to a pool, otherwise
                null.
            </returns>
        </member>
        <member name="M:GDX.Collections.Pooling.IGameObjectPoolItem.IsValidItem">
            <summary>
                Is the GDX.Collections.Pooling.IGameObjectPoolItem thought to be valid?
            </summary>
            <remarks>
                Sometimes a UnityEngine.GameObject may get destroyed without the pool knowing, this contains
                checks to validate if the item can be returned to a pool and reused appropriately.
            </remarks>
            <returns>true/false if the item is found to be valid.</returns>
        </member>
        <member name="M:GDX.Collections.Pooling.IGameObjectPoolItem.OnReturnedToPool">
            <summary>
                Called when this item is returned to the GDX.Collections.Pooling.IManagedPool.
            </summary>
            <remarks>
                This should handle everything, including disabling the UnityEngine.GameObject.
            </remarks>
        </member>
        <member name="M:GDX.Collections.Pooling.IGameObjectPoolItem.OnSpawnedFromPool">
            <summary>
                Called when this item is spawned from the GDX.Collections.Pooling.IManagedPool.
            </summary>
            <remarks>
                This should handle everything, including enabling the UnityEngine.GameObject.
            </remarks>
        </member>
        <member name="M:GDX.Collections.Pooling.IGameObjectPoolItem.ReturnToPool">
            <summary>
                Return the item to the GDX.Collections.Pooling.IManagedPool which it is associated too.
            </summary>
        </member>
        <member name="M:GDX.Collections.Pooling.IGameObjectPoolItem.SetParentPool(GDX.Collections.Pooling.IManagedPool)">
            <summary>
                Set the GDX.Collections.Pooling.IManagedPool which this item believes it belongs too.
            </summary>
            <remarks>This is used during creation to assign the parent that is creating the item.</remarks>
            <param name="targetManagedPool">The parent GDX.Collections.Pooling.IManagedPool.</param>
        </member>
        <member name="T:GDX.Collections.Pooling.ManagedPools">
            <summary>
                A managed pooling system implementation primarily meant for the object oriented patterns, based on the C# base
                object.
            </summary>
        </member>
        <member name="F:GDX.Collections.Pooling.ManagedPools.s_lastPoolKey">
            <summary>
                The last issued pool key used by internal dictionary's System.Collections.Generic.KeyValuePair`2 when referencing an
                GDX.Collections.Pooling.IManagedPool.
            </summary>
            <remarks>
                This value resets on domain reload, and as such the keys should not be relied on through any sort of
                serialization (including networking) or session based process.
            </remarks>
        </member>
        <member name="F:GDX.Collections.Pooling.ManagedPools.s_pools">
            <summary>
                An internal dictionary containing the GDX.Collections.Pooling.IManagedPools, uniquely indexed by constant ticket-like
                system.
            </summary>
        </member>
        <member name="M:GDX.Collections.Pooling.ManagedPools.GetNextPoolKey">
            <summary>
                Get the next available pool key.
            </summary>
            <remarks>Increments the previously issued stored value, and returns the new value.</remarks>
            <returns>A unique pool identifying key.</returns>
        </member>
        <member name="M:GDX.Collections.Pooling.ManagedPools.GetPool(System.UInt32)">
            <summary>
                Get a registered GDX.Collections.Pooling.IManagedPool based on its key.
            </summary>
            <param name="key">The unique key to use when looking for the GDX.Collections.Pooling.IManagedPool.</param>
            <returns>An GDX.Collections.Pooling.IManagedPool identified by the provided key.</returns>
        </member>
        <member name="M:GDX.Collections.Pooling.ManagedPools.GetPool``1(System.UInt32)">
            <summary>
                Get a registered GDX.Collections.Pooling.IManagedPool based on its key.
            </summary>
            <param name="key">The unique key to use when looking for the GDX.Collections.Pooling.IManagedPool.</param>
            <typeparam name="T">The type of the pool, used to cast the return pool</typeparam>
            <returns>A type casted pool identified by the provided key.</returns>
        </member>
        <member name="M:GDX.Collections.Pooling.ManagedPools.GetPoolWithContainsCheck(System.UInt32)">
            <summary>
                Get a registered GDX.Collections.Pooling.IManagedPool based on its key, first checking if it is
                registered.
            </summary>
            <param name="key">The unique key to use when looking for the GDX.Collections.Pooling.IManagedPool.</param>
            <returns>An GDX.Collections.Pooling.IManagedPool identified by the provided key, null if not found.</returns>
        </member>
        <member name="M:GDX.Collections.Pooling.ManagedPools.GetPoolWithContainsCheck``1(System.UInt32)">
            <summary>
                Get a registered GDX.Collections.Pooling.IManagedPool based on its key, first checking if it is
                registered.
            </summary>
            <param name="key">The unique key to use when looking for the GDX.Collections.Pooling.IManagedPool.</param>
            <typeparam name="T">The type of the pool, used to cast the return pool</typeparam>
            <returns>A type casted pool identified by the provided key, null if not found.</returns>
        </member>
        <member name="M:GDX.Collections.Pooling.ManagedPools.HasPool(System.UInt32)">
            <summary>
                Is an GDX.Collections.Pooling.IManagedPool registered with the provided key?
            </summary>
            <param name="key">A unique pool key</param>
            <returns>true if a pool is found registered with this system, false otherwise.</returns>
        </member>
        <member name="M:GDX.Collections.Pooling.ManagedPools.ReturnAll(System.Boolean)">
            <summary>
                Attempts to return all spawned items to their original GDX.Collections.Pooling.IManagedPools.
            </summary>
            <param name="shouldShrink">Should the pool be shrunk (destroying created items) to its original set minimum size?</param>
        </member>
        <member name="M:GDX.Collections.Pooling.ManagedPools.Register(GDX.Collections.Pooling.IManagedPool)">
            <summary>
                Register a GDX.Collections.Pooling.IManagedPool with the global management system.
            </summary>
            <param name="managedPool">Target GDX.Collections.Pooling.IManagedPool</param>
        </member>
        <member name="M:GDX.Collections.Pooling.ManagedPools.TearDown(System.Boolean)">
            <summary>
                Execute GDX.Collections.Pooling.IManagedPool.TearDown (destroying contents) on all registered GDX.Collections.Pooling.IManagedPool
                which have been flagged to accept it, evaluated by GDX.Collections.Pooling.IManagedPool.IsAllowedManagedTearDown.
            </summary>
            <remarks>
                This will unregister the GDX.Collections.Pooling.IManagedPool itself as well.
            </remarks>
            <param name="forceAll">
                Execute GDX.Collections.Pooling.IManagedPool.TearDown regardless of the
                GDX.Collections.Pooling.IManagedPool.IsAllowedManagedTearDown response.
            </param>
        </member>
        <member name="M:GDX.Collections.Pooling.ManagedPools.TryGetFirstPool(System.Object,GDX.Collections.Pooling.IManagedPool@)">
            <summary>
                Attempt to get an GDX.Collections.Pooling.IManagedPool based on the baseObject.
            </summary>
            <param name="baseObject">The System.Object which was used to create the pool.</param>
            <param name="pool">The first found GDX.Collections.Pooling.IManagedPool created with baseObject.</param>
            <returns>true/false if an GDX.Collections.Pooling.IManagedPool was found.</returns>
        </member>
        <member name="M:GDX.Collections.Pooling.ManagedPools.Unregister(GDX.Collections.Pooling.IManagedPool)">
            <summary>
                Unregister a GDX.Collections.Pooling.IManagedPool from with the management system.
            </summary>
            <param name="managedPool">Target GDX.Collections.Pooling.IManagedPool</param>
        </member>
        <member name="T:GDX.Collections.BitArray64">
            <summary>
                A 64-bit array.
            </summary>
            <example>
                Useful for packing a bunch of data with known indices tightly.
                <code>
                    if(myBitArray64[1])
                    {
                        BeAwesome();
                    }
                </code>
            </example>
        </member>
        <member name="F:GDX.Collections.BitArray64.Bits0">
            <summary>
                First reserved System.Int64 memory block (64-bits).
            </summary>
            <remarks>Indices 0-63</remarks>
        </member>
        <member name="M:GDX.Collections.BitArray64.#ctor(System.Int64)">
            <summary>
                Create a new GDX.Collections.BitArray64 based on provided bits0.
            </summary>
            <param name="bits0">An existing value to be used to create the backing data for a GDX.Collections.BitArray64</param>
        </member>
        <member name="P:GDX.Collections.BitArray64.Item(System.Byte)">
            <summary>
                Access bit in array.
            </summary>
            <param name="index">Target bit index.</param>
        </member>
        <member name="T:GDX.Collections.NativeSparseSet">
            <summary>
                An adapter collection for external data arrays that allows constant-time insertion, deletion, and lookup by
                handle, as well as array-like iteration.
            </summary>
            <remarks>
                The GDX.Collections.NativeSparseSet is backed by a Unity.Collections.NativeArray`1 which
                requires UnityEngine.CoreModule.dll.
            </remarks>
        </member>
        <member name="F:GDX.Collections.NativeSparseSet.DenseArray">
            <summary>
                Holds references to the sparse array for swapping indices.
            </summary>
        </member>
        <member name="F:GDX.Collections.NativeSparseSet.SparseArray">
            <summary>
                Holds references to dense array indices.
            </summary>
            <remarks>
                Its own indices are claimed and freed via a free-list.
            </remarks>
        </member>
        <member name="F:GDX.Collections.NativeSparseSet.Count">
            <summary>
                How many indices are being used currently?
            </summary>
        </member>
        <member name="F:GDX.Collections.NativeSparseSet.FreeIndex">
            <summary>
                The first free (currently unused) index in the sparse array.
            </summary>
        </member>
        <member name="M:GDX.Collections.NativeSparseSet.#ctor(System.Int32,Unity.Collections.Allocator,Unity.Collections.NativeArrayOptions)">
            <summary>
                Create a GDX.Collections.NativeSparseSet with an initialCapacity.
            </summary>
            <param name="initialCapacity">The initial capacity of the sparse and dense int arrays.</param>
            <param name="allocator">The Unity.Collections.Allocator type to use.</param>
            <param name="nativeArrayOptions">Should the memory be cleared on allocation?</param>
        </member>
        <member name="M:GDX.Collections.NativeSparseSet.AddWithExpandCheck(System.Int32,System.Int32@,System.Int32@,Unity.Collections.Allocator,Unity.Collections.NativeArrayOptions)">
            <summary>
                Adds a sparse/dense index pair to the set and expands the arrays if necessary.
            </summary>
            <param name="expandBy">How many indices to expand by.</param>
            <param name="sparseIndex">The sparse index allocated.</param>
            <param name="denseIndex">The dense index allocated.</param>
            <param name="allocator">The Unity.Collections.Allocator type to use.</param>
            <param name="nativeArrayOptions">Should the memory be cleared on allocation?</param>
            <returns>True if the index pool expanded.</returns>
        </member>
        <member name="M:GDX.Collections.NativeSparseSet.AddUnchecked(System.Int32@,System.Int32@)">
            <summary>
                Adds a sparse/dense index pair to the set without checking if the set needs to expand.
            </summary>
            <param name="sparseIndex">The sparse index allocated.</param>
            <param name="denseIndex">The dense index allocated.</param>
        </member>
        <member name="M:GDX.Collections.NativeSparseSet.GetDenseIndexUnchecked(System.Int32)">
            <summary>
                Gets the value of the sparse array at the given index without any data validation.
            </summary>
            <param name="sparseIndex">The index to check in the sparse array.</param>
            <returns>The dense index at the given sparse index.</returns>
        </member>
        <member name="M:GDX.Collections.NativeSparseSet.GetDenseIndexWithBoundsCheck(System.Int32)">
            <summary>
                Gets the value of the sparse array at the given index,
                or -1 if the dense and sparse indices don't point to each other or if the dense index is outside the dense bounds.
            </summary>
            <param name="sparseIndex">The index in the sparse array to check against.</param>
            <returns>The dense index pointed to by the current sparse index, or -1 if invalid.</returns>
        </member>
        <member name="M:GDX.Collections.NativeSparseSet.GetDenseIndexWithVersionCheck(System.Int32,System.UInt64,Unity.Collections.NativeArray{System.UInt64})">
            <summary>
                Gets the value of the sparse array at the given index,
                or -1 if the version number does not match.
            </summary>
            <param name="sparseIndex">The index in the sparse array to check against.</param>
            <param name="version">The version number associated with the sparse index.</param>
            <param name="versionArray">The array containing the version number to check against.</param>
            <returns>The dense index pointed to by the current sparse index, or -1 if invalid.</returns>
        </member>
        <member name="M:GDX.Collections.NativeSparseSet.GetDenseIndexWithBoundsAndVersionCheck(System.Int32,System.UInt64,Unity.Collections.NativeArray{System.UInt64})">
            <summary>
                Gets the value of the sparse array at the given index,
                or -1 if the given sparse index is invalid..
            </summary>
            <param name="sparseIndex">The index in the sparse array to check against.</param>
            <param name="version">The version number associated with the sparse index.</param>
            <param name="versionArray">The array containing the version number to check against.</param>
            <returns>The dense index pointed to by the current sparse index, or -1 if invalid.</returns>
        </member>
        <member name="M:GDX.Collections.NativeSparseSet.RemoveWithNullValueCheck(System.Int32@)">
            <summary>
                Returns true if the element was successfully removed.
                WARNING: Will not protect against accidentally removing twice if the index in question was recycled between Remove
                calls.
            </summary>
        </member>
        <member name="M:GDX.Collections.NativeSparseSet.RemoveWithBoundsAndVersionChecks(System.Int32@,System.UInt64,Unity.Collections.NativeArray{System.UInt64})">
            <summary>
                Removes the associated sparse/dense index pair from active use.
                calls.
            </summary>
            <param name="sparseIndexToRemove">The sparse index to remove.</param>
            <param name="version">
                The version number of the int used to access the sparse index. Used to guard against accessing
                indices that have been removed and reused.
            </param>
            <param name="versionArray">The array where version numbers to check against are stored.</param>
            <returns>True if the element was successfully removed.</returns>
        </member>
        <member name="M:GDX.Collections.NativeSparseSet.RemoveUnchecked(System.Int32)">
            <summary>
                Removes the associated sparse/dense index pair from active use.
            </summary>
            <param name="sparseIndexToRemove">The sparse index to remove.</param>
        </member>
        <member name="M:GDX.Collections.NativeSparseSet.RemoveUnchecked(System.Int32,Unity.Collections.NativeArray{System.UInt64})">
            <summary>
                Removes the associated sparse/dense index pair from active use and increments the version.
            </summary>
            <param name="sparseIndexToRemove">The sparse index to remove.</param>
            <param name="versionArray">The array where version numbers to check against are stored.</param>
        </member>
        <member name="M:GDX.Collections.NativeSparseSet.RemoveUnchecked(System.Int32,System.Int32@,System.Int32@)">
            <summary>
                Removes the associated sparse/dense index pair from active use.
                Out parameters used to manage parallel data arrays.
            </summary>
            <param name="sparseIndexToRemove">The sparse index to remove.</param>
            <param name="indexToSwapTo">Replace the data array value at this index with the data array value at indexToSwapFrom.</param>
            <param name="indexToSwapFrom">
                Set the data array value at this index to default after swapping with the data array
                value at indexToSwapTo.
            </param>
        </member>
        <member name="M:GDX.Collections.NativeSparseSet.RemoveUnchecked(System.Int32,Unity.Collections.NativeArray{System.UInt64},System.Int32@,System.Int32@)">
            <summary>
                Removes the associated sparse/dense index pair from active use and increments the version.
                Out parameters used to manage parallel data arrays.
            </summary>
            <param name="sparseIndexToRemove">The sparse index to remove.</param>
            <param name="versionArray">The array where version numbers to check against are stored.</param>
            <param name="indexToSwapTo">Replace the data array value at this index with the data array value at indexToSwapFrom.</param>
            <param name="indexToSwapFrom">
                Set the data array value at this index to default after swapping with the data array
                value at indexToSwapTo.
            </param>
        </member>
        <member name="M:GDX.Collections.NativeSparseSet.RemoveUncheckedFromDenseIndex(System.Int32)">
            <summary>
                Removes the associated sparse/dense index pair from active use.
            </summary>
            <param name="denseIndexToRemove">The dense index associated with the sparse index to remove.</param>
        </member>
        <member name="M:GDX.Collections.NativeSparseSet.RemoveUncheckedFromDenseIndex(System.Int32,System.UInt64[])">
            <summary>
                Removes the associated sparse/dense index pair from active use.
            </summary>
            <param name="denseIndexToRemove">The dense index associated with the sparse index to remove.</param>
            <param name="versionArray">The array where version numbers to check against are stored.</param>
        </member>
        <member name="M:GDX.Collections.NativeSparseSet.RemoveUncheckedFromDenseIndex(System.Int32,System.Int32@)">
            <summary>
                Removes the associated sparse/dense index pair from active use.
                Out parameter used to manage parallel data arrays.
            </summary>
            <param name="denseIndexToRemove">The sparse index to remove.</param>
            <param name="indexToSwapFrom">
                Set the data array value at this index to default after swapping with the data array
                value at denseIndexToRemove.
            </param>
        </member>
        <member name="M:GDX.Collections.NativeSparseSet.RemoveUncheckedFromDenseIndex(System.Int32,Unity.Collections.NativeArray{System.UInt64},System.Int32@)">
            <summary>
                Removes the associated sparse/dense index pair from active use.
                Out parameter used to manage parallel data arrays.
            </summary>
            <param name="denseIndexToRemove">The sparse index to remove.</param>
            <param name="versionArray">The array where version numbers to check against are stored.</param>
            <param name="indexToSwapFrom">
                Set the data array value at this index to default after swapping with the data array
                value at denseIndexToRemove.
            </param>
        </member>
        <member name="M:GDX.Collections.NativeSparseSet.TryRemoveWithVersionCheck(System.Int32,System.UInt64,Unity.Collections.NativeArray{System.UInt64},System.Int32@,System.Int32@)">
            <summary>
                Attempts to remove the associated sparse/dense index pair from active use and increments the version if successful.
                Out parameters used to manage parallel data arrays.
            </summary>
            <param name="sparseIndexToRemove">The sparse index to remove.</param>
            <param name="version">
                The version number of the int used to access the sparse index. Used to guard against accessing
                indices that have been removed and reused.
            </param>
            <param name="versionArray">The array where version numbers to check against are stored.</param>
            <param name="indexToSwapTo">Replace the data array value at this index with the data array value at indexToSwapFrom.</param>
            <param name="indexToSwapFrom">
                Set the data array value at this index to default after swapping with the data array
                value at indexToSwapTo.
            </param>
            <returns>Whether or not the remove attempt succeeded.</returns>
        </member>
        <member name="M:GDX.Collections.NativeSparseSet.TryRemoveFromDenseIndexWithVersionCheck(System.Int32,System.UInt64,Unity.Collections.NativeArray{System.UInt64})">
            <summary>
                Attempts to remove the associated sparse/dense index pair from active use and increments the version if successful.
            </summary>
            <param name="denseIndexToRemove">The dense index associated with the sparse index to remove.</param>
            <param name="version">The array where version numbers to check against are stored.</param>
            <param name="versionArray">The array where version numbers to check against are stored.</param>
            <returns>Whether or not the remove attempt succeeded.</returns>
        </member>
        <member name="M:GDX.Collections.NativeSparseSet.Clear">
            <summary>
                Clear the dense and sparse arrays.
            </summary>
        </member>
        <member name="M:GDX.Collections.NativeSparseSet.Clear(Unity.Collections.NativeArray{System.UInt64})">
            <summary>
                Clear the dense and sparse arrays.
            </summary>
            <param name="versionArray">Array containing version numbers to check against.</param>
        </member>
        <member name="M:GDX.Collections.NativeSparseSet.Expand(System.Int32,Unity.Collections.Allocator,Unity.Collections.NativeArrayOptions)">
            <summary>
                Reallocate the dense and sparse arrays with additional capacity.
            </summary>
            <param name="extraCapacity">How many indices to expand the dense and sparse arrays by.</param>
            <param name="allocator">The Unity.Collections.Allocator type to use.</param>
            <param name="nativeArrayOptions">Should the memory be cleared on allocation?</param>
        </member>
        <member name="M:GDX.Collections.NativeSparseSet.Expand(System.Int32,Unity.Collections.NativeArray{System.UInt64}@,Unity.Collections.Allocator,Unity.Collections.NativeArrayOptions)">
            <summary>
                Reallocate the dense and sparse arrays with additional capacity.
            </summary>
            <param name="extraCapacity">How many indices to expand the dense and sparse arrays by.</param>
            <param name="versionArray">Array containing version numbers to check against.</param>
            <param name="allocator">The Unity.Collections.Allocator type to use.</param>
            <param name="nativeArrayOptions">Should the memory be cleared on allocation?</param>
        </member>
        <member name="T:GDX.Collections.BitArray128">
            <summary>
                A 128-bit array.
            </summary>
            <example>
                Useful for packing a bunch of data with known indices tightly.
                <code>
                    if(myBitArray128[1])
                    {
                        BeAwesome();
                    }
                </code>
            </example>
        </member>
        <member name="F:GDX.Collections.BitArray128.Bits0">
            <summary>
                First reserved System.Int32 memory block.
            </summary>
            <remarks>Indices 0-31</remarks>
        </member>
        <member name="F:GDX.Collections.BitArray128.Bits1">
            <summary>
                Second reserved System.Int32 memory block.
            </summary>
            <remarks>Indices 32-63</remarks>
        </member>
        <member name="F:GDX.Collections.BitArray128.Bits2">
            <summary>
                Third reserved System.Int32 memory block.
            </summary>
            <remarks>Indices 64-95</remarks>
        </member>
        <member name="F:GDX.Collections.BitArray128.Bits3">
            <summary>
                Fourth reserved System.Int32 memory block.
            </summary>
            <remarks>Indices 96-127</remarks>
        </member>
        <member name="P:GDX.Collections.BitArray128.Item(System.Int32)">
            <summary>
                Access bit in array.
            </summary>
            <param name="index">Target bit index.</param>
        </member>
        <member name="T:GDX.Collections.BitArray32">
            <summary>
                A 32-bit array.
            </summary>
            <example>
                Useful for packing a bunch of data with known indices tightly.
                <code>
                    if(myBitArray32[1])
                    {
                        BeAwesome();
                    }
                </code>
            </example>
        </member>
        <member name="F:GDX.Collections.BitArray32.Bits0">
            <summary>
                First reserved System.UInt32 memory block (32-bits).
            </summary>
            <remarks>Indices 0-31</remarks>
        </member>
        <member name="M:GDX.Collections.BitArray32.#ctor(System.UInt32)">
            <summary>
                Create a new GDX.Collections.BitArray32 based on provided bits0.
            </summary>
            <param name="bits0">An existing value to be used to create the backing data for a GDX.Collections.BitArray32</param>
        </member>
        <member name="P:GDX.Collections.BitArray32.Item(System.Byte)">
            <summary>
                Access bit in array.
            </summary>
            <param name="index">Target bit index.</param>
        </member>
        <member name="T:GDX.Collections.SparseSet">
            <summary>
                An adapter collection for external data arrays that allows constant-time insertion, deletion, and lookup by
                handle, as well as array-like iteration.
            </summary>
        </member>
        <member name="F:GDX.Collections.SparseSet.DenseArray">
            <summary>
                Holds references to the sparse array for swapping indices.
            </summary>
        </member>
        <member name="F:GDX.Collections.SparseSet.SparseArray">
            <summary>
                Holds references to dense array indices.
            </summary>
            <remarks>
                Its own indices are claimed and freed via a free-list.
            </remarks>
        </member>
        <member name="F:GDX.Collections.SparseSet.Count">
            <summary>
                How many indices are being used currently?
            </summary>
        </member>
        <member name="F:GDX.Collections.SparseSet.FreeIndex">
            <summary>
                The first free (currently unused) index in the sparse array.
            </summary>
        </member>
        <member name="M:GDX.Collections.SparseSet.#ctor(System.Int32)">
            <summary>
                Create a GDX.Collections.SparseSet with an initialCapacity.
            </summary>
            <param name="initialCapacity">The initial capacity of the sparse and dense int arrays.</param>
        </member>
        <member name="M:GDX.Collections.SparseSet.AddWithExpandCheck(System.Int32,System.Int32@,System.Int32@)">
            <summary>
                Adds a sparse/dense index pair to the set and expands the arrays if necessary.
            </summary>
            <param name="expandBy">How many indices to expand by.</param>
            <param name="sparseIndex">The sparse index allocated.</param>
            <param name="denseIndex">The dense index allocated.</param>
            <returns>True if the index pool expanded.</returns>
        </member>
        <member name="M:GDX.Collections.SparseSet.AddUnchecked(System.Int32@,System.Int32@)">
            <summary>
                Adds a sparse/dense index pair to the set without checking if the set needs to expand.
            </summary>
            <param name="sparseIndex">The sparse index allocated.</param>
            <param name="denseIndex">The dense index allocated.</param>
        </member>
        <member name="M:GDX.Collections.SparseSet.GetDenseIndexUnchecked(System.Int32)">
            <summary>
                Gets the value of the sparse array at the given index without any data validation.
            </summary>
            <param name="sparseIndex">The index to check in the sparse array.</param>
            <returns>The dense index at the given sparse index.</returns>
        </member>
        <member name="M:GDX.Collections.SparseSet.GetDenseIndexWithBoundsCheck(System.Int32)">
            <summary>
                Gets the value of the sparse array at the given index,
                or -1 if the dense and sparse indices don't point to each other or if the dense index is outside the dense bounds.
            </summary>
            <param name="sparseIndex">The index in the sparse array to check against.</param>
            <returns>The dense index pointed to by the current sparse index, or -1 if invalid.</returns>
        </member>
        <member name="M:GDX.Collections.SparseSet.GetDenseIndexWithVersionCheck(System.Int32,System.UInt64,System.UInt64[])">
            <summary>
                Gets the value of the sparse array at the given index,
                or -1 if the version number does not match.
            </summary>
            <param name="sparseIndex">The index in the sparse array to check against.</param>
            <param name="version">The version number associated with the sparse index.</param>
            <param name="versionArray">The array containing the version number to check against.</param>
            <returns>The dense index pointed to by the current sparse index, or -1 if invalid.</returns>
        </member>
        <member name="M:GDX.Collections.SparseSet.GetDenseIndexWithBoundsAndVersionCheck(System.Int32,System.UInt64,System.UInt64[])">
            <summary>
                Gets the value of the sparse array at the given index,
                or -1 if the given sparse index is invalid..
            </summary>
            <param name="sparseIndex">The index in the sparse array to check against.</param>
            <param name="version">The version number associated with the sparse index.</param>
            <param name="versionArray">The array containing the version number to check against.</param>
            <returns>The dense index pointed to by the current sparse index, or -1 if invalid.</returns>
        </member>
        <member name="M:GDX.Collections.SparseSet.RemoveWithNullValueCheck(System.Int32@)">
            <summary>
                Returns true if the element was successfully removed.
                WARNING: Will not protect against accidentally removing twice if the index in question was recycled between Remove
                calls.
            </summary>
        </member>
        <member name="M:GDX.Collections.SparseSet.RemoveWithBoundsAndVersionChecks(System.Int32@,System.UInt64,System.UInt64[]@)">
            <summary>
                Removes the associated sparse/dense index pair from active use.
                calls.
            </summary>
            <param name="sparseIndexToRemove">The sparse index to remove.</param>
            <param name="version">
                The version number of the int used to access the sparse index. Used to guard against accessing
                indices that have been removed and reused.
            </param>
            <param name="versionArray">The array where version numbers to check against are stored.</param>
            <returns>True if the element was successfully removed.</returns>
        </member>
        <member name="M:GDX.Collections.SparseSet.RemoveUnchecked(System.Int32)">
            <summary>
                Removes the associated sparse/dense index pair from active use.
            </summary>
            <param name="sparseIndexToRemove">The sparse index to remove.</param>
        </member>
        <member name="M:GDX.Collections.SparseSet.RemoveUnchecked(System.Int32,System.UInt64[])">
            <summary>
                Removes the associated sparse/dense index pair from active use and increments the version.
            </summary>
            <param name="sparseIndexToRemove">The sparse index to remove.</param>
            <param name="versionArray">The array where version numbers to check against are stored.</param>
        </member>
        <member name="M:GDX.Collections.SparseSet.RemoveUnchecked(System.Int32,System.Int32@,System.Int32@)">
            <summary>
                Removes the associated sparse/dense index pair from active use.
                Out parameters used to manage parallel data arrays.
            </summary>
            <param name="sparseIndexToRemove">The sparse index to remove.</param>
            <param name="indexToSwapTo">Replace the data array value at this index with the data array value at indexToSwapFrom.</param>
            <param name="indexToSwapFrom">
                Set the data array value at this index to default after swapping with the data array
                value at indexToSwapTo.
            </param>
        </member>
        <member name="M:GDX.Collections.SparseSet.RemoveUnchecked(System.Int32,System.UInt64[],System.Int32@,System.Int32@)">
            <summary>
                Removes the associated sparse/dense index pair from active use and increments the version.
                Out parameters used to manage parallel data arrays.
            </summary>
            <param name="sparseIndexToRemove">The sparse index to remove.</param>
            <param name="versionArray">The array where version numbers to check against are stored.</param>
            <param name="indexToSwapTo">Replace the data array value at this index with the data array value at indexToSwapFrom.</param>
            <param name="indexToSwapFrom">
                Set the data array value at this index to default after swapping with the data array
                value at indexToSwapTo.
            </param>
        </member>
        <member name="M:GDX.Collections.SparseSet.RemoveUncheckedFromDenseIndex(System.Int32)">
            <summary>
                Removes the associated sparse/dense index pair from active use.
            </summary>
            <param name="denseIndexToRemove">The dense index associated with the sparse index to remove.</param>
        </member>
        <member name="M:GDX.Collections.SparseSet.RemoveUncheckedFromDenseIndex(System.Int32,System.UInt64[])">
            <summary>
                Removes the associated sparse/dense index pair from active use.
            </summary>
            <param name="denseIndexToRemove">The dense index associated with the sparse index to remove.</param>
            <param name="versionArray">The array where version numbers to check against are stored.</param>
        </member>
        <member name="M:GDX.Collections.SparseSet.RemoveUncheckedFromDenseIndex(System.Int32,System.Int32@)">
            <summary>
                Removes the associated sparse/dense index pair from active use.
                Out parameter used to manage parallel data arrays.
            </summary>
            <param name="denseIndexToRemove">The sparse index to remove.</param>
            <param name="indexToSwapFrom">
                Set the data array value at this index to default after swapping with the data array
                value at denseIndexToRemove.
            </param>
        </member>
        <member name="M:GDX.Collections.SparseSet.RemoveUncheckedFromDenseIndex(System.Int32,System.UInt64[],System.Int32@)">
            <summary>
                Removes the associated sparse/dense index pair from active use.
                Out parameter used to manage parallel data arrays.
            </summary>
            <param name="denseIndexToRemove">The sparse index to remove.</param>
            <param name="versionArray">The array where version numbers to check against are stored.</param>
            <param name="indexToSwapFrom">
                Set the data array value at this index to default after swapping with the data array
                value at denseIndexToRemove.
            </param>
        </member>
        <member name="M:GDX.Collections.SparseSet.TryRemoveWithVersionCheck(System.Int32,System.UInt64,System.UInt64[],System.Int32@,System.Int32@)">
            <summary>
                Attempts to remove the associated sparse/dense index pair from active use and increments the version if successful.
                Out parameters used to manage parallel data arrays.
            </summary>
            <param name="sparseIndexToRemove">The sparse index to remove.</param>
            <param name="version">
                The version number of the int used to access the sparse index. Used to guard against accessing
                indices that have been removed and reused.
            </param>
            <param name="versionArray">The array where version numbers to check against are stored.</param>
            <param name="indexToSwapTo">Replace the data array value at this index with the data array value at indexToSwapFrom.</param>
            <param name="indexToSwapFrom">
                Set the data array value at this index to default after swapping with the data array
                value at indexToSwapTo.
            </param>
            <returns>Whether or not the remove attempt succeeded.</returns>
        </member>
        <member name="M:GDX.Collections.SparseSet.TryRemoveFromDenseIndexWithVersionCheck(System.Int32,System.UInt64,System.UInt64[])">
            <summary>
                Attempts to remove the associated sparse/dense index pair from active use and increments the version if successful.
            </summary>
            <param name="denseIndexToRemove">The dense index associated with the sparse index to remove.</param>
            <param name="version">The array where version numbers to check against are stored.</param>
            <param name="versionArray">The array where version numbers to check against are stored.</param>
            <returns>Whether or not the remove attempt succeeded.</returns>
        </member>
        <member name="M:GDX.Collections.SparseSet.Clear">
            <summary>
                Clear the dense and sparse arrays.
            </summary>
        </member>
        <member name="M:GDX.Collections.SparseSet.Clear(System.UInt64[])">
            <summary>
                Clear the dense and sparse arrays.
            </summary>
            ///
            <param name="versionArray">Array containing version numbers to check against.</param>
        </member>
        <member name="M:GDX.Collections.SparseSet.Expand(System.Int32)">
            <summary>
                Reallocate the dense and sparse arrays with additional capacity.
            </summary>
            <param name="extraCapacity">How many indices to expand the dense and sparse arrays by.</param>
        </member>
        <member name="M:GDX.Collections.SparseSet.Expand(System.Int32,System.UInt64[]@)">
            <summary>
                Reallocate the dense and sparse arrays with additional capacity.
            </summary>
            <param name="extraCapacity">How many indices to expand the dense and sparse arrays by.</param>
            <param name="versionArray">Array containing version numbers to check against.</param>
        </member>
        <member name="M:GDX.Collections.SparseSet.AddWithExpandCheck``1(``0,``0[]@,System.Int32@,System.Int32)">
            <summary>
                Adds a sparse/dense index pair to the set and expands the arrays if necessary.
            </summary>
            <returns>True if the index pool expanded.</returns>
        </member>
        <member name="M:GDX.Collections.SparseSet.AddWithExpandCheck``2(``0,``0[]@,``1,``1[]@,System.Int32@,System.Int32)">
            <summary>
                Adds a sparse/dense index pair to the set and expands the arrays if necessary.
            </summary>
            <returns>True if the index pool expanded.</returns>
        </member>
        <member name="M:GDX.Collections.SparseSet.AddWithExpandCheck``3(``0,``0[]@,``1,``1[]@,``2,``2[]@,System.Int32@,System.Int32)">
            <summary>
                Adds a sparse/dense index pair to the set and expands the arrays if necessary.
            </summary>
            <returns>True if the index pool expanded.</returns>
        </member>
        <member name="M:GDX.Collections.SparseSet.AddWithExpandCheck``4(``0,``0[]@,``1,``1[]@,``2,``2[]@,``3,``3[]@,System.Int32@,System.Int32)">
            <summary>
                Adds a sparse/dense index pair to the set and expands the arrays if necessary.
            </summary>
            <returns>True if the index pool expanded.</returns>
        </member>
        <member name="M:GDX.Collections.SparseSet.AddWithExpandCheck``5(``0,``0[]@,``1,``1[]@,``2,``2[]@,``3,``3[]@,``4,``4[]@,System.Int32@,System.Int32)">
            <summary>
                Adds a sparse/dense index pair to the set and expands the arrays if necessary.
            </summary>
            <returns>True if the index pool expanded.</returns>
        </member>
        <member name="M:GDX.Collections.SparseSet.AddWithExpandCheck``6(``0,``0[]@,``1,``1[]@,``2,``2[]@,``3,``3[]@,``4,``4[]@,``5,``5[]@,System.Int32@,System.Int32)">
            <summary>
                Adds a sparse/dense index pair to the set and expands the arrays if necessary.
            </summary>
            <returns>True if the index pool expanded.</returns>
        </member>
        <member name="M:GDX.Collections.SparseSet.AddWithExpandCheck``7(``0,``0[]@,``1,``1[]@,``2,``2[]@,``3,``3[]@,``4,``4[]@,``5,``5[]@,``6,``6[]@,System.Int32@,System.Int32)">
            <summary>
                Adds a sparse/dense index pair to the set and expands the arrays if necessary.
            </summary>
            <returns>True if the index pool expanded.</returns>
        </member>
        <member name="M:GDX.Collections.SparseSet.AddWithExpandCheck``8(``0,``0[]@,``1,``1[]@,``2,``2[]@,``3,``3[]@,``4,``4[]@,``5,``5[]@,``6,``6[]@,``7,``7[]@,System.Int32@,System.Int32)">
            <summary>
                Adds a sparse/dense index pair to the set and expands the arrays if necessary.
            </summary>
            <returns>True if the index pool expanded.</returns>
        </member>
        <member name="M:GDX.Collections.SparseSet.AddUnchecked``1(``0,``0[])">
            <summary>
                Adds to the set without checking if the set needs to expand.
            </summary>
            <returns>The sparse index allocated</returns>
        </member>
        <member name="M:GDX.Collections.SparseSet.AddUnchecked``2(``0,``0[],``1,``1[])">
            <summary>
                Adds to the set without checking if the set needs to expand.
            </summary>
            <returns>The sparse index allocated</returns>
        </member>
        <member name="M:GDX.Collections.SparseSet.AddUnchecked``3(``0,``0[],``1,``1[],``2,``2[])">
            <summary>
                Adds to the set without checking if the set needs to expand.
            </summary>
            <returns>The sparse index allocated</returns>
        </member>
        <member name="M:GDX.Collections.SparseSet.AddUnchecked``4(``0,``0[],``1,``1[],``2,``2[],``3,``3[])">
            <summary>
                Adds to the set without checking if the set needs to expand.
            </summary>
            <returns>The sparse index allocated</returns>
        </member>
        <member name="M:GDX.Collections.SparseSet.AddUnchecked``5(``0,``0[],``1,``1[],``2,``2[],``3,``3[],``4,``4[])">
            <summary>
                Adds to the set without checking if the set needs to expand.
            </summary>
            <returns>The sparse index allocated</returns>
        </member>
        <member name="M:GDX.Collections.SparseSet.AddUnchecked``6(``0,``0[],``1,``1[],``2,``2[],``3,``3[],``4,``4[],``5,``5[])">
            <summary>
                Adds to the set without checking if the set needs to expand.
            </summary>
            <returns>The sparse index allocated</returns>
        </member>
        <member name="M:GDX.Collections.SparseSet.AddUnchecked``7(``0,``0[],``1,``1[],``2,``2[],``3,``3[],``4,``4[],``5,``5[],``6,``6[])">
            <summary>
                Adds to the set without checking if the set needs to expand.
            </summary>
            <returns>The sparse index allocated</returns>
        </member>
        <member name="M:GDX.Collections.SparseSet.AddUnchecked``8(``0,``0[],``1,``1[],``2,``2[],``3,``3[],``4,``4[],``5,``5[],``6,``6[],``7,``7[])">
            <summary>
                Adds to the set without checking if the set needs to expand.
            </summary>
            <returns>The sparse index allocated</returns>
        </member>
        <member name="T:GDX.Collections.BitArray512">
            <summary>
                A 512-bit array.
            </summary>
            <example>
                Useful for packing a bunch of data with known indices tightly.
                <code>
                    if(myBitArray512[1])
                    {
                        BeAwesome();
                    }
                </code>
            </example>
        </member>
        <member name="F:GDX.Collections.BitArray512.Bits0">
            <summary>
                First reserved System.Int32 memory block.
            </summary>
            <remarks>Indices 0-31</remarks>
        </member>
        <member name="F:GDX.Collections.BitArray512.Bits1">
            <summary>
                Second reserved System.Int32 memory block.
            </summary>
            <remarks>Indices 32-63</remarks>
        </member>
        <member name="F:GDX.Collections.BitArray512.Bits2">
            <summary>
                Third reserved System.Int32 memory block.
            </summary>
            <remarks>Indices 64-95</remarks>
        </member>
        <member name="F:GDX.Collections.BitArray512.Bits3">
            <summary>
                Fourth reserved System.Int32 memory block.
            </summary>
            <remarks>Indices 96-127</remarks>
        </member>
        <member name="F:GDX.Collections.BitArray512.Bits4">
            <summary>
                Fifth reserved System.Int32 memory block.
            </summary>
            <remarks>Indices 128-159</remarks>
        </member>
        <member name="F:GDX.Collections.BitArray512.Bits5">
            <summary>
                Sixth reserved System.Int32 memory block.
            </summary>
            <remarks>Indices 160-191</remarks>
        </member>
        <member name="F:GDX.Collections.BitArray512.Bits6">
            <summary>
                Seventh reserved System.Int32 memory block.
            </summary>
            <remarks>Indices 192-223</remarks>
        </member>
        <member name="F:GDX.Collections.BitArray512.Bits7">
            <summary>
                Eighth reserved System.Int32 memory block.
            </summary>
            <remarks>Indices 224-255</remarks>
        </member>
        <member name="F:GDX.Collections.BitArray512.Bits8">
            <summary>
                Ninth reserved System.Int32 memory block.
            </summary>
            <remarks>Indices 256-287</remarks>
        </member>
        <member name="F:GDX.Collections.BitArray512.Bits9">
            <summary>
                Tenth reserved System.Int32 memory block.
            </summary>
            <remarks>Indices 288-319</remarks>
        </member>
        <member name="F:GDX.Collections.BitArray512.Bits10">
            <summary>
                Eleventh reserved System.Int32 memory block.
            </summary>
            <remarks>Indices 320-351</remarks>
        </member>
        <member name="F:GDX.Collections.BitArray512.Bits11">
            <summary>
                Twelfth reserved System.Int32 memory block.
            </summary>
            <remarks>Indices 352-383</remarks>
        </member>
        <member name="F:GDX.Collections.BitArray512.Bits12">
            <summary>
                Thirteenth reserved System.Int32 memory block.
            </summary>
            <remarks>Indices 384-415</remarks>
        </member>
        <member name="F:GDX.Collections.BitArray512.Bits13">
            <summary>
                Fourteenth reserved System.Int32 memory block.
            </summary>
            <remarks>Indices 416-447</remarks>
        </member>
        <member name="F:GDX.Collections.BitArray512.Bits14">
            <summary>
                Fifteenth reserved System.Int32 memory block.
            </summary>
            <remarks>Indices 448-479</remarks>
        </member>
        <member name="F:GDX.Collections.BitArray512.Bits15">
            <summary>
                Sixteenth reserved System.Int32 memory block.
            </summary>
            <remarks>Indices 480-511</remarks>
        </member>
        <member name="P:GDX.Collections.BitArray512.Item(System.Int32)">
            <summary>
                Access bit in array.
            </summary>
            <param name="index">Target bit index.</param>
        </member>
        <member name="T:GDX.Collections.FreeList">
            <summary>
                An array where indices are allocated from and stored in an in-place linked list.
                Allocating or deallocating a single int from this array is very fast, as is single datum lookup,
                but neither the allocated indices nor the free indices can be reliably iterated without an external data structure.
                This structure can be adapted to an arbitrary of external, parallel arrays.
            </summary>
        </member>
        <member name="F:GDX.Collections.FreeList.Indices">
            <summary>
                Data storage for allocated indices as well as the in-place free-list.
            </summary>
        </member>
        <member name="F:GDX.Collections.FreeList.CurrentFreeIndex">
            <summary>
                The next available index of the free-list.
            </summary>
        </member>
        <member name="F:GDX.Collections.FreeList.Count">
            <summary>
                The total number of currently-allocated indices.
            </summary>
        </member>
        <member name="M:GDX.Collections.FreeList.#ctor(System.Int32)">
            <summary>
            </summary>
            <param name="initialCapacity">The initial capacity of the array.</param>
        </member>
        <member name="M:GDX.Collections.FreeList.Clear">
            <summary>
                Removes all allocated data and rebuilds the free-list.
            </summary>
        </member>
        <member name="M:GDX.Collections.FreeList.AddWithExpandCheck(System.Int32,System.Int32@,System.Int32)">
            <summary>
                Allocates an index from the free-list and stores an integer there, expanding the array if necessary.
            </summary>
            <param name="data">The integer value to store at the allocated index.</param>
            <param name="allocatedIndex">The index allocated from the free-list.</param>
            <param name="expandBy">How much the array should expand by when out of space.</param>
            <returns>True if the array expanded.</returns>
        </member>
        <member name="M:GDX.Collections.FreeList.AddWithExpandCheck(System.Int32,System.Int32@)">
            <summary>
                Allocates an index from the free-list and stores an integer there, expanding the array by twice the current size if
                necessary.
            </summary>
            <param name="data">The integer value to store at the allocated index.</param>
            <param name="allocatedIndex">The index allocated from the free-list.</param>
            <returns>True if the array expanded.</returns>
        </member>
        <member name="M:GDX.Collections.FreeList.AddUnchecked(System.Int32)">
            <summary>
                Allocates an index from the free-list and stores an integer there, without checking for expansion.
            </summary>
            <param name="data">The integer value to store at the allocated index.</param>
            <returns>The index allocated from the free-list.</returns>
        </member>
        <member name="M:GDX.Collections.FreeList.RemoveAt(System.Int32)">
            <summary>
                Deallocates the given index and adds it to the free-list.
            </summary>
            <param name="index">The index to add to the free-list.</param>
        </member>
        <member name="M:GDX.Collections.FreeList.GetAndRemoveAt(System.Int32)">
            <summary>
                Retrieves the value stored at the given index and deallocates the index, adding it to the free-list.
            </summary>
            <param name="index">The index to add to the free-list.</param>
            <returns>The value stored at the given index.</returns>
        </member>
        <member name="T:GDX.Mathematics.Smooth">
            <summary>
                Some helpful interpolation functionality.
            </summary>
        </member>
        <member name="M:GDX.Mathematics.Smooth.Exponential(System.Single,System.Single,System.Single,System.Single)">
            <summary>
                Smooths between previousValue and targetValue based on time since the last sample and a given half-life.
            </summary>
            <remarks>Assumes wibbly wobbly, timey wimey.</remarks>
            <param name="previousValue">Ideally, the previous output value.</param>
            <param name="targetValue">The target value.</param>
            <param name="halfLife">
                Half of the time it would take to go from previousValue to
                targetValue if time were constant.
            </param>
            <param name="elapsedTime">
                The amount of time that has transpired since the previousValue was
                generated.
            </param>
            <returns>A smoothed value.</returns>
        </member>
        <member name="M:GDX.Mathematics.Smooth.HalfLifeToSmoothingFactor(System.Single,System.Single)">
            <summary>
                Takes a halfLife value, and outputs a factor based on elapsedTime.
            </summary>
            <remarks>Not providing a value for elapsedTime will result in using <c>Time.deltaTime</c>.</remarks>
            <param name="halfLife">The desired halflife.</param>
            <param name="elapsedTime">The time since the last sample.</param>
            <returns>The coefficient value applied to the weight(t) of a lerp.</returns>
        </member>
        <member name="T:GDX.Mathematics.Random.MersenneTwister">
            <summary>
                Generates pseudo-random value using the Mersenne Twister algorithm.
            </summary>
            <remarks>
                <para>
                    Adapted from the work of Akihilo Kramot (Takel), originally based on a
                    <a href="http://www.math.sci.hiroshima-u.ac.jp/m-mat/MT/MT2002/CODES/mt19937ar.c">
                        C-program for MT19937
                    </a>
                    by Takuji Nishimura, considering the suggestions by Topher Cooper and Marc Rieffel in July-Aug. 1997.
                    See the
                    <a href="http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html">
                        Mersenne Twister Homepage
                    </a>
                    for details on the algorithm.
                </para>
            </remarks>
        </member>
        <member name="F:GDX.Mathematics.Random.MersenneTwister.N">
            <summary>
                The degree of recurrence.
            </summary>
            <remarks>
                Size of byte pool.
            </remarks>
        </member>
        <member name="F:GDX.Mathematics.Random.MersenneTwister.M">
            <summary>
                The middle word value.
            </summary>
            <remarks>
                Period second parameter.
            </remarks>
        </member>
        <member name="F:GDX.Mathematics.Random.MersenneTwister.UpperMask">
            <summary>
                The most significant w-r bits.
            </summary>
        </member>
        <member name="F:GDX.Mathematics.Random.MersenneTwister.LowerMask">
            <summary>
                Least significant r bits.
            </summary>
        </member>
        <member name="F:GDX.Mathematics.Random.MersenneTwister.FiftyThreeBitsOf1S">
            <summary>
                A magic inducing value.
            </summary>
            <remarks>
                A value of 9007199254740991.0 is the maximum System.Double value which the 53
                significant can hold when the exponent is 0.
            </remarks>
        </member>
        <member name="F:GDX.Mathematics.Random.MersenneTwister.Inverse53BitsOf1S">
            <summary>
                Inverse of GDX.Mathematics.Random.MersenneTwister.FiftyThreeBitsOf1S.
            </summary>
            <remarks>
                Multiply by inverse to (vainly?) try to avoid a division.
            </remarks>
        </member>
        <member name="F:GDX.Mathematics.Random.MersenneTwister.OnePlus53BitsOf1S">
            <summary>
                1 plus GDX.Mathematics.Random.MersenneTwister.FiftyThreeBitsOf1S.
            </summary>
        </member>
        <member name="F:GDX.Mathematics.Random.MersenneTwister.InverseOnePlus53BitsOf1S">
            <summary>
                Inverse of GDX.Mathematics.Random.MersenneTwister.OnePlus53BitsOf1S.
            </summary>
        </member>
        <member name="F:GDX.Mathematics.Random.MersenneTwister.s_mag01">
            <summary>
                Magnitude lookup.
            </summary>
        </member>
        <member name="F:GDX.Mathematics.Random.MersenneTwister._mersenneTwisterState">
            <summary>
                The array for the state vector of the twister.
            </summary>
            <remarks>Also known as it's byte pool.</remarks>
        </member>
        <member name="F:GDX.Mathematics.Random.MersenneTwister._mersenneTwisterIndex">
            <summary>
                The current index in the array for the state of the twister.
            </summary>
        </member>
        <member name="M:GDX.Mathematics.Random.MersenneTwister.#ctor(System.Int32)">
            <summary>
                Creates a new pseudo-random number generator with the given seed.
            </summary>
            <param name="seed">A System.Int32 value to use as a seed.</param>
        </member>
        <member name="M:GDX.Mathematics.Random.MersenneTwister.#ctor">
            <summary>
                Creates a new pseudo-random number generator with a default seed.
            </summary>
            <remarks>
                <c>new System.Random().System.Random.Next</c>
                is used for the seed.
            </remarks>
        </member>
        <member name="M:GDX.Mathematics.Random.MersenneTwister.#ctor(System.Int32[])">
            <summary>
                Creates a pseudo-random number generator initialized with the given array.
            </summary>
            <param name="initKey">The array for System.Int32 initializing keys.</param>
        </member>
        <member name="M:GDX.Mathematics.Random.MersenneTwister.GenerateUnsignedInteger">
            <summary>
                Generates a new pseudo-random System.UInt32.
            </summary>
            <returns>A pseudo-random System.UInt32.</returns>
        </member>
        <member name="M:GDX.Mathematics.Random.MersenneTwister.NextUInt">
            <summary>
                Returns the next pseudo-random System.UInt32.
            </summary>
            <returns>A pseudo-random System.UInt32 value.</returns>
        </member>
        <member name="M:GDX.Mathematics.Random.MersenneTwister.NextUInt(System.UInt32)">
            <summary>
                Returns the next pseudo-random System.UInt32 up to maxValue.
            </summary>
            <param name="maxValue">
                The maximum value of the pseudo-random number to create.
            </param>
            <returns>
                A pseudo-random System.UInt32 value which is at most maxValue.
            </returns>
        </member>
        <member name="M:GDX.Mathematics.Random.MersenneTwister.NextUInt(System.UInt32,System.UInt32)">
            <summary>
                Returns the next pseudo-random System.UInt32 at least
                minValue and up to maxValue.
            </summary>
            <param name="minValue">The minimum value of the pseudo-random number to create.</param>
            <param name="maxValue">The maximum value of the pseudo-random number to create.</param>
            <returns>
                A pseudo-random System.UInt32 value which is at least
                minValue and at most maxValue.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
                If <c>minValue &gt;= maxValue</c>.
            </exception>
        </member>
        <member name="M:GDX.Mathematics.Random.MersenneTwister.Next">
            <summary>
                Returns the next pseudo-random System.Int32.
            </summary>
            <returns>A pseudo-random System.Int32 value.</returns>
        </member>
        <member name="M:GDX.Mathematics.Random.MersenneTwister.Next(System.Int32)">
            <summary>
                Returns the next pseudo-random System.Int32 up to maxValue.
            </summary>
            <param name="maxValue">The maximum value of the pseudo-random number to create.</param>
            <returns>
                A pseudo-random System.Int32 value which is at most maxValue.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
                When maxValue &lt; 0.
            </exception>
        </member>
        <member name="M:GDX.Mathematics.Random.MersenneTwister.Next(System.Int32,System.Int32)">
            <summary>
                Returns the next pseudo-random System.Int32 at least minValue
                and up to maxValue.
            </summary>
            <param name="minValue">The minimum value of the pseudo-random number to create.</param>
            <param name="maxValue">The maximum value of the pseudo-random number to create.</param>
            <returns>
                A pseudo-random System.Int32 value which is at least minValue and at
                most maxValue.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
                If <c>minValue &gt;= maxValue</c>.
            </exception>
        </member>
        <member name="M:GDX.Mathematics.Random.MersenneTwister.NextBytes(System.Byte[])">
            <summary>
                Fills a buffer with pseudo-random System.Byte.
            </summary>
            <param name="buffer">The buffer to fill.</param>
            <exception cref="T:System.ArgumentNullException">
                If <c>buffer == null</c>.
            </exception>
        </member>
        <member name="M:GDX.Mathematics.Random.MersenneTwister.NextDouble">
            <summary>
                Returns the next pseudo-random System.Double value.
            </summary>
            <returns>A pseudo-random System.Double floating point value.</returns>
            <remarks>
                <para>
                    There are two common ways to create a double floating point using MT19937:
                    using GDX.Mathematics.Random.MersenneTwister.GenerateUnsignedInteger and dividing by 0xFFFFFFFF + 1,
                    or else generating two double words and shifting the first by 26 bits and
                    adding the second.
                </para>
                <para>
                    In a newer measurement of the randomness of MT19937 published in the
                    journal "Monte Carlo Methods and Applications, Vol. 12, No. 5-6, pp. 385  393 (2006)"
                    entitled "A Repetition Test for Pseudo-Random Number Generators",
                    it was found that the 32-bit version of generating a double fails at the 95%
                    confidence level when measuring for expected repetitions of a particular
                    number in a sequence of numbers generated by the algorithm.
                </para>
                <para>
                    Due to this, the 53-bit method is implemented here and the 32-bit method
                    of generating a double is not. If, for some reason,
                    the 32-bit method is needed, it can be generated by the following:
                    <code>
                        (System.Double)NextUInt32() / ((UInt64)UInt32.MaxValue + 1);
                    </code>
                </para>
            </remarks>
        </member>
        <member name="M:GDX.Mathematics.Random.MersenneTwister.NextDouble(System.Boolean)">
            <summary>
                Returns a pseudo-random System.Double number greater than or equal to zero, and
                either strictly less than one, or less than or equal to one,
                depending on the value of the given parameter.
            </summary>
            <param name="includeOne">
                If true, the pseudo-random System.Double number returned will be
                less than or equal to one; otherwise, the pseudo-random number returned will
                be strictly less than one.
            </param>
            <returns>
                If includeOne is true, this method returns a
                System.Double-precision pseudo-random number greater than or equal to zero, and less
                than or equal to one. If includeOne is false, this method
                returns a System.Double-precision pseudo-random number greater than or equal to zero and
                strictly less than one.
            </returns>
        </member>
        <member name="M:GDX.Mathematics.Random.MersenneTwister.NextDoublePositive">
            <summary>
                Returns a pseudo-random System.Double number greater than 0.0 and less than 1.0.
            </summary>
            <returns>A pseudo-random System.Double number greater than 0.0 and less than 1.0.</returns>
        </member>
        <member name="M:GDX.Mathematics.Random.MersenneTwister.NextSingle">
            <summary>
                Returns a pseudo-random System.Single number between 0.0 and 1.0.
            </summary>
            <returns>
                A System.Single-precision floating point number greater than or equal to 0.0,
                and less than 1.0.
            </returns>
        </member>
        <member name="M:GDX.Mathematics.Random.MersenneTwister.NextSingle(System.Boolean)">
            <summary>
                Returns a pseudo-random System.Single number greater than or equal to zero,
                and either strictly less than one, or less than or equal to one, depending on the value of the
                given boolean parameter.
            </summary>
            <param name="includeOne">
                If true, the pseudo-random number returned will be
                less than or equal to one; otherwise, the pseudo-random number returned will
                be strictly less than one.
            </param>
            <returns>
                If includeOne is true, this method returns a
                System.Single-precision pseudo-random number greater than or equal to zero, and less
                than or equal to one. If includeOne is false,
                this method returns a single-precision pseudo-random number greater than or equal to zero and
                strictly less than one.
            </returns>
        </member>
        <member name="M:GDX.Mathematics.Random.MersenneTwister.NextSinglePositive">
            <summary>
                Returns a pseudo-random positive System.Single number greater than 0.0 and less than 1.0.
            </summary>
            <returns>A pseudo-random number greater than 0.0 and less than 1.0.</returns>
        </member>
        <member name="M:GDX.Mathematics.Random.MersenneTwister.NextBoolean">
            <summary>
                Returns a pseudo-random System.Boolean.
            </summary>
            <returns>A System.Boolean value of either true or false.</returns>
        </member>
        <member name="T:GDX.Mathematics.Rotate">
            <summary>
            A set of functionality to extend on Unity's on rotation based methods.
            </summary>
        </member>
        <member name="M:GDX.Mathematics.Rotate.Towards(UnityEngine.Quaternion,UnityEngine.Quaternion,System.Single,System.Single)">
            <summary>
            Create a quaternion based on a rotation from targetQuaternion to otherQuaternion.
            </summary>
            <param name="targetQuaternion">The source UnityEngine.Quaternion.</param>
            <param name="otherQuaternion">The destination UnityEngine.Quaternion.</param>
            <param name="rotationRate">How fast should the rotation occur.</param>
            <param name="elapsedTime">How long has elapsed since the rotation started.</param>
            <returns>A rotational value.</returns>
        </member>
        <member name="T:GDX.Mathematics.Byte2">
            <summary>
                A System.Byte vector.
            </summary>
        </member>
        <member name="F:GDX.Mathematics.Byte2.x">
            <summary>
                X System.Byte.
            </summary>
        </member>
        <member name="F:GDX.Mathematics.Byte2.y">
            <summary>
                Y System.Byte.
            </summary>
        </member>
        <member name="M:GDX.Mathematics.Byte2.#ctor(System.Int32,System.Int32)">
            <summary>
                Create a GDX.Mathematics.Byte2 from two System.Int32 values.
            </summary>
            <param name="x">X value.</param>
            <param name="y">Y value.</param>
        </member>
        <member name="M:GDX.Mathematics.Byte2.#ctor(System.Byte,System.Byte)">
            <summary>
                Constructs a GDX.Mathematics.Byte2 from two System.Byte values.
            </summary>
            <param name="x">X value.</param>
            <param name="y">Y value.</param>
        </member>
        <member name="M:GDX.Mathematics.Byte2.#ctor(GDX.Mathematics.Byte2)">
            <summary>
                Constructs a GDX.Mathematics.Byte2 from a GDX.Mathematics.Byte2 value.
            </summary>
            <param name="xy">The value to copy.</param>
        </member>
        <member name="M:GDX.Mathematics.Byte2.#ctor(System.Byte)">
            <summary>
                Constructs a GDX.Mathematics.Byte2 from a single System.Byte value by assigning it to every component.
            </summary>
            <param name="v">The value to copy to GDX.Mathematics.Byte2.x and GDX.Mathematics.Byte2.y.</param>
        </member>
        <member name="M:GDX.Mathematics.Byte2.#ctor(System.Boolean)">
            <summary>
                Constructs a GDX.Mathematics.Byte2 from a single System.Boolean value by converting it to System.Byte
                and assigning it to every component.
            </summary>
            <param name="v">The System.Boolean value to transcribe.</param>
        </member>
        <member name="M:GDX.Mathematics.Byte2.#ctor(System.Single)">
            <summary>
                Constructs a GDX.Mathematics.Byte2 from a single System.Single value by converting it to System.Byte
                and assigning it to every component.
            </summary>
            <param name="v">The System.Single value to transcribe.</param>
        </member>
        <member name="M:GDX.Mathematics.Byte2.#ctor(System.Double)">
            <summary>
                Constructs a GDX.Mathematics.Byte2 from a single System.Double value by converting it to System.Byte
                and assigning it to every component.
            </summary>
            <param name="v">The System.Double value to transcribe.</param>
        </member>
        <member name="P:GDX.Mathematics.Byte2.xx">
            <summary>
                Get a new GDX.Mathematics.Byte2 created with GDX.Mathematics.Byte2.x as both components.
            </summary>
        </member>
        <member name="P:GDX.Mathematics.Byte2.xy">
            <summary>
                Get a new GDX.Mathematics.Byte2 created with identical components.
            </summary>
        </member>
        <member name="P:GDX.Mathematics.Byte2.yx">
            <summary>
                Get a new GDX.Mathematics.Byte2 created with swapped components.
            </summary>
        </member>
        <member name="P:GDX.Mathematics.Byte2.yy">
            <summary>
                Get a new GDX.Mathematics.Byte2 created with GDX.Mathematics.Byte2.y as both components.
            </summary>
        </member>
        <member name="P:GDX.Mathematics.Byte2.Item(System.Int32)">
            <summary>
                Get the System.Byte at the provided index.
            </summary>
            <param name="index">Returns the byte element at a specified index.</param>
            <exception cref="T:System.ArgumentException">Out of range check.</exception>
        </member>
        <member name="M:GDX.Mathematics.Byte2.Equals(GDX.Mathematics.Byte2)">
            <summary>
                Does the GDX.Mathematics.Byte2 equal another GDX.Mathematics.Byte2.
            </summary>
            <param name="rhs">Target GDX.Mathematics.Byte2 to compare with.</param>
            <returns>Returns true if the GDX.Mathematics.Byte2 is equal to a given GDX.Mathematics.Byte2, false otherwise.</returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.ToString(System.String,System.IFormatProvider)">
            <summary>
                Convert the GDX.Mathematics.Byte2 to a System.String using the provided format.
            </summary>
            <param name="format">Specified format System.String.</param>
            <param name="formatProvider">Culture-specific format information.</param>
            <returns>
                Returns a string representation of the GDX.Mathematics.Byte2 using a specified format and culture-specific
                format information.
            </returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.Equals(System.Object)">
            <summary>
                Does the GDX.Mathematics.Byte2 equal another System.Object (casted).
            </summary>
            <param name="o">Target System.Object to compare with.</param>
            <returns>Returns true if the GDX.Mathematics.Byte2 is equal to a given GDX.Mathematics.Byte2, false otherwise.</returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_Implicit(System.Byte)~GDX.Mathematics.Byte2">
            <summary>
                Implicitly converts a single System.Byte value to a GDX.Mathematics.Byte2 by assigning it to every
                component.
            </summary>
            <param name="v">The System.Byte value to transcribe.</param>
            <returns>A new GDX.Mathematics.Byte2.</returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_Explicit(System.Boolean)~GDX.Mathematics.Byte2">
            <summary>
                Explicitly converts a single System.Boolean value to a GDX.Mathematics.Byte2 by converting it to
                System.Byte and assigning it to every component.
            </summary>
            <param name="v">The System.Boolean value to transcribe.</param>
            <returns>A new GDX.Mathematics.Byte2.</returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_Explicit(System.Single)~GDX.Mathematics.Byte2">
            <summary>
                Explicitly converts a single System.Single value to a GDX.Mathematics.Byte2 by converting it to
                System.Byte and assigning it to every component.
            </summary>
            <param name="v">The System.Single value to transcribe.</param>
            <returns>A new GDX.Mathematics.Byte2.</returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_Explicit(System.Double)~GDX.Mathematics.Byte2">
            <summary>
                Explicitly converts a single System.Double value to a GDX.Mathematics.Byte2 by converting it to
                System.Byte and assigning it to every component.
            </summary>
            <param name="v">The System.Double value to transcribe.</param>
            <returns>A new GDX.Mathematics.Byte2.</returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_Multiply(GDX.Mathematics.Byte2,GDX.Mathematics.Byte2)">
            <summary>
                Multiply two GDX.Mathematics.Byte2.
            </summary>
            <param name="lhs">Left-hand side GDX.Mathematics.Byte2.</param>
            <param name="rhs">Right-hand side GDX.Mathematics.Byte2.</param>
            <returns>Returns the result of a  multiplication operation on two GDX.Mathematics.Byte2.</returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_Multiply(GDX.Mathematics.Byte2,System.Byte)">
            <summary>
                Multiply a GDX.Mathematics.Byte2 by a System.Byte.
            </summary>
            <param name="lhs">Left-hand side GDX.Mathematics.Byte2.</param>
            <param name="rhs">Right-hand side System.Byte.</param>
            <returns>
                Returns the result of a multiplication operation on a GDX.Mathematics.Byte2 and a
                System.Byte value.
            </returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_Multiply(System.Byte,GDX.Mathematics.Byte2)">
            <summary>
                Multiply a System.Byte by a GDX.Mathematics.Byte2.
            </summary>
            <param name="lhs">Left-hand side System.Byte.</param>
            <param name="rhs">Right-hand side GDX.Mathematics.Byte2.</param>
            <returns>
                Returns the result of a multiplication operation on a System.Byte and a
                GDX.Mathematics.Byte2 value.
            </returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_Addition(GDX.Mathematics.Byte2,GDX.Mathematics.Byte2)">
            <summary>
                Add two GDX.Mathematics.Byte2.
            </summary>
            <param name="lhs">Left-hand side GDX.Mathematics.Byte2.</param>
            <param name="rhs">Right-hand side GDX.Mathematics.Byte2.</param>
            <returns>Returns the result of an addition operation on two GDX.Mathematics.Byte2.</returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_Addition(GDX.Mathematics.Byte2,System.Byte)">
            <summary>
                Add a System.Byte to both components of a GDX.Mathematics.Byte2.
            </summary>
            <param name="lhs">Left-hand side GDX.Mathematics.Byte2.</param>
            <param name="rhs">Right-hand side System.Byte.</param>
            <returns>
                Returns the result of an addition operation on an GDX.Mathematics.Byte2 and an System.Byte
                value.
            </returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_Addition(System.Byte,GDX.Mathematics.Byte2)">
            <summary>
                Add a GDX.Mathematics.Byte2 to a System.Byte.
            </summary>
            <param name="lhs">Left-hand side System.Byte.</param>
            <param name="rhs">Right-hand side GDX.Mathematics.Byte2.</param>
            <returns>
                Returns the result of an addition operation on an System.Byte value and an
                GDX.Mathematics.Byte2.
            </returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_Subtraction(GDX.Mathematics.Byte2,GDX.Mathematics.Byte2)">
            <summary>
                Subtract a GDX.Mathematics.Byte2 from another GDX.Mathematics.Byte2.
            </summary>
            <param name="lhs">Left-hand side GDX.Mathematics.Byte2.</param>
            <param name="rhs">Right-hand side GDX.Mathematics.Byte2.</param>
            <returns>Returns the result of a subtraction operation on two GDX.Mathematics.Byte2.</returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_Subtraction(GDX.Mathematics.Byte2,System.Byte)">
            <summary>
                Subtract a System.Byte from both components of a GDX.Mathematics.Byte2.
            </summary>
            <param name="lhs">Left-hand side GDX.Mathematics.Byte2.</param>
            <param name="rhs">Right-hand side System.Byte.</param>
            <returns>
                Returns the result of a subtraction operation on a GDX.Mathematics.Byte2 and a System.Byte
                value.
            </returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_Subtraction(System.Byte,GDX.Mathematics.Byte2)">
            <summary>
                Subtract both components of a GDX.Mathematics.Byte2 from a System.Byte.
            </summary>
            <param name="lhs">Left-hand side System.Byte.</param>
            <param name="rhs">Right-hand side GDX.Mathematics.Byte2.</param>
            <returns>
                Returns the result of a subtraction operation on an System.Byte value and an
                GDX.Mathematics.Byte2.
            </returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_Division(GDX.Mathematics.Byte2,GDX.Mathematics.Byte2)">
            <summary>
                Divide a GDX.Mathematics.Byte2 by another GDX.Mathematics.Byte2.
            </summary>
            <param name="lhs">Left-hand side GDX.Mathematics.Byte2.</param>
            <param name="rhs">Right-hand side GDX.Mathematics.Byte2.</param>
            <returns>Returns the result of a division operation on two GDX.Mathematics.Byte2.</returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_Division(GDX.Mathematics.Byte2,System.Byte)">
            <summary>
                Divide a GDX.Mathematics.Byte2 by a System.Byte.
            </summary>
            <param name="lhs">Left-hand side GDX.Mathematics.Byte2.</param>
            <param name="rhs">Right-hand side System.Byte.</param>
            <returns>
                Returns the result of a division operation on a GDX.Mathematics.Byte2 and System.Byte
                value.
            </returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_Division(System.Byte,GDX.Mathematics.Byte2)">
            <summary>
                Divide a System.Byte by a GDX.Mathematics.Byte2.
            </summary>
            <param name="lhs">Left-hand side System.Byte.</param>
            <param name="rhs">Right-hand side GDX.Mathematics.Byte2.</param>
            <returns>
                Returns the result of a division operation on a System.Byte value and
                GDX.Mathematics.Byte2.
            </returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_Modulus(GDX.Mathematics.Byte2,GDX.Mathematics.Byte2)">
            <summary>
                Modulus a GDX.Mathematics.Byte2 by another GDX.Mathematics.Byte2.
            </summary>
            <param name="lhs">Left-hand side GDX.Mathematics.Byte2.</param>
            <param name="rhs">Right-hand side GDX.Mathematics.Byte2.</param>
            <returns>Returns the result of a modulus operation on two GDX.Mathematics.Byte2.</returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_Modulus(GDX.Mathematics.Byte2,System.Byte)">
            <summary>
                Modulus a GDX.Mathematics.Byte2 by a System.Byte.
            </summary>
            <param name="lhs">Left-hand side GDX.Mathematics.Byte2.</param>
            <param name="rhs">Right-hand side System.Byte.</param>
            <returns>
                Returns the result of a modulus operation on a GDX.Mathematics.Byte2 and System.Byte
                value.
            </returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_Modulus(System.Byte,GDX.Mathematics.Byte2)">
            <summary>
                Modulus a System.Byte by a GDX.Mathematics.Byte2.
            </summary>
            <param name="lhs">Left-hand side System.Byte.</param>
            <param name="rhs">Right-hand side GDX.Mathematics.Byte2.</param>
            <returns>
                Returns the result of a modulus operation on a System.Byte value and
                GDX.Mathematics.Byte2.
            </returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_Increment(GDX.Mathematics.Byte2)">
            <summary>
                Increment GDX.Mathematics.Byte2 values.
            </summary>
            <param name="val">Target GDX.Mathematics.Byte2.</param>
            <returns>Returns the result of an increment operation on a GDX.Mathematics.Byte2.</returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_Decrement(GDX.Mathematics.Byte2)">
            <summary>
                Decrement GDX.Mathematics.Byte2 values.
            </summary>
            <param name="val">Target GDX.Mathematics.Byte2.</param>
            <returns>Returns the result of a decrement operation on a GDX.Mathematics.Byte2.</returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_UnaryNegation(GDX.Mathematics.Byte2)">
            <summary>
                Unary minus GDX.Mathematics.Byte2 values.
            </summary>
            <param name="val">Target GDX.Mathematics.Byte2.</param>
            <returns>Returns the result of an unary minus operation on a GDX.Mathematics.Byte2.</returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_UnaryPlus(GDX.Mathematics.Byte2)">
            <summary>
                Unary plus GDX.Mathematics.Byte2 values.
            </summary>
            <param name="val">Target GDX.Mathematics.Byte2.</param>
            <returns>Returns the result of an unary plus operation on a GDX.Mathematics.Byte2.</returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_OnesComplement(GDX.Mathematics.Byte2)">
            <summary>
                Bitwise NOT GDX.Mathematics.Byte2 values.
            </summary>
            <param name="val">Target GDX.Mathematics.Byte2.</param>
            <returns>Returns the result of a bitwise NOT operation on a GDX.Mathematics.Byte2.</returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_BitwiseAnd(GDX.Mathematics.Byte2,GDX.Mathematics.Byte2)">
            <summary>
                Bitwise AND two GDX.Mathematics.Byte2 values.
            </summary>
            <param name="lhs">Left-hand side GDX.Mathematics.Byte2.</param>
            <param name="rhs">Right-hand side GDX.Mathematics.Byte2.</param>
            <returns>Returns the result of a bitwise AND operation on two GDX.Mathematics.Byte2.</returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_BitwiseAnd(GDX.Mathematics.Byte2,System.Byte)">
            <summary>
                Bitwise AND a GDX.Mathematics.Byte2 and a System.Byte.
            </summary>
            <param name="lhs">Left-hand side GDX.Mathematics.Byte2.</param>
            <param name="rhs">Right-hand side System.Byte.</param>
            <returns>
                Returns the result of a bitwise AND operation on a GDX.Mathematics.Byte2 and a System.Byte
                value.
            </returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_BitwiseAnd(System.Byte,GDX.Mathematics.Byte2)">
            <summary>
                Bitwise AND a System.Byte and a GDX.Mathematics.Byte2.
            </summary>
            <param name="lhs">Left-hand side System.Byte.</param>
            <param name="rhs">Right-hand side GDX.Mathematics.Byte2.</param>
            <returns>
                Returns the result of a bitwise AND operation on a System.Byte and a GDX.Mathematics.Byte2
                value.
            </returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_BitwiseOr(GDX.Mathematics.Byte2,GDX.Mathematics.Byte2)">
            <summary>
                Bitwise OR two GDX.Mathematics.Byte2 values.
            </summary>
            <param name="lhs">Left-hand side GDX.Mathematics.Byte2.</param>
            <param name="rhs">Right-hand side GDX.Mathematics.Byte2.</param>
            <returns>Returns the result of a bitwise OR operation on two GDX.Mathematics.Byte2.</returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_BitwiseOr(GDX.Mathematics.Byte2,System.Byte)">
            <summary>
                Bitwise OR a GDX.Mathematics.Byte2 and a System.Byte.
            </summary>
            <param name="lhs">Left-hand side GDX.Mathematics.Byte2.</param>
            <param name="rhs">Right-hand side System.Byte.</param>
            <returns>
                Returns the result of a bitwise OR operation on a GDX.Mathematics.Byte2 and a System.Byte
                value.
            </returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_BitwiseOr(System.Byte,GDX.Mathematics.Byte2)">
            <summary>
                Bitwise OR a System.Byte and a GDX.Mathematics.Byte2.
            </summary>
            <param name="lhs">Left-hand side System.Byte.</param>
            <param name="rhs">Right-hand side GDX.Mathematics.Byte2.</param>
            <returns>
                Returns the result of a bitwise OR operation on a System.Byte and a GDX.Mathematics.Byte2
                value.
            </returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_ExclusiveOr(GDX.Mathematics.Byte2,GDX.Mathematics.Byte2)">
            <summary>
                Bitwise XOR two GDX.Mathematics.Byte2 values.
            </summary>
            <param name="lhs">Left-hand side GDX.Mathematics.Byte2.</param>
            <param name="rhs">Right-hand side GDX.Mathematics.Byte2.</param>
            <returns>Returns the result of a bitwise EXCLUSIVE OR operation on two GDX.Mathematics.Byte2.</returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_ExclusiveOr(GDX.Mathematics.Byte2,System.Byte)">
            <summary>
                Bitwise XOR a GDX.Mathematics.Byte2 and a System.Byte.
            </summary>
            <param name="lhs">Left-hand side GDX.Mathematics.Byte2.</param>
            <param name="rhs">Right-hand side System.Byte.</param>
            <returns>
                Returns the result of a bitwise XOR operation on a GDX.Mathematics.Byte2 and a System.Byte
                value.
            </returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_ExclusiveOr(System.Byte,GDX.Mathematics.Byte2)">
            <summary>
                Bitwise XOR a System.Byte and a GDX.Mathematics.Byte2.
            </summary>
            <param name="lhs">Left-hand side System.Byte.</param>
            <param name="rhs">Right-hand side GDX.Mathematics.Byte2.</param>
            <returns>
                Returns the result of a bitwise XOR operation on a System.Byte and a GDX.Mathematics.Byte2
                value.
            </returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.GetHashCode">
            <summary>
                Get a hash code from the GDX.Mathematics.Byte2.
            </summary>
            <remarks>
                This loosely based on the FowlerNollVo (FNV) hash function.
            </remarks>
            <returns>A System.Int32 value.</returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.ToString">
            <summary>
                Returns a System.String representation of the GDX.Mathematics.Byte2.
            </summary>
        </member>
        <member name="T:GDX.Mathematics.Byte2.DebuggerProxy">
            <summary>
                Debug object used by IDEs for visibility of a GDX.Mathematics.Byte2.
            </summary>
        </member>
        <member name="F:GDX.Mathematics.Byte2.DebuggerProxy.x">
            <summary>
                X System.Byte.
            </summary>
        </member>
        <member name="F:GDX.Mathematics.Byte2.DebuggerProxy.y">
            <summary>
                Y System.Byte.
            </summary>
        </member>
        <member name="M:GDX.Mathematics.Byte2.#ctor(Unity.Mathematics.bool2)">
            <summary>
                Constructs a GDX.Mathematics.Byte2 from a Unity.Mathematics.bool2 by conversion.
            </summary>
            <remarks>Requires UnityEngine.CoreModule.dll to function correctly.</remarks>
            <param name="v">The value to transcribe.</param>
        </member>
        <member name="M:GDX.Mathematics.Byte2.#ctor(Unity.Mathematics.float2)">
            <summary>
                Constructs a GDX.Mathematics.Byte2 from a Unity.Mathematics.float2 by conversion.
            </summary>
            <remarks>Requires UnityEngine.CoreModule.dll to function correctly.</remarks>
            <param name="v">The value to transcribe.</param>
        </member>
        <member name="M:GDX.Mathematics.Byte2.#ctor(Unity.Mathematics.double2)">
            <summary>
                Constructs a GDX.Mathematics.Byte2 from a Unity.Mathematics.double2 by conversion.
            </summary>
            <remarks>Requires UnityEngine.CoreModule.dll to function correctly.</remarks>
            <param name="v">The value to transcribe.</param>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_Explicit(Unity.Mathematics.bool2)~GDX.Mathematics.Byte2">
            <summary>
                Explicitly converts a Unity.Mathematics.bool2 to a GDX.Mathematics.Byte2 by conversion.
            </summary>
            <remarks>Requires UnityEngine.CoreModule.dll to function correctly.</remarks>
            <param name="v">The value to transcribe.</param>
            <returns>A new GDX.Mathematics.Byte2 created from v.</returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_Explicit(Unity.Mathematics.float2)~GDX.Mathematics.Byte2">
            <summary>
                Explicitly converts a Unity.Mathematics.bool2 to a GDX.Mathematics.Byte2 by conversion.
            </summary>
            <remarks>Requires UnityEngine.CoreModule.dll to function correctly.</remarks>
            <param name="v">The value to transcribe.</param>
            <returns>A new GDX.Mathematics.Byte2 created from v.</returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_Explicit(Unity.Mathematics.double2)~GDX.Mathematics.Byte2">
            <summary>
                Explicitly converts a Unity.Mathematics.double2 to a GDX.Mathematics.Byte2 by
                conversion.
            </summary>
            <remarks>Requires UnityEngine.CoreModule.dll to function correctly.</remarks>
            <param name="v">The value to transcribe.</param>
            <returns>A new GDX.Mathematics.Byte2 created from v.</returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_LessThan(GDX.Mathematics.Byte2,GDX.Mathematics.Byte2)">
            <summary>
                Determine if one GDX.Mathematics.Byte2 is less than another GDX.Mathematics.Byte2.
            </summary>
            <remarks>Requires UnityEngine.CoreModule.dll to function correctly.</remarks>
            <param name="lhs">Left-hand side GDX.Mathematics.Byte2.</param>
            <param name="rhs">Right-hand side GDX.Mathematics.Byte2.</param>
            <returns>Returns the result of a LESS THAN operation on two GDX.Mathematics.Byte2.</returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_LessThan(GDX.Mathematics.Byte2,System.Byte)">
            <summary>
                Determine if GDX.Mathematics.Byte2 is less than a System.Byte.
            </summary>
            <remarks>Requires UnityEngine.CoreModule.dll to function correctly.</remarks>
            <param name="lhs">Left-hand side GDX.Mathematics.Byte2.</param>
            <param name="rhs">Right-hand side System.Byte.</param>
            <returns>
                Returns the result of a LESS THAN operation on a GDX.Mathematics.Byte2 and a System.Byte
                value.
            </returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_LessThan(System.Byte,GDX.Mathematics.Byte2)">
            <summary>
                Determine if System.Byte is less than a GDX.Mathematics.Byte2.
            </summary>
            <remarks>Requires UnityEngine.CoreModule.dll to function correctly.</remarks>
            <param name="lhs">Left-hand side System.Byte.</param>
            <param name="rhs">Right-hand side GDX.Mathematics.Byte2.</param>
            <returns>
                Returns the result of a LESS THAN operation on a System.Byte and a GDX.Mathematics.Byte2
                value.
            </returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_LessThanOrEqual(GDX.Mathematics.Byte2,GDX.Mathematics.Byte2)">
            <summary>
                Determine if one GDX.Mathematics.Byte2 is less than or equal to another GDX.Mathematics.Byte2.
            </summary>
            <remarks>Requires UnityEngine.CoreModule.dll to function correctly.</remarks>
            <param name="lhs">Left-hand side GDX.Mathematics.Byte2.</param>
            <param name="rhs">Right-hand side GDX.Mathematics.Byte2.</param>
            <returns>Returns the result of a LESS THAN OR EQUAL operation on two GDX.Mathematics.Byte2.</returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_LessThanOrEqual(GDX.Mathematics.Byte2,System.Byte)">
            <summary>
                Determine if GDX.Mathematics.Byte2 is less than or equal a System.Byte.
            </summary>
            <remarks>Requires UnityEngine.CoreModule.dll to function correctly.</remarks>
            <param name="lhs">Left-hand side GDX.Mathematics.Byte2.</param>
            <param name="rhs">Right-hand side System.Byte.</param>
            <returns>
                Returns the result of a LESS THAN OR EQUAL operation on a GDX.Mathematics.Byte2 and a
                System.Byte
                value.
            </returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_LessThanOrEqual(System.Byte,GDX.Mathematics.Byte2)">
            <summary>
                Determine if System.Byte is less than or equal a GDX.Mathematics.Byte2.
            </summary>
            <remarks>Requires UnityEngine.CoreModule.dll to function correctly.</remarks>
            <param name="lhs">Left-hand side System.Byte.</param>
            <param name="rhs">Right-hand side GDX.Mathematics.Byte2.</param>
            <returns>
                Returns the result of a LESS THAN OR EQUAL operation on a System.Byte and a
                GDX.Mathematics.Byte2
                value.
            </returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_GreaterThan(GDX.Mathematics.Byte2,GDX.Mathematics.Byte2)">
            <summary>
                Determine if one GDX.Mathematics.Byte2 is less than another GDX.Mathematics.Byte2.
            </summary>
            <remarks>Requires UnityEngine.CoreModule.dll to function correctly.</remarks>
            <param name="lhs">Left-hand side GDX.Mathematics.Byte2.</param>
            <param name="rhs">Right-hand side GDX.Mathematics.Byte2.</param>
            <returns>Returns the result of a LESS THAN operation on two GDX.Mathematics.Byte2.</returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_GreaterThan(GDX.Mathematics.Byte2,System.Byte)">
            <summary>
                Determine if GDX.Mathematics.Byte2 is greater than a System.Byte.
            </summary>
            <remarks>Requires UnityEngine.CoreModule.dll to function correctly.</remarks>
            <param name="lhs">Left-hand side GDX.Mathematics.Byte2.</param>
            <param name="rhs">Right-hand side System.Byte.</param>
            <returns>
                Returns the result of a GREATER THAN operation on a GDX.Mathematics.Byte2 and a System.Byte
                value.
            </returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_GreaterThan(System.Byte,GDX.Mathematics.Byte2)">
            <summary>
                Determine if System.Byte is greater than a GDX.Mathematics.Byte2.
            </summary>
            <remarks>Requires UnityEngine.CoreModule.dll to function correctly.</remarks>
            <param name="lhs">Left-hand side System.Byte.</param>
            <param name="rhs">Right-hand side GDX.Mathematics.Byte2.</param>
            <returns>
                Returns the result of a GREATER THAN operation on a System.Byte and a GDX.Mathematics.Byte2
                value.
            </returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_GreaterThanOrEqual(GDX.Mathematics.Byte2,GDX.Mathematics.Byte2)">
            <summary>
                Determine if GDX.Mathematics.Byte2 is greater than or equal a GDX.Mathematics.Byte2.
            </summary>
            <remarks>Requires UnityEngine.CoreModule.dll to function correctly.</remarks>
            <param name="lhs">Left-hand side GDX.Mathematics.Byte2.</param>
            <param name="rhs">Right-hand side GDX.Mathematics.Byte2.</param>
            <returns>
                Returns the result of a GREATER THAN OR EQUAL operation on a GDX.Mathematics.Byte2 and a
                GDX.Mathematics.Byte2
                value.
            </returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_GreaterThanOrEqual(GDX.Mathematics.Byte2,System.Byte)">
            <summary>
                Determine if GDX.Mathematics.Byte2 is greater than or equal a System.Byte.
            </summary>
            <remarks>Requires UnityEngine.CoreModule.dll to function correctly.</remarks>
            <param name="lhs">Left-hand side GDX.Mathematics.Byte2.</param>
            <param name="rhs">Right-hand side System.Byte.</param>
            <returns>
                Returns the result of a GREATER THAN OR EQUAL operation on a GDX.Mathematics.Byte2 and a
                System.Byte
                value.
            </returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_GreaterThanOrEqual(System.Byte,GDX.Mathematics.Byte2)">
            <summary>
                Determine if System.Byte is greater than or equal a GDX.Mathematics.Byte2.
            </summary>
            <remarks>Requires UnityEngine.CoreModule.dll to function correctly.</remarks>
            <param name="lhs">Left-hand side System.Byte.</param>
            <param name="rhs">Right-hand side GDX.Mathematics.Byte2.</param>
            <returns>
                Returns the result of a GREATER THAN OR EQUAL operation on a System.Byte and a
                GDX.Mathematics.Byte2
                value.
            </returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_Equality(GDX.Mathematics.Byte2,GDX.Mathematics.Byte2)">
            <summary>
                Determine if one GDX.Mathematics.Byte2 is equal to another GDX.Mathematics.Byte2.
            </summary>
            <remarks>Requires UnityEngine.CoreModule.dll to function correctly.</remarks>
            <param name="lhs">Left-hand side GDX.Mathematics.Byte2.</param>
            <param name="rhs">Right-hand side GDX.Mathematics.Byte2.</param>
            <returns>Returns the result of an EQUALITY operation on two GDX.Mathematics.Byte2.</returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_Equality(GDX.Mathematics.Byte2,System.Byte)">
            <summary>
                Determine if both components of a GDX.Mathematics.Byte2 are equal to a System.Byte.
            </summary>
            <remarks>Requires UnityEngine.CoreModule.dll to function correctly.</remarks>
            <param name="lhs">Left-hand side GDX.Mathematics.Byte2.</param>
            <param name="rhs">Right-hand side System.Byte.</param>
            <returns>Returns the result of an EQUALITY operation on a GDX.Mathematics.Byte2 and a System.Byte.</returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_Equality(System.Byte,GDX.Mathematics.Byte2)">
            <summary>
                Determine if both components of a GDX.Mathematics.Byte2 are equal to a System.Byte.
            </summary>
            <remarks>Requires UnityEngine.CoreModule.dll to function correctly.</remarks>
            <param name="lhs">Left-hand side System.Byte.</param>
            <param name="rhs">Right-hand side GDX.Mathematics.Byte2.</param>
            <returns>Returns the result of an EQUALITY operation on a System.Byte and a GDX.Mathematics.Byte2.</returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_Inequality(GDX.Mathematics.Byte2,GDX.Mathematics.Byte2)">
            <summary>
                Determine if one GDX.Mathematics.Byte2 is not equal to another GDX.Mathematics.Byte2.
            </summary>
            <remarks>Requires UnityEngine.CoreModule.dll to function correctly.</remarks>
            <param name="lhs">Left-hand side GDX.Mathematics.Byte2.</param>
            <param name="rhs">Right-hand side GDX.Mathematics.Byte2.</param>
            <returns>Returns the result of a NOT EQUAL operation on two GDX.Mathematics.Byte2.</returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_Inequality(GDX.Mathematics.Byte2,System.Byte)">
            <summary>
                Determine if both components of a GDX.Mathematics.Byte2 are not equal to a System.Byte.
            </summary>
            <remarks>Requires UnityEngine.CoreModule.dll to function correctly.</remarks>
            <param name="lhs">Left-hand side GDX.Mathematics.Byte2.</param>
            <param name="rhs">Right-hand side System.Byte.</param>
            <returns>Returns the result of a NOT EQUAL operation on a GDX.Mathematics.Byte2 and a System.Byte.</returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_Inequality(System.Byte,GDX.Mathematics.Byte2)">
            <summary>
                Determine if both components of a GDX.Mathematics.Byte2 are not equal to a System.Byte.
            </summary>
            <remarks>Requires UnityEngine.CoreModule.dll to function correctly.</remarks>
            <param name="lhs">Left-hand side System.Byte.</param>
            <param name="rhs">Right-hand side GDX.Mathematics.Byte2.</param>
            <returns>Returns the result of a NOT EQUAL operation on a System.Byte and a GDX.Mathematics.Byte2.</returns>
        </member>
        <member name="T:GDX.StringExtensions">
            <summary>
                System.String Based Extension Methods
            </summary>
        </member>
        <member name="F:GDX.StringExtensions.AsciiCaseShift">
            <summary>
                The ASCII decimal value shift required to change the case of a letter.
            </summary>
        </member>
        <member name="F:GDX.StringExtensions.AsciiLowerCaseStart">
            <summary>
                The ASCII decimal value for a.
            </summary>
        </member>
        <member name="F:GDX.StringExtensions.AsciiLowerCaseEnd">
            <summary>
                The ASCII decimal value for lowercase z.
            </summary>
        </member>
        <member name="F:GDX.StringExtensions.AsciiNumberSign">
            <summary>
                The ASCII decimal value for the number sign -.
            </summary>
        </member>
        <member name="F:GDX.StringExtensions.AsciiNumberDecimal">
            <summary>
                The ASCII decimal value for the decimal (.).
            </summary>
        </member>
        <member name="F:GDX.StringExtensions.AsciiNumberSeparator">
            <summary>
                The ASCII decimal value for the , separator.
            </summary>
        </member>
        <member name="F:GDX.StringExtensions.AsciiNumberStart">
            <summary>
                The ASCII decimal value for 0.
            </summary>
        </member>
        <member name="F:GDX.StringExtensions.AsciiNumberEnd">
            <summary>
                The ASCII decimal value for 9.
            </summary>
        </member>
        <member name="F:GDX.StringExtensions.AsciiUpperCaseStart">
            <summary>
                The ASCII decimal value for uppercase A.
            </summary>
        </member>
        <member name="F:GDX.StringExtensions.AsciiUpperCaseEnd">
            <summary>
                The ASCII  decimal value for uppercase Z.
            </summary>
        </member>
        <member name="F:GDX.StringExtensions.EncryptionDefaultKey">
            <summary>
                The default encryption key used when none is provided to the encryption related extensions.
            </summary>
            <remarks>
                You can change this at runtime during some sort of initialization pass to being something unique to your project,
                but it is not absolutely necessary. This must be a multiple of 8 bytes.
            </remarks>
        </member>
        <member name="F:GDX.StringExtensions.EncryptionInitializationVector">
            <summary>
                The IV (Initialization Vector) provided to the System.Security.Cryptography.DESCryptoServiceProvider.
            </summary>
            <remarks>
                You can change this at runtime during some sort of initialization pass to being something unique to your project,
                but it is not absolutely necessary. This must be a multiple of 8 bytes.
            </remarks>
        </member>
        <member name="M:GDX.StringExtensions.Decrypt(System.String,System.Byte[])">
            <summary>
                Decrypt an encrypted System.String created by GDX.StringExtensions.Encrypt(System.String,System.Byte[]).
            </summary>
            <remarks>This will have quite a few allocations.</remarks>
            <param name="encryptedString">The encrypted System.String.</param>
            <param name="encryptionKey">The key used to encrypt the System.String.</param>
            <returns>The decrypted System.String.</returns>
        </member>
        <member name="M:GDX.StringExtensions.Encrypt(System.String,System.Byte[])">
            <summary>
                Encrypt a System.String utilizing a System.Security.Cryptography.DESCryptoServiceProvider.
            </summary>
            <remarks>This will have quite a few allocations.</remarks>
            <param name="decryptedString">The original System.String.</param>
            <param name="encryptionKey">
                The key to be used when encrypting the System.String.  This must be a
                multiple of 8 bytes.
            </param>
            <returns>The encrypted System.String.</returns>
        </member>
        <member name="M:GDX.StringExtensions.GetAfterFirst(System.String,System.String,System.StringComparison)">
            <summary>
                Get the System.String after the first identified splitString in
                targetString.
            </summary>
            <param name="targetString">The target System.String to look in.</param>
            <param name="splitString">The divider which the targetString should be split on.</param>
            <param name="comparison">Specifies the culture, case, and sort rules to be used.</param>
            <returns>
                The content following the splitString, or <c>null</c> if none is found.
            </returns>
        </member>
        <member name="M:GDX.StringExtensions.GetAfterLast(System.String,System.String,System.StringComparison)">
            <summary>
                Get the System.String after the last identified splitString in
                targetString.
            </summary>
            <param name="targetString">The target System.String to look in.</param>
            <param name="splitString">The divider which the targetString should be split on.</param>
            <param name="comparison">Specifies the culture, case, and sort rules to be used.</param>
            <returns>
                The content following the splitString, or <c>null</c> if none is found.
            </returns>
        </member>
        <member name="M:GDX.StringExtensions.GetBeforeFirst(System.String,System.String,System.StringComparison)">
            <summary>
                Get the System.String before the first identified splitString in
                targetString.
            </summary>
            <param name="targetString">The target System.String to look in.</param>
            <param name="splitString">The divider which the targetString should be split on.</param>
            <param name="comparison">Specifies the culture, case, and sort rules to be used.</param>
            <returns>The content before the splitString, or <c>null</c> if none is found.</returns>
        </member>
        <member name="M:GDX.StringExtensions.GetBeforeLast(System.String,System.String,System.StringComparison)">
            <summary>
                Get the System.String before the last identified splitString in
                targetString.
            </summary>
            <param name="targetString">The target System.String to look in.</param>
            <param name="splitString">The divider which the targetString should be split on.</param>
            <param name="comparison">Specifies the culture, case, and sort rules to be used.</param>
            <returns>The content before the splitString, or <c>null</c> if none is found.</returns>
        </member>
        <member name="M:GDX.StringExtensions.GetStableUpperCaseHashCode(System.String)">
            <summary>
                <para>
                    Get the stable hash code value of targetString (converted to an uppercase
                    System.String).
                </para>
            </summary>
            <remarks>
                This loosely based on the FowlerNollVo (FNV) hash function. It's value will be identical
                to the value produced natively by processing a System.String with
                System.String.ToUpper.System.String.GetHashCode, but with no
                allocations.
            </remarks>
            <param name="targetString">The target System.String.</param>
            <returns>A System.Int32 value.</returns>
        </member>
        <member name="M:GDX.StringExtensions.GetStableLowerCaseHashCode(System.String)">
            <summary>
                <para>
                    Get the stable hash code value of targetString (converted to an uppercase
                    System.String).
                </para>
            </summary>
            <remarks>
                This loosely based on the FowlerNollVo (FNV) hash function. It's value will be identical
                to the value produced natively by processing a System.String with
                System.String.ToLower.System.String.GetHashCode, but with no
                allocations.
            </remarks>
            <param name="targetString">The target System.String.</param>
            <returns>A System.Int32 value.</returns>
        </member>
        <member name="M:GDX.StringExtensions.HasLowerCase(System.String)">
            <summary>
                Determine if there are any lowercase letters in the provided targetString.
            </summary>
            <param name="targetString">The target System.String.</param>
            <returns>true/false if lowercase letters were found.</returns>
        </member>
        <member name="M:GDX.StringExtensions.HasUpperCase(System.String)">
            <summary>
                Determine if there are any uppercase letters in the provided targetString.
            </summary>
            <param name="targetString">The target System.String.</param>
            <returns>true/false if uppercase letters were found.</returns>
        </member>
        <member name="M:GDX.StringExtensions.IsBooleanValue(System.String)">
            <summary>
                Determine if the targetString represents a boolean value arrangement.
            </summary>
            <param name="targetString">The target System.String.</param>
            <returns>true/false if the targetString can be evaluated as a boolean value.</returns>
        </member>
        <member name="M:GDX.StringExtensions.IsBooleanPositiveValue(System.String)">
            <summary>
                Determine if the targetString represents a positive boolean value arrangement.
            </summary>
            <example>
                Useful method when trying to parse data for branching.
                <code>
                    if(data["set"].IsBooleanPositiveValue())
                    {
                        ShouldBlueBox();
                    }
                </code>
            </example>
            <param name="targetString">The target System.String.</param>
            <returns>true/false if the targetString can be evaluated as a positive boolean value.</returns>
        </member>
        <member name="M:GDX.StringExtensions.IsIntegerValue(System.String)">
            <summary>
                Determine if the targetString is an System.Int32 value.
            </summary>
            <remarks>
                This method is meant for when you do not actually need the value returned, merely an evaluation if
                the provided targetString is an System.Int32. This does not qualify
                System.Single values positively.
            </remarks>
            <param name="targetString">The target System.String.</param>
            <returns>true/false if it contains an System.Int32.</returns>
        </member>
        <member name="M:GDX.StringExtensions.IsNumeric(System.String)">
            <summary>
                Is the targetString a numeric value.
            </summary>
            <remarks>
                <para>
                    The following requirements must be met to be considered a valid number in this method:
                </para>
                <list type="bullet">
                    <item>
                        <description>
                            The first character may be an indicator of its sign, an explicit acceptance of <c>-</c> is made. If
                            prefixed with <c>+</c>, the number will be found invalid.
                        </description>
                    </item>
                    <item>
                        <description>A single decimal point <c>.</c> may be present in the targetString.</description>
                    </item>
                    <item>
                        <description>No alphabet characters are present in the targetString.</description>
                    </item>
                </list>
            </remarks>
            <param name="targetString">The target System.String.</param>
            <returns>true/false if the targetString qualifies as a numeric value.</returns>
        </member>
        <member name="M:GDX.StringExtensions.CountOccurence(System.String,System.Char)">
            <summary>
                Counts the number of times the needle (targetCharacter) appears in the haystack (targetString).
            </summary>
            <remarks>Specifically created to avoid using LINQ and avoid an allocation.</remarks>
            <param name="targetString">The haystack.</param>
            <param name="targetCharacter">The needle.</param>
            <returns>The number of times targetCharacter is found in targetString.</returns>
        </member>
        <member name="M:GDX.StringExtensions.TryParseVector2(System.String,UnityEngine.Vector2@)">
            <summary>
                Attempt to parse a System.String into a UnityEngine.Vector2.
            </summary>
            <remarks>This isn't great for runtime performance, it should be used predominantly when reconstructing data.</remarks>
            <param name="targetString">The System.String to convert into a UnityEngine.Vector2 if possible.</param>
            <param name="outputVector2">The outputted UnityEngine.Vector2.</param>
            <returns>true/false if the conversion was successful.</returns>
        </member>
        <member name="M:GDX.StringExtensions.TryParseVector3(System.String,UnityEngine.Vector3@)">
            <summary>
                Attempt to parse a System.String into a UnityEngine.Vector3.
            </summary>
            <remarks>This isn't great for runtime performance, it should be used predominantly when reconstructing data.</remarks>
            <param name="targetString">The System.String to convert into a UnityEngine.Vector3 if possible.</param>
            <param name="outputVector3">The outputted UnityEngine.Vector3.</param>
            <returns>true/false if the conversion was successful.</returns>
        </member>
        <member name="M:GDX.StringExtensions.SplitCamelCase(System.String,System.String)">
            <summary>
                Create a new string, splitting an existing string up based on camel case formatting.
            </summary>
            <param name="targetString">The target System.String.</param>
            <param name="divider">The System.String to put in between the split System.String.</param>
            <returns>A new System.String.</returns>
        </member>
        <member name="T:GDX.ByteExtensions">
            <summary>
                System.Byte Based Extension Methods
            </summary>
        </member>
        <member name="M:GDX.ByteExtensions.GetStableHashCode(System.Byte[])">
            <summary>
                <para>Get the stable hash code of targetBytes, an array of System.Byte.</para>
            </summary>
            <remarks>Does NOT get the object's hashcode.</remarks>
            <param name="targetBytes">The target array of System.Byte.</param>
            <returns>A System.Int32 value.</returns>
        </member>
        <member name="M:GDX.ByteExtensions.IsSame(System.Byte[],System.Byte[])">
            <summary>
                Are the two provided System.Byte arrays the same.
            </summary>
            <param name="sourceBytes">The left hand side System.Byte array to compare.</param>
            <param name="targetBytes">The right hand side System.Byte array to compare.</param>
            <returns>true if they are identical, will also return true if both are null.</returns>
        </member>
        <member name="T:GDX.Jobs.ParallelFor.IntegerBufferCopyJob">
            <summary>
                Copy one Unity.Collections.NativeArray`1 typed as System.Int32 to another in
                parallel.
            </summary>
            <remarks>
                <para>
                    The GDX.Jobs.ParallelFor.IntegerBufferCopyJob relies on the Unity.Jobs.IJobParallelFor which
                    requires UnityEngine.CoreModule.dll.
                </para>
            </remarks>
        </member>
        <member name="F:GDX.Jobs.ParallelFor.IntegerBufferCopyJob.Destination">
            <summary>
                <para>The destination Unity.Collections.NativeArray`1 typed as System.Int32.</para>
            </summary>
            <remarks>Write-only.</remarks>
        </member>
        <member name="F:GDX.Jobs.ParallelFor.IntegerBufferCopyJob.Source">
            <summary>
                <para>The source Unity.Collections.NativeArray`1 typed as System.Int32.</para>
            </summary>
            <remarks>Read-only.</remarks>
        </member>
        <member name="M:GDX.Jobs.ParallelFor.IntegerBufferCopyJob.Execute(System.Int32)">
            <summary>
            Executable work for the provided index.
            </summary>
            <param name="index">The index of the Parallel for loop at which to perform work.</param>
        </member>
        <member name="T:GDX.Jobs.ParallelFor.IntegerBufferSwapJob">
            <summary>
                Swaps a Unity.Collections.NativeArray`1 typed as System.Int32 with a another
                in parallel.
            </summary>
            <remarks>
                <para>
                    The GDX.Jobs.ParallelFor.IntegerBufferSwapJob relies on the Unity.Jobs.IJobParallelFor which
                    requires UnityEngine.CoreModule.dll.
                </para>
            </remarks>
        </member>
        <member name="F:GDX.Jobs.ParallelFor.IntegerBufferSwapJob.A">
            <summary>
                The left-hand side Unity.Collections.NativeArray`1 typed as System.Int32.
            </summary>
        </member>
        <member name="F:GDX.Jobs.ParallelFor.IntegerBufferSwapJob.B">
            <summary>
                The right-hand side Unity.Collections.NativeArray`1 typed as System.Int32.
            </summary>
        </member>
        <member name="M:GDX.Jobs.ParallelFor.IntegerBufferSwapJob.Execute(System.Int32)">
            <summary>
            Executable work for the provided index.
            </summary>
            <param name="index">The index of the Parallel for loop at which to perform work.</param>
        </member>
        <member name="T:GDX.Jobs.ParallelFor.IntegerBufferFillJob">
            <summary>
                Fills a Unity.Collections.NativeArray`1 typed as System.Int32 with a value in
                parallel.
            </summary>
            <remarks>
                <para>
                    The GDX.Jobs.ParallelFor.IntegerBufferFillJob relies on the Unity.Jobs.IJobParallelFor which
                    requires UnityEngine.CoreModule.dll.
                </para>
            </remarks>
        </member>
        <member name="F:GDX.Jobs.ParallelFor.IntegerBufferFillJob.Buffer">
            <summary>
                <para>The Unity.Collections.NativeArray`1 which is going to be filled.</para>
            </summary>
            <remarks>Write-only.</remarks>
        </member>
        <member name="F:GDX.Jobs.ParallelFor.IntegerBufferFillJob.FillValue">
            <summary>
                <para>The System.Int32 value to fill the native array with.</para>
            </summary>
            <remarks>Read-only.</remarks>
        </member>
        <member name="M:GDX.Jobs.ParallelFor.IntegerBufferFillJob.Execute(System.Int32)">
            <summary>
            Executable work for the provided index.
            </summary>
            <param name="index">The index of the Parallel for loop at which to perform work.</param>
        </member>
        <member name="T:GDX.InspectorMessageBoxAttribute">
            <summary>
                Create a message box of information above the property in the inspector.
            </summary>
        </member>
        <member name="T:GDX.InspectorMessageBoxAttribute.MessageBoxType">
            <summary>
                Valid types of messages.
            </summary>
        </member>
        <member name="T:GDX.HideFromDocFXAttribute">
            <summary>
                Hide the attributed item from DocFX documentation generation.
            </summary>
            <example>
                <para>
                    For this to work a custom entry in a projects <c>filterConfig.yml</c> is necessary to define the exclusion.
                </para>
                <code>
                - exclude:
                    hasAttribute:
                    uid: GDX.HideFromDocFXAttribute
                </code>
            </example>
        </member>
        <member name="T:GDX.VisualScriptingCollectionAttribute">
            <summary>
                Indicate that the tagged <c>class</c> or <c>struct</c> should be considered as containing a collection when adding to Visual Scripting.
            </summary>
        </member>
        <member name="T:GDX.VisualScriptingExtensionAttribute">
            <summary>
                Indicate that the tagged <c>class</c> should be considered as containing extension methods when adding to Visual Scripting.
            </summary>
        </member>
        <member name="T:GDX.VisualScriptingTypeAttribute">
            <summary>
                Indicate that the tagged <c>class</c> or <c>struct</c> should be considered as containing a type when adding to Visual Scripting.
            </summary>
        </member>
        <member name="T:GDX.VisualScriptingUtilityAttribute">
            <summary>
                Indicate that the tagged <c>class</c> should be considered as containing utility functionality when adding to Visual Scripting.
            </summary>
        </member>
        <member name="T:GDX.DisableInInspectorAttribute">
            <summary>
                Make the field in the inspector disabled by toggling GUI.enabled before and after.
            </summary>
        </member>
        <member name="T:GDX.MeshExtensions">
            <summary>
                UnityEngine.Mesh Based Extension Methods
            </summary>
        </member>
        <member name="M:GDX.MeshExtensions.CalculateVolume(UnityEngine.Mesh)">
            <summary>
                Determine the volume of a given mesh.
            </summary>
            <remarks>
                Based off of https://n-e-r-v-o-u-s.com/blog/?p=4415.
            </remarks>
            <param name="targetMesh">The mesh to evaluate for its volume.</param>
            <returns>The meshes volume.</returns>
        </member>
        <member name="T:GDX.RigidbodyExtensions">
            <summary>
                UnityEngine.Rigidbody Based Extension Methods
            </summary>
        </member>
        <member name="M:GDX.RigidbodyExtensions.MomentOfInertia(UnityEngine.Rigidbody,UnityEngine.Vector3)">
            <summary>
                Get a UnityEngine.Rigidbody's moment of inertia for a targetAxis.
            </summary>
            <remarks>
                Provided targetAxis must not be P:UnityEngine.Vector3.zero.
            </remarks>
            <param name="targetRigidbody">The UnityEngine.Rigidbody to evaluate.</param>
            <param name="targetAxis">The axis use to calculate the moment of inertia.</param>
            <returns>The moment of inertia for the targetAxis.</returns>
        </member>
        <member name="T:GDX.GDXConfig">
            <summary>
                Project-wide configuration which is available at runtime.
            </summary>
            <remarks>Requires UnityEngine.CoreModule.dll to function correctly.</remarks>
        </member>
        <member name="F:GDX.GDXConfig.s_runtimeInstance">
            <summary>
                A runtime only instance of GDX.GDXConfig.
            </summary>
        </member>
        <member name="F:GDX.GDXConfig.updateProviderCheckForUpdates">
            <summary>
                Should GDX check for updates at editor time?
            </summary>
        </member>
        <member name="F:GDX.GDXConfig.developerCommandLineParserArgumentPrefix">
            <summary>
                What should be used to denote arguments in the command line?
            </summary>
        </member>
        <member name="F:GDX.GDXConfig.developerCommandLineParserArgumentSplit">
            <summary>
                What should be used to split arguments from their values in the command line?
            </summary>
        </member>
        <member name="F:GDX.GDXConfig.developerBuildInfoAssemblyDefinition">
            <summary>
                Ensure that there is an assembly definition wrapping the generated content.
            </summary>
        </member>
        <member name="F:GDX.GDXConfig.developerBuildInfoEnabled">
            <summary>
                Should the BuildInfo file be written during builds?
            </summary>
        </member>
        <member name="F:GDX.GDXConfig.developerBuildInfoPath">
            <summary>
                The path to output the BuildInfo file.
            </summary>
        </member>
        <member name="F:GDX.GDXConfig.developerBuildInfoNamespace">
            <summary>
                The namespace where the BuildInfo should be placed.
            </summary>
        </member>
        <member name="F:GDX.GDXConfig.developerBuildInfoBuildNumberArgument">
            <summary>
                The argument key for the build number to be passed to the BuildInfoGenerator.
            </summary>
        </member>
        <member name="F:GDX.GDXConfig.developerBuildInfoBuildDescriptionArgument">
            <summary>
                The argument key for the build description to be passed to the BuildInfoGenerator.
            </summary>
        </member>
        <member name="F:GDX.GDXConfig.developerBuildInfoBuildChangelistArgument">
            <summary>
                The argument key for the build's changelist to be passed to the BuildInfoGenerator.
            </summary>
        </member>
        <member name="F:GDX.GDXConfig.developerBuildInfoBuildTaskArgument">
            <summary>
                The argument key for the build's task to be passed to the BuildInfoGenerator.
            </summary>
        </member>
        <member name="F:GDX.GDXConfig.developerBuildInfoBuildStreamArgument">
            <summary>
                The argument key for the build's stream to be passed to the BuildInfoGenerator.
            </summary>
        </member>
        <member name="F:GDX.GDXConfig.environmentScriptingDefineSymbol">
            <summary>
                Should a GDX scripting define symbol be added to all target build groups.
            </summary>
        </member>
        <member name="F:GDX.GDXConfig.traceDevelopmentLevels">
            <summary>
                What is the level of traces which should be processed and logged by GDX in the editor or development builds?
            </summary>
        </member>
        <member name="F:GDX.GDXConfig.traceDebugLevels">
            <summary>
                What is the level of traces which should be processed and logged by GDX in debug builds?
            </summary>
        </member>
        <member name="F:GDX.GDXConfig.traceReleaseLevels">
            <summary>
                What is the level of traces which should be processed and logged by GDX in release builds?
            </summary>
        </member>
        <member name="F:GDX.GDXConfig.traceDevelopmentOutputToUnityConsole">
            <summary>
                Should GDX based traces output to the Unity console in the editor or development builds?
            </summary>
        </member>
        <member name="F:GDX.GDXConfig.traceDebugOutputToUnityConsole">
            <summary>
                Should GDX based traces output to the Unity console in debug builds?
            </summary>
        </member>
        <member name="F:GDX.GDXConfig.localizationSetDefaultCulture">
            <summary>
                Should the default thread culture be set?
            </summary>
        </member>
        <member name="F:GDX.GDXConfig.localizationDefaultCulture">
            <summary>
                The language to set the default thread culture too.
            </summary>
        </member>
        <member name="M:GDX.GDXConfig.Get">
            <summary>
                Get a loaded instance of the GDX.GDXConfig from resources.
            </summary>
            <remarks>Requires UnityEngine.CoreModule.dll to function correctly.</remarks>
            <returns>A instance of GDX.GDXConfig.</returns>
        </member>
        <member name="T:GDX.Vector2Extensions">
            <summary>
                UnityEngine.Vector2 Based Extension Methods
            </summary>
        </member>
        <member name="M:GDX.Vector2Extensions.Approximately(UnityEngine.Vector2,UnityEngine.Vector2)">
            <summary>
                Is one UnityEngine.Vector2 approximately similar to another UnityEngine.Vector2?
            </summary>
            <remarks>Includes optimized Unity.Mathematics approach.</remarks>
            <param name="targetVector2">Point A</param>
            <param name="otherVector2">Point B</param>
            <returns>Are the two UnityEngine.Vector2 approximately the same?</returns>
        </member>
        <member name="M:GDX.Vector2Extensions.Slope(UnityEngine.Vector2)">
            <summary>
            Get the slope of a UnityEngine.Vector2.
            </summary>
            <param name="targetVector2">The UnityEngine.Vector2 to evaluate.</param>
            <returns>The slope value.</returns>
        </member>
        <member name="M:GDX.Vector2Extensions.Midpoint(UnityEngine.Vector2,UnityEngine.Vector2)">
            <summary>
                Get the midpoint between two UnityEngine.Vector2s.
            </summary>
            <param name="targetVector2">Point A</param>
            <param name="otherVector2">Point B</param>
            <returns>The midpoint between targetVector2 and otherVector2.</returns>
        </member>
        <member name="M:GDX.Vector2Extensions.NearestIndex(UnityEngine.Vector2,UnityEngine.Vector2[])">
            <summary>
                Find the index of the UnityEngine.Vector2 in otherVector2 that is nearest to the
                targetVector2.
            </summary>
            <param name="targetVector2">The UnityEngine.Vector2 to use as the point of reference.</param>
            <param name="otherVector2">An array of UnityEngine.Vector2 positions to evaluate for which one is nearest.</param>
            <returns>
                The index of the nearest otherVector2 element to targetVector2.
                Returning -1 if the the otherVector2 has no elements or is null.
            </returns>
        </member>
        <member name="T:GDX.ArrayExtensions">
            <summary>
                Array Based Extension Methods
            </summary>
        </member>
        <member name="M:GDX.ArrayExtensions.Clear``1(``0[])">
            <summary>
                Set all elements in an array to the default values.
            </summary>
            <remarks>
                This does not alter the targetArray's length.
            </remarks>
            <param name="targetArray">The array to be defaulted.</param>
            <typeparam name="T">The type of the array.</typeparam>
        </member>
        <member name="M:GDX.ArrayExtensions.FirstIndexOfItem``1(``0[],``0)">
            <summary>
                Find the first index of targetItem in targetArray.
            </summary>
            <param name="targetArray">The array which to look in.</param>
            <param name="targetItem">The object to be found.</param>
            <typeparam name="T">The type of the array.</typeparam>
            <returns>The index of targetItem in targetArray, or -1 if not found.</returns>
        </member>
        <member name="M:GDX.ArrayExtensions.FirstIndexOfValue``1(``0[],``0)">
            <summary>
                Find the first index of targetValue in targetArray.
            </summary>
            <param name="targetArray">The array which to look in.</param>
            <param name="targetValue">The value to be found.</param>
            <typeparam name="T">The type of the array.</typeparam>
            <returns>The index of targetValue in targetArray, or -1 if not found.</returns>
        </member>
        <member name="M:GDX.ArrayExtensions.LastIndexOfItem``1(``0[],``0)">
            <summary>
                Find the last index of targetItem in targetArray.
            </summary>
            <param name="targetArray">The array which to look in.</param>
            <param name="targetItem">The object to be found.</param>
            <typeparam name="T">The type of the array.</typeparam>
            <returns>The index of targetItem in targetArray, or -1 if not found.</returns>
        </member>
        <member name="M:GDX.ArrayExtensions.LastIndexOfValue``1(``0[],``0)">
            <summary>
                Find the last index of targetValue in targetArray.
            </summary>
            <param name="targetArray">The array which to look in.</param>
            <param name="targetValue">The value to be found.</param>
            <typeparam name="T">The type of the array.</typeparam>
            <returns>The index of targetValue in targetArray, or -1 if not found.</returns>
        </member>
        <member name="T:GDX.Vector3Extensions">
            <summary>
                UnityEngine.Vector3 Based Extension Methods
            </summary>
        </member>
        <member name="M:GDX.Vector3Extensions.Approximately(UnityEngine.Vector3,UnityEngine.Vector3)">
            <summary>
                Is one UnityEngine.Vector3 approximately similar to another UnityEngine.Vector3?
            </summary>
            <remarks>Includes optimized Unity.Mathematics approach.</remarks>
            <param name="targetVector3">Point A</param>
            <param name="otherVector3">Point B</param>
            <returns>Are the two UnityEngine.Vector3 approximately the same?</returns>
        </member>
        <member name="M:GDX.Vector3Extensions.DistanceSqr(UnityEngine.Vector3,UnityEngine.Vector3)">
            <summary>
                Calculate the squared distance between two UnityEngine.Vector3.
            </summary>
            <remarks>
                <para>Based on https://en.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance.</para>
            </remarks>
            <param name="targetVector3">Point A</param>
            <param name="otherVector3">Point B</param>
            <returns>The squared distance.</returns>
        </member>
        <member name="M:GDX.Vector3Extensions.HorizontalDistance(UnityEngine.Vector3,UnityEngine.Vector3)">
            <summary>
                Get the horizontal distance between two UnityEngine.Vector3 points.
            </summary>
            <remarks>Ignores the Y-axis completely.</remarks>
            <param name="targetVector3">Point A</param>
            <param name="otherVector3">Point B</param>
            <returns>The horizontal distance.</returns>
        </member>
        <member name="M:GDX.Vector3Extensions.DistanceToRay(UnityEngine.Vector3,UnityEngine.Ray)">
            <summary>
            Calculate the distance from a UnityEngine.Vector3 to a UnityEngine.Ray.
            </summary>
            <param name="targetVector3">The position.</param>
            <param name="targetRay">The line.</param>
            <returns>The distance.</returns>
        </member>
        <member name="M:GDX.Vector3Extensions.Midpoint(UnityEngine.Vector3,UnityEngine.Vector3)">
            <summary>
                Get the midpoint between two UnityEngine.Vector3s.
            </summary>
            <param name="targetVector3">Point A</param>
            <param name="otherVector3">Point B</param>
            <returns>The midpoint between targetVector3 and otherVector3.</returns>
        </member>
        <member name="M:GDX.Vector3Extensions.NearestIndex(UnityEngine.Vector3,UnityEngine.Vector3[])">
            <summary>
                Find the index of the UnityEngine.Vector3 in otherVector3 that is nearest to the
                targetVector3.
            </summary>
            <param name="targetVector3">The UnityEngine.Vector3 to use as the point of reference.</param>
            <param name="otherVector3">An array of UnityEngine.Vector3 positions to evaluate for which one is nearest.</param>
            <returns>
                The index of the nearest otherVector3 element to targetVector3.
                Returning -1 if the the otherVector3 has no elements or is null.
            </returns>
        </member>
        <member name="T:GDX.Display">
            <summary>
                A collection of display related helper utilities.
            </summary>
            <remarks>Requires UnityEngine.CoreModule.dll to function correctly.</remarks>
        </member>
        <member name="M:GDX.Display.GetScreenHeight">
            <summary>
                <para>Returns the actual screen height being rendered on the current platform.</para>
            </summary>
            <remarks>This resolves issues with scaled rendering.</remarks>
            <returns>The pixel height of the screen resolution.</returns>
        </member>
        <member name="M:GDX.Display.GetScreenWidth">
            <summary>
                <para>Returns the actual screen width being rendered on the current platform.</para>
            </summary>
            <remarks>This resolves issues with scaled rendering.</remarks>
            <returns>The pixel width of the screen resolution.</returns>
        </member>
        <member name="M:GDX.Display.IsHDRSupported">
            <summary>
                Does the current display device support HDR output?
            </summary>
            <returns>true/false</returns>
        </member>
        <member name="M:GDX.Display.IsHDREnabled">
            <summary>
                Is HDR output currently enabled (and actively being used)?
            </summary>
            <returns>true/false</returns>
        </member>
        <member name="T:GDX.EnumExtensions">
            <summary>
                Enumeration Based Extension Methods
            </summary>
        </member>
        <member name="M:GDX.EnumExtensions.HasFlags``1(``0*,``0*)">
            <summary>
                Determine if the provide flags (needles) are found in the haystack.
            </summary>
            <param name="haystack">A predefined flag based enumeration.</param>
            <param name="needles">A set of flags to search for in the predefined enumeration.</param>
            <typeparam name="T">The enumeration's type.</typeparam>
            <returns>true if the needles are found in the haystack, otherwise false.</returns>
        </member>
        <member name="M:GDX.EnumExtensions.HasFlags``1(``0,``0)">
            <summary>
                Determine if the provide flags (needles) are found in the haystack.
            </summary>
            <remarks>Faster then System.Enum.HasFlag(System.Enum).</remarks>
            <param name="haystack">A predefined flag based enumeration.</param>
            <param name="needles">A set of flags to search for in the predefined enumeration.</param>
            <typeparam name="T">The enumeration's type.</typeparam>
            <returns>true if the needles are found in the haystack, otherwise false.</returns>
        </member>
        <member name="T:GDX.Platform">
            <summary>
                A collection of platform related helper utilities.
            </summary>
        </member>
        <member name="M:GDX.Platform.EnsureFolderHierarchyExists(System.String)">
            <summary>
                Validate that all directories are created for a given folderPath.
            </summary>
            <param name="folderPath">The path to process and validate.</param>
        </member>
        <member name="M:GDX.Platform.EnsureFileFolderHierarchyExists(System.String)">
            <summary>
                Validate that all parent directories are created for a given filePath.
            </summary>
            <param name="filePath">The path to process and validate.</param>
        </member>
        <member name="M:GDX.Platform.GetHardwareGeneration">
            <summary>
                Gets the current platforms hardware generation number?
            </summary>
            <remarks>Requires UnityEngine.CoreModule.dll to function correctly.</remarks>
            <returns>true/false</returns>
        </member>
        <member name="M:GDX.Platform.IsFocused">
            <summary>
                Is the application focused?
            </summary>
            <remarks>
                There are issues on some platforms with getting an accurate reading.
            </remarks>
            <returns>true/false if the application has focus.</returns>
        </member>
        <member name="M:GDX.Platform.IsHeadless">
            <summary>
            Is the application running in headless mode?.
            </summary>
            <remarks>Useful for detecting running a server.</remarks>
            <returns>true/false if the application is without an initialized graphics device.</returns>
        </member>
        <member name="T:GDX.Memory">
            <summary>
                A collection of memory related helper utilities.
            </summary>
            <remarks>Requires UnityEngine.CoreModule.dll to function correctly.</remarks>
        </member>
        <member name="M:GDX.Memory.CleanUp">
            <summary>
                <para>Cleanup Memory</para>
                <list type="bullet">
                    <item>
                        <description>Mono Heap (Garbage Collection)</description>
                    </item>
                    <item>
                        <description>Unity Resources</description>
                    </item>
                </list>
            </summary>
            <remarks>
                <para>Requires UnityEngine.CoreModule.dll to function correctly.</para>
            </remarks>
        </member>
        <member name="M:GDX.Memory.CleanUpAsync">
            <inheritdoc cref="M:GDX.Memory.CleanUp" />
            <remarks>Requires UnityEngine.CoreModule.dll to function correctly.</remarks>
        </member>
        <member name="T:GDX.IO.Compression.TarFile">
            <summary>
            Provides static methods for extracting tar files and tarballs.
            </summary>
        </member>
        <member name="M:GDX.IO.Compression.TarFile.ExtractToDirectory(System.String,System.String,System.Boolean)">
            <summary>
                Extracts all the files in the specified tar/tarball to a directory on the file system.
            </summary>
            <example>
                A synchronous approach to extracting the contents of a file, to a folder:
                <code>TarFile.ExtractToDirectory("C:\Temp\DownloadCache.tar.gz", "C:\Saved");</code>
            </example>
            <param name="sourceArchiveFileName">The path to the archive that is to be extracted.</param>
            <param name="destinationDirectoryName">
                The path to the directory in which to place the extracted files, specified as a
                relative or absolute path. A relative path is interpreted as relative to the current working directory.
            </param>
            <param name="forceGZipDataFormat">Enforce inflating the file via a System.IO.Compression.GZipStream.</param>
        </member>
        <member name="M:GDX.IO.Compression.TarFile.ExtractStream(System.IO.Stream,System.String)">
            <summary>
                Extract a tar formatted System.IO.Stream to the destinationDirectoryName.
            </summary>
            <param name="sourceStream">The System.IO.Stream which to extract from.</param>
            <param name="destinationDirectoryName">Output directory to write the files.</param>
        </member>
        <member name="T:GDX.NavMeshPathExtensions">
            <summary>
                UnityEngine.AI.NavMeshPath Based Extension Methods
            </summary>
        </member>
        <member name="M:GDX.NavMeshPathExtensions.GetTotalDistance(UnityEngine.AI.NavMeshPath)">
            <summary>
                Get the total travel distance, from start to finish of a calculated UnityEngine.AI.NavMeshPath.
            </summary>
            <remarks>The P:UnityEngine.AI.NavMeshPath.corners does allocate internally.</remarks>
            <param name="targetNavMeshPath">The calculated path to evaluate for its length.</param>
            <returns>The total distance of a calculated path.</returns>
        </member>
        <member name="M:GDX.NavMeshPathExtensions.GetTotalDistanceSqr(UnityEngine.AI.NavMeshPath)">
            <summary>
                Get the total squared distance, from start to finish of a calculated UnityEngine.AI.NavMeshPath.
            </summary>
            <remarks>The P:UnityEngine.AI.NavMeshPath.corners does allocate internally.</remarks>
            <param name="targetNavMeshPath">The calculated path to evaluate for its squared length.</param>
            <returns>The total squared distance of a calculated path.</returns>
        </member>
        <member name="M:GDX.NavMeshPathExtensions.GetPositionAtDistance(UnityEngine.AI.NavMeshPath,System.Single)">
            <summary>
                Get a position along a UnityEngine.AI.NavMeshPath based on the travel distance along it.
            </summary>
            <param name="targetNavMeshPath">The calculated path to evaluate for the position.</param>
            <param name="distance">The distance along the calculated path to find the position at.</param>
            <returns>The position found on the UnityEngine.AI.NavMeshPath.</returns>
        </member>
        <member name="M:GDX.NavMeshPathExtensions.GetPositionAtDistanceSqr(UnityEngine.AI.NavMeshPath,System.Single)">
            <summary>
                Get a position along a UnityEngine.AI.NavMeshPath based on the travel square distance along it.
            </summary>
            <param name="targetNavMeshPath">The calculated path to evaluate for the position.</param>
            <param name="distance">The distance along the calculated path to find the position at.</param>
            <returns>The position found on the UnityEngine.AI.NavMeshPath.</returns>
        </member>
        <member name="T:GDX.SimpleListExtensions">
            <summary>
                GDX.Collections.Generic.SimpleList`1 Based Extension Methods
            </summary>
        </member>
        <member name="M:GDX.SimpleListExtensions.AddUncheckedUniqueItem``1(GDX.Collections.Generic.SimpleList{``0}@,``0)">
            <summary>
                Add an item to the GDX.Collections.Generic.SimpleList`1 without checking the internal size,
                making sure that the item is not already contained in the GDX.Collections.Generic.SimpleList`1.
            </summary>
            <param name="targetSimpleList">The target GDX.Collections.Generic.SimpleList`1 to add to.</param>
            <param name="targetItem">The target class object to add.</param>
            <typeparam name="T">The type of the GDX.Collections.Generic.SimpleList`1.</typeparam>
            <returns>true/false if the operation was able to add the item successfully.</returns>
        </member>
        <member name="M:GDX.SimpleListExtensions.AddUncheckedUniqueValue``1(GDX.Collections.Generic.SimpleList{``0}@,``0)">
            <summary>
                Add a value to the GDX.Collections.Generic.SimpleList`1 without checking the internal size,
                making sure that the value is not already contained in the GDX.Collections.Generic.SimpleList`1.
            </summary>
            <param name="targetSimpleList">The target GDX.Collections.Generic.SimpleList`1 to add to.</param>
            <param name="targetValue">The value to add.</param>
            <typeparam name="T">The type of the GDX.Collections.Generic.SimpleList`1.</typeparam>
            <returns>true/false if the operation was able to add the value successfully.</returns>
        </member>
        <member name="M:GDX.SimpleListExtensions.AddWithExpandCheckUniqueItem``1(GDX.Collections.Generic.SimpleList{``0}@,``0)">
            <summary>
                Add an item to the GDX.Collections.Generic.SimpleList`1 with checking the internal size (expanding as necessary),
                making sure that the item is not already contained in the GDX.Collections.Generic.SimpleList`1.
            </summary>
            <param name="targetSimpleList">The target GDX.Collections.Generic.SimpleList`1 to add to.</param>
            <param name="targetItem">The target class object to add.</param>
            <typeparam name="T">The type of the GDX.Collections.Generic.SimpleList`1.</typeparam>
            <returns>true/false if the operation was able to add the item successfully.</returns>
        </member>
        <member name="M:GDX.SimpleListExtensions.AddWithExpandCheckUniqueValue``1(GDX.Collections.Generic.SimpleList{``0}@,``0)">
            <summary>
                Add a value to the GDX.Collections.Generic.SimpleList`1 with checking the internal size (expanding as necessary),
                making sure that the value is not already contained in the GDX.Collections.Generic.SimpleList`1.
            </summary>
            <param name="targetSimpleList">The target GDX.Collections.Generic.SimpleList`1 to add to.</param>
            <param name="targetValue">The value to add.</param>
            <typeparam name="T">The type of the GDX.Collections.Generic.SimpleList`1.</typeparam>
            <returns>true/false if the operation was able to add the value successfully.</returns>
        </member>
        <member name="M:GDX.SimpleListExtensions.ContainsItem``1(GDX.Collections.Generic.SimpleList{``0}@,``0)">
            <summary>
                <para>Does targetSimpleList contain targetItem?</para>
            </summary>
            <remarks>Avoids using System.Collections.Generic.EqualityComparer`1.</remarks>
            <param name="targetSimpleList">The GDX.Collections.Generic.SimpleList`1 to look in.</param>
            <param name="targetItem">The target class object to look for.</param>
            <typeparam name="T">The type of the GDX.Collections.Generic.SimpleList`1.</typeparam>
            <returns>true/false</returns>
        </member>
        <member name="M:GDX.SimpleListExtensions.ContainsValue``1(GDX.Collections.Generic.SimpleList{``0}@,System.Object)">
            <summary>
                <para>Does targetSimpleList contain targetValue?</para>
            </summary>
            <remarks>
                WARNING: This will box the targetValue. You should probably write your own explicit
                implementation.
            </remarks>
            <param name="targetSimpleList">The GDX.Collections.Generic.SimpleList`1 to look in.</param>
            <param name="targetValue">The value to look for.</param>
            <typeparam name="T">The type of the GDX.Collections.Generic.SimpleList`1.</typeparam>
            <returns>true/false</returns>
        </member>
        <member name="M:GDX.SimpleListExtensions.RemoveFirstItem``1(GDX.Collections.Generic.SimpleList{``0}@,``0)">
            <summary>
                <para>Removes the first targetItem from the provided targetSimpleList.</para>
            </summary>
            <remarks>Avoids using System.Collections.Generic.EqualityComparer`1.</remarks>
            <param name="targetSimpleList">The target GDX.Collections.Generic.SimpleList`1.</param>
            <param name="targetItem">The target object to remove from the targetSimpleList.</param>
            <typeparam name="T">The type of the GDX.Collections.Generic.SimpleList`1.</typeparam>
            <returns>true/false if an item was removed.</returns>
        </member>
        <member name="M:GDX.SimpleListExtensions.RemoveFirstValue``1(GDX.Collections.Generic.SimpleList{``0}@,System.Object)">
            <summary>
                Removes the first targetValue from the provided targetSimpleList.
            </summary>
            <remarks>
                <para>
                    WARNING: This will box the targetValue. You should probably write your own explicit
                    implementation.
                </para>
            </remarks>
            <param name="targetSimpleList">The target GDX.Collections.Generic.SimpleList`1.</param>
            <param name="targetValue">The value to remove from the targetSimpleList.</param>
            <typeparam name="T">The type of the GDX.Collections.Generic.SimpleList`1.</typeparam>
            <returns>true/false if a value was removed.</returns>
        </member>
        <member name="M:GDX.SimpleListExtensions.RemoveItems``1(GDX.Collections.Generic.SimpleList{``0}@,``0)">
            <summary>
                <para>Removes all targetItem from the provided targetSimpleList.</para>
            </summary>
            <param name="targetSimpleList">The target GDX.Collections.Generic.SimpleList`1.</param>
            <param name="targetItem">The item to remove from the targetSimpleList.</param>
            <typeparam name="T">The type of the GDX.Collections.Generic.SimpleList`1.</typeparam>
            <returns>true/false if items were removed.</returns>
        </member>
        <member name="M:GDX.SimpleListExtensions.RemoveLastItem``1(GDX.Collections.Generic.SimpleList{``0}@,``0)">
            <summary>
                <para>Removes the last targetItem from the provided targetSimpleList.</para>
            </summary>
            <remarks>Avoids using System.Collections.Generic.EqualityComparer`1.</remarks>
            <param name="targetSimpleList">The target GDX.Collections.Generic.SimpleList`1.</param>
            <param name="targetItem">The target object to remove from the targetSimpleList.</param>
            <typeparam name="T">The type of the GDX.Collections.Generic.SimpleList`1.</typeparam>
            <returns>true/false if an item was removed.</returns>
        </member>
        <member name="M:GDX.SimpleListExtensions.RemoveLastValue``1(GDX.Collections.Generic.SimpleList{``0}@,System.Object)">
            <summary>
                Removes the last targetValue from the provided targetSimpleList.
            </summary>
            <remarks>
                <para>
                    WARNING: This will box the targetValue. You should probably write your own explicit
                    implementation.
                </para>
            </remarks>
            <param name="targetSimpleList">The target GDX.Collections.Generic.SimpleList`1.</param>
            <param name="targetValue">The value to remove from the targetSimpleList.</param>
            <typeparam name="T">The type of the GDX.Collections.Generic.SimpleList`1.</typeparam>
            <returns>true/false if a value was removed.</returns>
        </member>
        <member name="M:GDX.SimpleListExtensions.RemoveValues``1(GDX.Collections.Generic.SimpleList{``0}@,System.Object)">
            <summary>
                Removes all targetValue from the provided targetSimpleList.
            </summary>
            <remarks>
                <para>
                    WARNING: This will box the targetValue. You should probably write your own explicit
                    implementation.
                </para>
            </remarks>
            <param name="targetSimpleList">The target GDX.Collections.Generic.SimpleList`1.</param>
            <param name="targetValue">The value to remove from the targetSimpleList.</param>
            <typeparam name="T">The type of the GDX.Collections.Generic.SimpleList`1.</typeparam>
            <returns>true/false if values were removed.</returns>
        </member>
        <member name="T:GDX.CapsuleColliderExtensions">
            <summary>
                UnityEngine.CapsuleCollider Based Extension Methods
            </summary>
        </member>
        <member name="M:GDX.CapsuleColliderExtensions.Direction(UnityEngine.CapsuleCollider)">
            <summary>
                Get a UnityEngine.Vector3 based orientation of the targetCapsuleCollider.
            </summary>
            <param name="targetCapsuleCollider">The capsule collider</param>
            <returns>The direction of a UnityEngine.CapsuleCollider in its local space.</returns>
        </member>
        <member name="M:GDX.CapsuleColliderExtensions.OutSphereCenters(UnityEngine.CapsuleCollider,UnityEngine.Vector3@,UnityEngine.Vector3@)">
            <summary>
                Return into topPosition and bottomPosition, the respective world-space position of a UnityEngine.CapsuleCollider's spheres centers.
            </summary>
            <param name="targetCapsuleCollider">The UnityEngine.CapsuleCollider having its spheres evaluated.</param>
            <param name="topPosition">The determined top spheres center position in world-space.</param>
            <param name="bottomPosition">The determined bottom spheres center position in world-space.</param>
        </member>
        <member name="T:GDX.AddressablesExtensions">
            <summary>
                Addressables Based Extension Methods
            </summary>
            <remarks>
                <para>Requires UnityEngine.CoreModule.dll to function correctly.</para>
                <para>Requires <c>com.unity.addressables</c> Package.</para>
            </remarks>
        </member>
        <member name="F:GDX.AddressablesExtensions.s_emptyAssetReference">
            <summary>
                An empty instance of an UnityEngine.AddressableAssets.AssetReference to be used for comparison.
            </summary>
        </member>
        <member name="M:GDX.AddressablesExtensions.CanInstantiate(UnityEngine.AddressableAssets.AssetReference)">
            <summary>
                <para>Can targetAssetReference be instantiated at runtime?</para>
            </summary>
            <remarks>Checks that it is not empty, has a runtime key, and makes sure the key is valid.</remarks>
            <param name="targetAssetReference">The target UnityEngine.AddressableAssets.AssetReference.</param>
            <returns>true/false</returns>
        </member>
        <member name="M:GDX.AddressablesExtensions.CanRelease(UnityEngine.ResourceManagement.AsyncOperations.AsyncOperationHandle{UnityEngine.GameObject},System.Boolean)">
            <summary>
                Can the targetAsyncOperationHandle be released?
            </summary>
            <param name="targetAsyncOperationHandle">
                A target UnityEngine.ResourceManagement.AsyncOperations.AsyncOperationHandle`1
                typed as UnityEngine.GameObject.
            </param>
            <param name="autoRelease">If it can, should the handle release?</param>
            <returns>true/false</returns>
        </member>
        <member name="M:GDX.AddressablesExtensions.HasRuntimeKey(UnityEngine.AddressableAssets.AssetReference)">
            <summary>
                <para>Does targetAssetReference have a runtime key?</para>
            </summary>
            <remarks>Will return false if the reference is null.</remarks>
            <param name="targetAssetReference">The target UnityEngine.AddressableAssets.AssetReference.</param>
            <returns>true/false</returns>
        </member>
        <member name="M:GDX.AddressablesExtensions.IsEmpty(UnityEngine.AddressableAssets.AssetReference)">
            <summary>
                Is targetAssetReference empty?
            </summary>
            <param name="targetAssetReference">The target UnityEngine.AddressableAssets.AssetReference.</param>
            <returns>true/false</returns>
        </member>
        <member name="T:GDX.TransformExtensions">
            <summary>
                UnityEngine.Transform Based Extension Methods
            </summary>
            <remarks>
                Used for MonoBehaviour workflows.
            </remarks>
        </member>
        <member name="M:GDX.TransformExtensions.DestroyChildren(UnityEngine.Transform,System.Boolean,System.Boolean)">
            <summary>
                Destroy child UnityEngine.Transform.
            </summary>
            <param name="targetTransform">The parent UnityEngine.Transform to look at.</param>
            <param name="deactivateBeforeDestroy">Should the targetTransform children's UnityEngine.GameObjects be deactivated before destroying? This can be used to immediately hide an object, that will be destroyed at the end of the frame.</param>
            <param name="destroyInactive">Should inactive UnityEngine.GameObject be destroyed as well?</param>
        </member>
        <member name="M:GDX.TransformExtensions.GetActiveChildCount(UnityEngine.Transform)">
            <summary>
            Get the number of immediate children active.
            </summary>
            <param name="targetTransform">The transform to look at's children.</param>
            <returns>The number of active children transforms.</returns>
        </member>
        <member name="M:GDX.TransformExtensions.GetFirstComponentInChildrenComplex``1(UnityEngine.Transform,System.Boolean,System.Int32,System.Int32)">
            <summary>
                Search recursively for a UnityEngine.Component on the targetTransform.
            </summary>
            <param name="targetTransform">The target UnityEngine.Transform to use as the base for the search.</param>
            <param name="includeInactive">
                Include inactive child UnityEngine.GameObjects when looking for the
                UnityEngine.Component.
            </param>
            <param name="currentDepth">Current level of recursion.</param>
            <param name="maxLevelsOfRecursion">
                The maximum levels of recursion when looking for a UnityEngine.Component, -1 for
                infinite recursion.
            </param>
            <typeparam name="T">The target UnityEngine.Component type that is being looked for.</typeparam>
            <returns>The first found UnityEngine.Component.</returns>
        </member>
        <member name="M:GDX.TransformExtensions.GetScenePath(UnityEngine.Transform)">
            <summary>
                Get an in scene path to the targetTransform.
            </summary>
            <param name="targetTransform">The UnityEngine.Transform which to derive a path from.</param>
            <returns>A created path System.String.</returns>
        </member>
        <member name="T:GDX.Trace">
            <summary>
                Trace logging functionality.
            </summary>
        </member>
        <member name="T:GDX.Trace.TraceLevel">
            <summary>
            Trace Levels
            </summary>
        </member>
        <member name="F:GDX.Trace.TraceLevel.Info">
            <summary>
                A trivial informational entry.
            </summary>
        </member>
        <member name="F:GDX.Trace.TraceLevel.Log">
            <summary>
                An entry indicating something which might be useful to provide context.
            </summary>
        </member>
        <member name="F:GDX.Trace.TraceLevel.Warning">
            <summary>
                An issue has been found but handled.
            </summary>
        </member>
        <member name="F:GDX.Trace.TraceLevel.Error">
            <summary>
                An error has occurred which may be recoverable, but notification is required.
            </summary>
        </member>
        <member name="F:GDX.Trace.TraceLevel.Exception">
            <summary>
                An exception has occured and needs to be flagged up for resolution. The should never happen in a release
                environment.
            </summary>
        </member>
        <member name="F:GDX.Trace.TraceLevel.Assertion">
            <summary>
                An assertion based event has occured and has some sort of messaging to be recorded.
            </summary>
        </member>
        <member name="F:GDX.Trace.TraceLevel.Fatal">
            <summary>
                A fatal error has occured which needs to be logged, and the program will subsequently crash.
            </summary>
        </member>
        <member name="M:GDX.Trace.Output(GDX.Trace.TraceLevel,System.Object,UnityEngine.Object)">
            <summary>
                Log a trace message to the appropriate subscribers and the Unity console where applicable.
            </summary>
            <param name="level">The GDX.Trace.TraceLevel of the particular message.</param>
            <param name="traceObject">An System.Object representing the message to be recorded.</param>
            <param name="contextObject">An UnityEngine.Object indicating context for the given message.</param>
        </member>
        <member name="T:GDX.BoxColliderExtensions">
            <summary>
                UnityEngine.BoxCollider Based Extension Methods
            </summary>
        </member>
        <member name="M:GDX.BoxColliderExtensions.ContainsPosition(UnityEngine.BoxCollider,UnityEngine.Vector3)">
            <summary>
                Is the worldPosition inside of the targetBoxCollider?
            </summary>
            <param name="targetBoxCollider">The UnityEngine.BoxCollider to use for evaluation.</param>
            <param name="worldPosition">A UnityEngine.Vector3 point in world space.</param>
            <returns>true/false if the world position is contained within the targetBoxCollider.</returns>
        </member>
        <member name="T:GDX.GameObjectExtensions">
            <summary>
                UnityEngine.GameObject Based Extension Methods
            </summary>
            <remarks>
                Used for MonoBehaviour workflows.
            </remarks>
        </member>
        <member name="M:GDX.GameObjectExtensions.DestroyChildren(UnityEngine.GameObject,System.Boolean,System.Boolean)">
            <summary>
                Destroy child UnityEngine.GameObject.
            </summary>
            <param name="targetGameObject">The parent UnityEngine.GameObject to look at.</param>
            <param name="deactivateBeforeDestroy">
                Should the targetGameObject's children be deactivated before
                destroying? This can be used to immediately hide an object, that will be destroyed at the end of the frame.
            </param>
            <param name="destroyInactive">Should inactive UnityEngine.GameObject be destroyed as well?</param>
        </member>
        <member name="M:GDX.GameObjectExtensions.GetFirstComponentInChildrenComplex``1(UnityEngine.GameObject,System.Boolean,System.Boolean,System.Int32)">
            <summary>
                A slightly more complex version of UnityEngine.Component.GetComponentInChildren``1(System.Boolean) which allows for
                different hinted search options.
            </summary>
            <remarks>
                <para>
                    If the maxLevelsOfRecursion is set to 1; this will search the
                    targetGameObject and its immediate children only.
                </para>
                <para>
                    The internal UnityEngine.Component.GetComponentInChildren``1(System.Boolean) has optimizations internally in engine
                    code which make it faster in different scenarios.
                </para>
            </remarks>
            <param name="targetGameObject">The target UnityEngine.GameObject to use as the base for the search.</param>
            <param name="lookInChildrenFirst">
                Should children UnityEngine.GameObject be searched before the
                targetGameObject's UnityEngine.GameObject.
            </param>
            <param name="includeInactive">
                Include inactive child UnityEngine.GameObjects when looking for the
                UnityEngine.Component.
            </param>
            <param name="maxLevelsOfRecursion">
                The maximum levels of recursion when looking for a UnityEngine.Component, -1 for
                infinite recursion.
            </param>
            <typeparam name="T">The target UnityEngine.Component type that is being looked for.</typeparam>
            <returns>The first found UnityEngine.Component.</returns>
        </member>
        <member name="M:GDX.GameObjectExtensions.GetOrAddComponent``1(UnityEngine.GameObject)">
            <summary>
                Get a component by type from a targetGameObject, if it is not found add and return it.
            </summary>
            <remarks>Adding a component at runtime is a performance nightmare. Use with caution!</remarks>
            <param name="targetGameObject">The UnityEngine.GameObject that we should query for the component.</param>
            <typeparam name="T">The type of component.</typeparam>
            <returns>The component on the targetGameObject.</returns>
        </member>
        <member name="M:GDX.GameObjectExtensions.GetScenePath(UnityEngine.GameObject)">
            <summary>
                Get an in scene path to the targetGameObject.
            </summary>
            <param name="targetGameObject">The UnityEngine.GameObject which to derive a path from.</param>
            <returns>A created path System.String.</returns>
        </member>
        <member name="T:GDX.MonoBehaviourExtensions">
            <summary>
                UnityEngine.MonoBehaviour Based Extension Methods
            </summary>
            <remarks>
                Used for MonoBehaviour workflows.
            </remarks>
        </member>
        <member name="M:GDX.MonoBehaviourExtensions.GetFirstComponentInChildrenComplex``1(UnityEngine.MonoBehaviour,System.Boolean,System.Boolean,System.Int32)">
            <summary>
                A slightly more complex version of UnityEngine.Component.GetComponentInChildren``1(System.Boolean) which allows for
                different hinted search options.
            </summary>
            <remarks>
                <para>
                    If the maxLevelsOfRecursion is set to 1; this will search the
                    targetMonoBehaviour and its immediate children only.
                </para>
                <para>
                    The internal UnityEngine.Component.GetComponentInChildren``1(System.Boolean) has optimizations internally in engine
                    code which make it faster in different scenarios.
                </para>
            </remarks>
            <typeparam name="T">The target UnityEngine.Component type that is being looked for.</typeparam>
            <param name="targetMonoBehaviour">The target UnityEngine.MonoBehaviour to use as the base for the search.</param>
            <param name="lookInChildrenFirst">
                Should children UnityEngine.GameObject be searched before the
                targetMonoBehaviour's UnityEngine.GameObject.
            </param>
            <param name="includeInactive">
                Include inactive child UnityEngine.GameObjects when looking for the
                UnityEngine.Component.
            </param>
            <param name="maxLevelsOfRecursion">
                The maximum levels of recursion when looking for a UnityEngine.Component, -1 for
                infinite recursion.
            </param>
            <returns>The first found UnityEngine.Component.</returns>
        </member>
    </members>
</doc>
