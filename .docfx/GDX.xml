<?xml version="1.0"?>
<doc>
    <assembly>
        <name>GDX</name>
    </assembly>
    <members>
        <member name="T:GDX.Developer.SemanticVersion">
            <summary>
                A Semantic Versioning structure.
            </summary>
            <remarks>https://semver.org/</remarks>
        </member>
        <member name="F:GDX.Developer.SemanticVersion.k_VersionIndicators">
            <summary>
                An array of System.Char used to split versions.
            </summary>
        </member>
        <member name="F:GDX.Developer.SemanticVersion.Major">
            <summary>
                Major Version.
            </summary>
            <remarks>Is incremented when you make incompatible API changes.</remarks>
        </member>
        <member name="F:GDX.Developer.SemanticVersion.Minor">
            <summary>
                Minor Version.
            </summary>
            <remarks>Is incremented when you add functionality in a backwards-compatible manner.</remarks>
        </member>
        <member name="F:GDX.Developer.SemanticVersion.Patch">
            <summary>
                Patch Version
            </summary>
            <remarks>Is incremented when you make backwards-compatible fixes.</remarks>
        </member>
        <member name="M:GDX.Developer.SemanticVersion.#ctor(System.String)">
            <summary>
                Create a GDX.Developer.SemanticVersion based on a formatted System.String.
            </summary>
            <param name="version">A formatted version semantic version string (2020.1.0).</param>
        </member>
        <member name="M:GDX.Developer.SemanticVersion.op_GreaterThan(GDX.Developer.SemanticVersion,GDX.Developer.SemanticVersion)">
            <summary>
                Determine if GDX.Developer.SemanticVersion is greater than another GDX.Developer.SemanticVersion.
            </summary>
            <param name="lhs">Left-hand side GDX.Developer.SemanticVersion.</param>
            <param name="rhs">Right-hand side GDX.Developer.SemanticVersion.</param>
            <returns>Returns the result of a GREATER THAN operation on two GDX.Developer.SemanticVersion values.</returns>
        </member>
        <member name="M:GDX.Developer.SemanticVersion.op_GreaterThanOrEqual(GDX.Developer.SemanticVersion,GDX.Developer.SemanticVersion)">
            <summary>
                Determine if GDX.Developer.SemanticVersion is greater than or equal to another GDX.Developer.SemanticVersion.
            </summary>
            <param name="lhs">Left-hand side GDX.Developer.SemanticVersion.</param>
            <param name="rhs">Right-hand side GDX.Developer.SemanticVersion.</param>
            <returns>
                Returns the result of a GREATER THAN OR EQUAL operation on two GDX.Developer.SemanticVersion
                values.
            </returns>
        </member>
        <member name="M:GDX.Developer.SemanticVersion.op_LessThanOrEqual(GDX.Developer.SemanticVersion,GDX.Developer.SemanticVersion)">
            <summary>
                Determine if GDX.Developer.SemanticVersion is less than or equal to another GDX.Developer.SemanticVersion.
            </summary>
            <param name="lhs">Left-hand side GDX.Developer.SemanticVersion.</param>
            <param name="rhs">Right-hand side GDX.Developer.SemanticVersion.</param>
            <returns>
                Returns the result of a LESS THAN OR EQUAL operation on two GDX.Developer.SemanticVersion
                values.
            </returns>
        </member>
        <member name="M:GDX.Developer.SemanticVersion.op_LessThan(GDX.Developer.SemanticVersion,GDX.Developer.SemanticVersion)">
            <summary>
                Determine if GDX.Developer.SemanticVersion is less than another GDX.Developer.SemanticVersion.
            </summary>
            <param name="lhs">Left-hand side GDX.Developer.SemanticVersion.</param>
            <param name="rhs">Right-hand side GDX.Developer.SemanticVersion.</param>
            <returns>Returns the result of a LESS THAN operation on two GDX.Developer.SemanticVersion values.</returns>
        </member>
        <member name="M:GDX.Developer.SemanticVersion.op_Equality(GDX.Developer.SemanticVersion,GDX.Developer.SemanticVersion)">
            <summary>
                Determine if GDX.Developer.SemanticVersion is equal to another GDX.Developer.SemanticVersion.
            </summary>
            <param name="lhs">Left-hand side GDX.Developer.SemanticVersion.</param>
            <param name="rhs">Right-hand side GDX.Developer.SemanticVersion.</param>
            <returns>Returns the result of a EQUALITY operation on two GDX.Developer.SemanticVersion values.</returns>
        </member>
        <member name="M:GDX.Developer.SemanticVersion.op_Inequality(GDX.Developer.SemanticVersion,GDX.Developer.SemanticVersion)">
            <summary>
                Determine if GDX.Developer.SemanticVersion does not equal than another GDX.Developer.SemanticVersion.
            </summary>
            <param name="lhs">Left-hand side GDX.Developer.SemanticVersion.</param>
            <param name="rhs">Right-hand side GDX.Developer.SemanticVersion.</param>
            <returns>Returns the result of a NOT EQUAL operation on two GDX.Developer.SemanticVersion values.</returns>
        </member>
        <member name="M:GDX.Developer.SemanticVersion.Equals(System.Object)">
            <summary>
                Does the obj equal this GDX.Developer.SemanticVersion.
            </summary>
            <param name="obj">An System.Object to compare against.</param>
            <returns>Returns the result of an EQUALITY operation.</returns>
        </member>
        <member name="M:GDX.Developer.SemanticVersion.GetHashCode">
            <summary>
                Get the hash code of the GDX.Developer.SemanticVersion.
            </summary>
            <returns>A System.Int32 value.</returns>
        </member>
        <member name="M:GDX.Developer.SemanticVersion.Equals(GDX.Developer.SemanticVersion)">
            <summary>
                Does the otherSemanticVersion equal the GDX.Developer.SemanticVersion.
            </summary>
            <param name="otherSemanticVersion"></param>
            <returns>
                The results of checking the GDX.Developer.SemanticVersion.Major/GDX.Developer.SemanticVersion.Minor/
                GDX.Developer.SemanticVersion.Patch for equality.
            </returns>
        </member>
        <member name="T:GDX.Developer.Conditionals">
            <summary>
                Constant indicators about conditional supports within the GDX package. Helpful indicators of which features are
                available through preprocessor gating.
            </summary>
        </member>
        <member name="F:GDX.Developer.Conditionals.HasAddressablesPackage">
            <summary>
                Is a compatible version of the Addressables package present in the project?
            </summary>
        </member>
        <member name="F:GDX.Developer.Conditionals.HasPlatformsPackage">
            <summary>
                Is a compatible version of the Platforms package present in the project?
            </summary>
        </member>
        <member name="F:GDX.Developer.Conditionals.HasVisualScriptingPackage">
            <summary>
                Is a compatible version of the Visual Scripting package present in the project?
            </summary>
        </member>
        <member name="T:GDX.Developer.Reports.Resource.ResourceReportContext">
            <summary>
                Context for generating a GDX.Developer.Reports.Resource.ResourceReport based report.
            </summary>
            <exception cref="T:GDX.UnsupportedRuntimeException">Not supported on DOTS Runtime.</exception>
        </member>
        <member name="T:GDX.Developer.Reports.Resource.Objects.AssetBundleObjectInfo">
            <exception cref="T:GDX.UnsupportedRuntimeException">Not supported on DOTS Runtime.</exception>
        </member>
        <member name="M:GDX.Developer.Reports.Resource.Objects.AssetBundleObjectInfo.Clone">
            <summary>
            Create a clone of this object.
            </summary>
            <returns></returns>
        </member>
        <member name="T:GDX.Developer.Reports.Resource.Objects.ShaderObjectInfo">
            <exception cref="T:GDX.UnsupportedRuntimeException">Not supported on DOTS Runtime.</exception>
        </member>
        <member name="M:GDX.Developer.Reports.Resource.Objects.ShaderObjectInfo.Clone">
            <summary>
            Create a clone of this object.
            </summary>
            <returns></returns>
        </member>
        <member name="M:GDX.Developer.Reports.Resource.Objects.ShaderObjectInfo.GetDetailedInformation(System.Int32)">
            <inheritdoc />
        </member>
        <member name="T:GDX.Developer.Reports.Resource.Objects.ObjectInfo">
            <summary>
                An information storage object for a target System.Object.
            </summary>
            <exception cref="T:GDX.UnsupportedRuntimeException">Not supported on DOTS Runtime.</exception>
        </member>
        <member name="F:GDX.Developer.Reports.Resource.Objects.ObjectInfo.TypeDefinition">
            <summary>
                The fully qualified reflection definition of the GDX.Developer.Reports.Resource.Objects.ObjectInfo.
            </summary>
        </member>
        <member name="F:GDX.Developer.Reports.Resource.Objects.ObjectInfo.CopyCount">
            <summary>
                The number of copies of the GDX.Developer.Reports.Resource.Objects.ObjectInfo.Reference object known by Unity.
            </summary>
        </member>
        <member name="F:GDX.Developer.Reports.Resource.Objects.ObjectInfo.MemoryUsage">
            <summary>
                The memory usage of the actual GDX.Developer.Reports.Resource.Objects.ObjectInfo.Reference object (in bytes).
            </summary>
        </member>
        <member name="F:GDX.Developer.Reports.Resource.Objects.ObjectInfo.Name">
            <summary>
                The name of the GDX.Developer.Reports.Resource.Objects.ObjectInfo.Reference object.
            </summary>
        </member>
        <member name="F:GDX.Developer.Reports.Resource.Objects.ObjectInfo.Reference">
            <summary>
                A GDX.Developer.TransientReference to the target object.
            </summary>
        </member>
        <member name="F:GDX.Developer.Reports.Resource.Objects.ObjectInfo.TotalMemoryUsage">
            <summary>
                The total memory usage of the GDX.Developer.Reports.Resource.Objects.ObjectInfo.Reference object (in bytes).
            </summary>
        </member>
        <member name="F:GDX.Developer.Reports.Resource.Objects.ObjectInfo.Type">
            <summary>
                The cached GDX.Developer.Reports.Resource.Objects.ObjectInfo.Type of the GDX.Developer.Reports.Resource.Objects.ObjectInfo.Reference object.
            </summary>
        </member>
        <member name="M:GDX.Developer.Reports.Resource.Objects.ObjectInfo.Clone">
            <summary>
            Create a clone of this object.
            </summary>
            <returns></returns>
        </member>
        <member name="M:GDX.Developer.Reports.Resource.Objects.ObjectInfo.GetDetailedInformation(System.Int32)">
            <summary>
                Get additional information about the specific GDX.Developer.Reports.Resource.Objects.ObjectInfo.Reference.
            </summary>
            <returns>A System.String of additional information.</returns>
        </member>
        <member name="M:GDX.Developer.Reports.Resource.Objects.ObjectInfo.Populate(UnityEngine.Object,GDX.Developer.TransientReference)">
            <summary>
                Populate an GDX.Developer.Reports.Resource.Objects.ObjectInfo from the targetObject. Optionally providing an existing
                reference created prior.
            </summary>
            <param name="targetObject">The System.Object which to cache information about.</param>
            <param name="reference">An existing GDX.Developer.TransientReference targeting the targetObject.</param>
        </member>
        <member name="M:GDX.Developer.Reports.Resource.Objects.ObjectInfo.CompareTo(System.Object)">
            <summary>
            Evaluate if the compared GDX.Developer.Reports.Resource.Objects.ObjectInfo utilizes more memory then this one.
            </summary>
            <param name="obj">The GDX.Developer.Reports.Resource.Objects.ObjectInfo to compare against.</param>
            <returns>1 if larger, otherwise 0.</returns>
        </member>
        <member name="T:GDX.Developer.Reports.Resource.Objects.ObjectInfoFactory">
            <exception cref="T:GDX.UnsupportedRuntimeException">Not supported on DOTS Runtime.</exception>
        </member>
        <member name="T:GDX.Developer.Reports.Resource.Objects.TextureObjectInfo">
            <exception cref="T:GDX.UnsupportedRuntimeException">Not supported on DOTS Runtime.</exception>
        </member>
        <member name="M:GDX.Developer.Reports.Resource.Objects.TextureObjectInfo.Clone">
            <summary>
            Create a clone of this object.
            </summary>
            <returns></returns>
        </member>
        <member name="T:GDX.Developer.Reports.Resource.Objects.MeshObjectInfo">
            <exception cref="T:GDX.UnsupportedRuntimeException">Not supported on DOTS Runtime.</exception>
        </member>
        <member name="M:GDX.Developer.Reports.Resource.Objects.MeshObjectInfo.Clone">
            <summary>
            Create a clone of this object.
            </summary>
            <returns></returns>
        </member>
        <member name="T:GDX.Developer.Reports.Resource.Sections.ApplicationSection">
            <exception cref="T:GDX.UnsupportedRuntimeException">Not supported on DOTS Runtime.</exception>
        </member>
        <member name="F:GDX.Developer.Reports.Resource.Sections.ApplicationSection.ActiveScene">
            <summary>
                The name of the scene that was known to the N:UnityEngine.SceneManagement as being the active scene
                when this GDX.Developer.Reports.Resource.Sections.ApplicationSection was created.
            </summary>
        </member>
        <member name="F:GDX.Developer.Reports.Resource.Sections.ApplicationSection.Created">
            <summary>
                The time of creation for the GDX.Developer.Reports.Resource.Sections.ApplicationSection.
            </summary>
        </member>
        <member name="F:GDX.Developer.Reports.Resource.Sections.ApplicationSection.Platform">
            <summary>
                The platform that the GDX.Developer.Reports.Resource.Sections.ApplicationSection was created on.
            </summary>
        </member>
        <member name="T:GDX.Developer.Reports.Resource.Sections.MemorySection">
            <exception cref="T:GDX.UnsupportedRuntimeException">Not supported on DOTS Runtime.</exception>
        </member>
        <member name="F:GDX.Developer.Reports.Resource.Sections.MemorySection.MonoHeapSize">
            <summary>
                The size of the Mono heap when the GDX.Developer.Reports.ResourcesAuditReport was created.
            </summary>
            <remarks>This is cached so that the GDX.Developer.Reports.ResourcesAuditReport does not effect this value.</remarks>
        </member>
        <member name="F:GDX.Developer.Reports.Resource.Sections.MemorySection.MonoUsedSize">
            <summary>
                The amount of the Mono heap used when the GDX.Developer.Reports.ResourcesAuditReport was created.
            </summary>
            <remarks>This is cached so that the GDX.Developer.Reports.ResourcesAuditReport does not effect this value.</remarks>
        </member>
        <member name="F:GDX.Developer.Reports.Resource.Sections.MemorySection.UnityGraphicsDriverAllocatedMemory">
            <summary>
                Unity's allocated native memory for the graphics driver (in bytes).
            </summary>
        </member>
        <member name="F:GDX.Developer.Reports.Resource.Sections.MemorySection.UnityTotalAllocatedMemory">
            <summary>
                Unity's total allocated memory (in bytes).
            </summary>
        </member>
        <member name="F:GDX.Developer.Reports.Resource.Sections.MemorySection.UnityTotalReservedMemory">
            <summary>
                Unity's total reserved memory (in bytes).
            </summary>
        </member>
        <member name="F:GDX.Developer.Reports.Resource.Sections.MemorySection.UnityTotalUnusedReservedMemory">
            <summary>
                Unity's total unused reserved memory (in bytes).
            </summary>
        </member>
        <member name="T:GDX.Developer.Reports.Resource.Sections.MemoryDiffSection">
            <exception cref="T:GDX.UnsupportedRuntimeException">Not supported on DOTS Runtime.</exception>
        </member>
        <member name="T:GDX.Developer.Reports.Resource.ResourceReport">
            <exception cref="T:GDX.UnsupportedRuntimeException">Not supported on DOTS Runtime.</exception>
        </member>
        <member name="F:GDX.Developer.Reports.Resource.ResourceReport.k_NewLineSplit">
            <summary>
                A System.String array used to represent the end of a line for splitting purposes.
            </summary>
        </member>
        <member name="M:GDX.Developer.Reports.Resource.ResourceReport.Output(GDX.Developer.Reports.Resource.ResourceReportContext)">
            <summary>
                Output the report format as an array of System.String.
            </summary>
            <remarks>It is usually best to provide a System.Text.StringBuilder or System.IO.StreamWriter instead.</remarks>
            <param name="context"></param>
            <returns>A generated report as an array of System.String.</returns>
        </member>
        <member name="M:GDX.Developer.Reports.Resource.ResourceReport.Output(System.IO.StreamWriter,System.Int32,GDX.Developer.Reports.Resource.ResourceReportContext)">
            <summary>
                Output the report format utilizing the provided writer, optionally limiting the
                write buffers by bufferSize.
            </summary>
            <param name="context">Contextual information regarding the generation of the report.</param>
            <param name="writer">A System.IO.StreamWriter instance to use for output.</param>
            <param name="bufferSize">The write buffer size.</param>
            <returns>true/false if the report was successfully written to the provided writer.</returns>
        </member>
        <member name="M:GDX.Developer.Reports.Resource.ResourceReport.Output(System.Text.StringBuilder,GDX.Developer.Reports.Resource.ResourceReportContext)">
            <summary>
                Output the report format utilizing the provided builder.
            </summary>
            <param name="builder">A System.Text.StringBuilder to use when generating the report.</param>
            <param name="context">Contextual information regarding the generation of the report.</param>
            <returns>true/false if report was added to builder.</returns>
        </member>
        <member name="M:GDX.Developer.Reports.Resource.ResourceReport.CreateDivider(GDX.Developer.Reports.Resource.ResourceReportContext,System.Char)">
            <summary>
                Create a sized divider string for use in generating reports.
            </summary>
            <param name="context">Contextual information regarding the generation of the report.</param>
            <param name="divider">The optional character to use as the divider.</param>
            <returns>A sized string to be used as a divider.</returns>
        </member>
        <member name="M:GDX.Developer.Reports.Resource.ResourceReport.CreateHeader(GDX.Developer.Reports.Resource.ResourceReportContext,System.String,System.Char)">
            <summary>
                Create a header with title with repeated decorators on the sides, filling
                out to GDX.Developer.Reports.Resource.ResourceReportContext.CharacterWidth.
            </summary>
            <param name="context">Contextual information regarding the generation of the report.</param>
            <param name="title">The text to be treated as the title for the header.</param>
            <param name="decorator">The optional character to be used as the decorator.</param>
            <returns>A sized string to be used as a header.</returns>
        </member>
        <member name="T:GDX.Developer.Reports.BuildVerification.ITestBehaviour">
            <summary>
                A build verification test behaviour interface.
            </summary>
        </member>
        <member name="M:GDX.Developer.Reports.BuildVerification.ITestBehaviour.GetIdentifier">
            <summary>
                Get some semblance of identifiable information for a test.
            </summary>
            <returns>
                The System.String identifier for the test.
            </returns>
        </member>
        <member name="M:GDX.Developer.Reports.BuildVerification.ITestBehaviour.Setup">
            <summary>
                Setup for the test.
            </summary>
        </member>
        <member name="M:GDX.Developer.Reports.BuildVerification.ITestBehaviour.TearDown">
            <summary>
                Tear down after the test.
            </summary>
        </member>
        <member name="M:GDX.Developer.Reports.BuildVerification.SimpleTestBehaviour.Setup">
            <inheritdoc />
        </member>
        <member name="M:GDX.Developer.Reports.BuildVerification.SimpleTestBehaviour.TearDown">
            <inheritdoc />
        </member>
        <member name="M:GDX.Developer.Reports.BuildVerification.SimpleTestBehaviour.Start">
            <summary>
                Unity's Start event.
            </summary>
        </member>
        <member name="M:GDX.Developer.Reports.NUnitReport.ToString">
            <summary>
                Builds and returns the NUnit formatted report.
            </summary>
            <remarks>Can result in a UTF-16 based XML document.</remarks>
        </member>
        <member name="T:GDX.Developer.Reports.ResourcesAuditReport">
            <summary>
                An audit of loaded UnityEngine.Object for queried types.
            </summary>
            <remarks>
                Information is referenced to the target objects by a modified weak reference (GDX.Developer.TransientReference),
                thus this will not prevent garbage collection.
            </remarks>
            <exception cref="T:GDX.UnsupportedRuntimeException">Not supported on DOTS Runtime.</exception>
        </member>
        <member name="F:GDX.Developer.Reports.ResourcesAuditReport.KnownObjects">
            <summary>
                A collection of known (loaded in memory) UnityEngine.Object keyed by type.
            </summary>
        </member>
        <member name="F:GDX.Developer.Reports.ResourcesAuditReport.KnownUsage">
            <summary>
                A collection of known UnityEngine.Object types in memory and their total usage.
            </summary>
        </member>
        <member name="F:GDX.Developer.Reports.ResourcesAuditReport.LastTouched">
            <summary>
                The last time that the GDX.Developer.Reports.ResourcesAuditReport has had a query of types.
            </summary>
        </member>
        <member name="F:GDX.Developer.Reports.ResourcesAuditReport.ObjectCount">
            <summary>
                The total number of objects which are known to the GDX.Developer.Reports.ResourcesAuditReport.
            </summary>
        </member>
        <member name="M:GDX.Developer.Reports.ResourcesAuditReport.Finalize">
            <summary>
                Process to destroy a GDX.Developer.Reports.ResourcesAuditReport.
            </summary>
        </member>
        <member name="M:GDX.Developer.Reports.ResourcesAuditReport.Output(System.Text.StringBuilder,GDX.Developer.Reports.Resource.ResourceReportContext)">
            <inheritdoc />
        </member>
        <member name="M:GDX.Developer.Reports.ResourcesAuditReport.Query(GDX.Developer.Reports.ResourcesAuditReport.ResourcesQuery)">
            <summary>
                Identify loaded UnityEngine.Object of the description provided in <paramref cref="!:query" />.
            </summary>
            <remarks>
                This method of querying uses reflection to allow for dynamic developer console calls,
                GDX.Developer.Reports.ResourcesAuditReport.QueryForType``2(System.String) for a much faster typed operation.
            </remarks>
            <param name="query">Description of UnityEngine.Object type to search for.</param>
        </member>
        <member name="M:GDX.Developer.Reports.ResourcesAuditReport.QueryForType``2(System.String)">
            <summary>
                Identify loaded <typeparamref name="TType" />, using <typeparamref name="TObjectInfo" /> for report generation.
            </summary>
            <typeparam name="TType">The object type to query for.</typeparam>
            <typeparam name="TObjectInfo">The GDX.Developer.Reports.Resource.Objects.ObjectInfo used to generate report entries.</typeparam>
        </member>
        <member name="M:GDX.Developer.Reports.ResourcesAuditReport.Remove(System.Type)">
            <summary>
                Remove all information regarding a specific type from the GDX.Developer.Reports.ResourcesAuditReport.KnownObjects.
            </summary>
            <param name="type">The type to remove from the GDX.Developer.Reports.ResourcesAuditReport.KnownObjects.</param>
        </member>
        <member name="M:GDX.Developer.Reports.ResourcesAuditReport.Get(GDX.Developer.Reports.ResourcesAuditReport.ResourcesQuery[])">
            <summary>
                Generate a GDX.Developer.Reports.ResourcesAuditReport for the provided GDX.Developer.Reports.ResourcesAuditReport.ResourcesQuery array.
            </summary>
            <remarks>
                This method uses reflection to generate the necessary typed parameters, its often more efficient to
                create your own custom reports like in GDX.Developer.Reports.ResourcesAuditReport.GetCommon.
            </remarks>
            <param name="queries">A list of GDX.Developer.Reports.ResourcesAuditReport.ResourcesQuery to generate a report from.</param>
            <returns>A GDX.Developer.Reports.ResourcesAuditReport containing the outlined types.</returns>
        </member>
        <member name="M:GDX.Developer.Reports.ResourcesAuditReport.GetAll">
            <summary>
                Get a GDX.Developer.Reports.ResourcesAuditReport of all UnityEngine.Object.
            </summary>
            <returns>A GDX.Developer.Reports.ResourcesAuditReport of all objects.</returns>
        </member>
        <member name="M:GDX.Developer.Reports.ResourcesAuditReport.GetCommon">
            <summary>
                Get a GDX.Developer.Reports.ResourcesAuditReport of a common subset of data which usually eats a large portion of
                memory, and often can reveal memory leaks.
            </summary>
            <returns>A GDX.Developer.Reports.ResourcesAuditReport of textures, shaders, materials and animations.</returns>
        </member>
        <member name="T:GDX.Developer.Reports.ResourcesAuditReport.ResourcesQuery">
            <summary>
                A structure that defines the string inputs necessary to query for loaded resources of a specific type.
            </summary>
            <remarks>
                This forces the path through reflection when querying; there are faster methods available. These queries are
                built ideally to support dynamic developer console calls.
            </remarks>
        </member>
        <member name="F:GDX.Developer.Reports.ResourcesAuditReport.ResourcesQuery.TypeDefinition">
            <summary>
                The fully qualified type that is going to be evaluated.
            </summary>
            <example>
                UnityEngine.Texture2D,UnityEngine
            </example>
        </member>
        <member name="F:GDX.Developer.Reports.ResourcesAuditReport.ResourcesQuery.ObjectInfoTypeDefinition">
            <summary>
                The fully qualified type that is going to be used to generate a report on the type.
            </summary>
            <example>
                GDX.Developer.Reports.ObjectInfo,GDX
            </example>
        </member>
        <member name="F:GDX.Developer.Reports.ResourcesAuditReport.ResourcesQuery.NameFilter">
            <summary>
                A System.String check against a UnityEngine.Object name.
            </summary>
            <example>
                Armor
            </example>
        </member>
        <member name="M:GDX.Developer.Reports.ResourcesAuditReport.ResourcesQuery.#ctor(System.String,System.String,System.String)">
            <summary>
                Create a GDX.Developer.Reports.ResourcesAuditReport.ResourcesQuery for the given typeDefinition, while
                attempting to use the provided objectInfoTypeDefinition for report generation.
            </summary>
            <remarks>
                Uses the default GDX.Developer.Reports.Resource.Objects.ObjectInfo for report generation if
                objectInfoTypeDefinition fails to qualify.
            </remarks>
            <param name="typeDefinition">The fully qualified type that is going to be evaluated.</param>
            <param name="objectInfoTypeDefinition">
                The fully qualified type that is going to be used to generate a report on the
                type. If left null, system will attempt to find an appropriate info generator.
            </param>
            <param name="nameFilter">
                A string that must be contained in an objects name for it to be valid in the query.
            </param>
            <example>
                var queryTexture2D = new ResourcesQuery("UnityEngine.Texture2D,UnityEngine",
                "GDX.Developer.Reports.ObjectInfos.TextureObjectInfo,GDX", "Armor");
            </example>
        </member>
        <member name="T:GDX.Developer.Reports.ResourcesDiffReport">
            <exception cref="T:GDX.UnsupportedRuntimeException">Not supported on DOTS Runtime.</exception>
        </member>
        <member name="M:GDX.Developer.Reports.ResourcesDiffReport.Output(System.Text.StringBuilder,GDX.Developer.Reports.Resource.ResourceReportContext)">
            <inheritdoc />
        </member>
        <member name="T:GDX.Developer.TextGenerator">
            <summary>
                A formatted text generator useful for creating text based files with some semblance of organization.
            </summary>
        </member>
        <member name="F:GDX.Developer.TextGenerator.m_Builder">
            <summary>
                The actual buffer holder used to create the dynamic string.
            </summary>
        </member>
        <member name="F:GDX.Developer.TextGenerator.m_IndentContent">
            <summary>
                The assigned indent content used to indent lines where applicable.
            </summary>
        </member>
        <member name="F:GDX.Developer.TextGenerator.m_IndentClose">
            <summary>
                The content used to indicate the closing of a section that was indented.
            </summary>
        </member>
        <member name="F:GDX.Developer.TextGenerator.m_IndentOpen">
            <summary>
                The content used to indicate the opening of a section which should be indented.
            </summary>
        </member>
        <member name="F:GDX.Developer.TextGenerator.m_IndentLevel">
            <summary>
                The current level of indentation.
            </summary>
        </member>
        <member name="M:GDX.Developer.TextGenerator.#ctor(System.String,System.String,System.String)">
            <summary>
                Create a new GDX.Developer.TextGenerator with the
            </summary>
            <param name="indentContent">
                The characters used to indent the content when applicable. By default it will use a tab representation,
                however for code files you may want to use four spaces.
            </param>
            <param name="indentOpen"></param>
            <param name="indentClose"></param>
        </member>
        <member name="M:GDX.Developer.TextGenerator.ApplyIndent">
            <summary>
                Apply the current level of indent to the current line being operated on.
            </summary>
        </member>
        <member name="M:GDX.Developer.TextGenerator.Append(System.String)">
            <summary>
                Append content to the current line being operated on.
            </summary>
            <param name="content">The content to append to the current line.</param>
        </member>
        <member name="M:GDX.Developer.TextGenerator.AppendLine(System.String)">
            <summary>
                Apply the appropriate amount of indentation to the current line, appending content afterwards and then
                advancing to the next line.
            </summary>
            <param name="content">The content to append to the current line.</param>
        </member>
        <member name="M:GDX.Developer.TextGenerator.AppendLineRange(System.Collections.IEnumerable)">
            <summary>
                Append an System.Collections.IEnumerable set of content as individual lines with proper indentation.
            </summary>
            <param name="content">The content to be added.</param>
        </member>
        <member name="M:GDX.Developer.TextGenerator.GetIndentLevel">
            <summary>
                Gets the current indent level of the GDX.Developer.TextGenerator.
            </summary>
            <returns>The indent level.</returns>
        </member>
        <member name="M:GDX.Developer.TextGenerator.NextLine">
            <summary>
                Move the builder to the start of the next line.
            </summary>
        </member>
        <member name="M:GDX.Developer.TextGenerator.PopIndent">
            <summary>
                Remove a level of indentation from the builder.
            </summary>
        </member>
        <member name="M:GDX.Developer.TextGenerator.PushIndent(System.Boolean)">
            <summary>
                Add a level of indentation to the builder.
            </summary>
            <param name="applyOpener">Should the opener be applied?</param>
        </member>
        <member name="M:GDX.Developer.TextGenerator.ToString">
            <summary>
                Returns the built string content for the builder.
            </summary>
            <remarks>Will automatically reduce the indentation level to 0.</remarks>
        </member>
        <member name="T:GDX.Developer.DebugDrawBuffer">
            <summary>
            An optimized method for drawing static procedural content.
            </summary>
            <remarks>
                This still suffers from multiple SetPass calls associated with the UnityEngine.Rendering.CommandBuffer.
                It should be possible in the future to using GraphicsBuffers/BatchRenderGroup once that API stabilizes.
            </remarks>
        </member>
        <member name="F:GDX.Developer.DebugDrawBuffer.DefaultMaximumVerticesPerMesh">
            <summary>
                The default maximum number of vertices per meshReference when dynamically creating meshes.
            </summary>
        </member>
        <member name="F:GDX.Developer.DebugDrawBuffer.CubeSegmentIndices">
            <summary>
                The ordered segment index pairs used to describe a cube.
            </summary>
            <remarks>
                This effectively wraps the left side, then the right, then connects the two sides.
            </remarks>
        </member>
        <member name="F:GDX.Developer.DebugDrawBuffer.s_DottedLineMaterial">
            <summary>
                The base instance of the default dotted line material.
            </summary>
            <remarks>
                This will be cloned when a new color value is provided and not found by
                GDX.Developer.DebugDrawBuffer.GetDottedLineMaterialByColor(UnityEngine.Color).
            </remarks>
        </member>
        <member name="F:GDX.Developer.DebugDrawBuffer.s_LineMaterial">
            <summary>
                The base instance of the default line material.
            </summary>
            <remarks>
                This will be cloned when a new color value is provided and not found by
                GDX.Developer.DebugDrawBuffer.GetSolidLineMaterialByColor(UnityEngine.Color).
            </remarks>
        </member>
        <member name="F:GDX.Developer.DebugDrawBuffer.s_LineSegmentIndices">
            <summary>
                The ordered segment index pairs used to describe a line.
            </summary>
        </member>
        <member name="F:GDX.Developer.DebugDrawBuffer.Key">
            <summary>
            The associated System.Int32 key with the GDX.Developer.DebugDrawBuffer.
            </summary>
            <remarks>
                <para>
                    This is useful for identifying the GDX.Developer.DebugDrawBuffer in different contexts; its
                    specific use is meant for being able to recall a GDX.Developer.DebugDrawBuffer from the
                    GDX.Developer.DebugDraw.
                </para>
                <para>
                    A common pattern is to use the the UnityEngine.GameObject's InstanceID or an Entity Number to
                    create a unique indexer. Collisions can occur if you are not careful about how you index your
                    GDX.Developer.DebugDrawBuffer.
                </para>
            </remarks>
        </member>
        <member name="F:GDX.Developer.DebugDrawBuffer.m_CommandBuffer">
            <summary>
                The actual allocated UnityEngine.Rendering.CommandBuffer used by the GDX.Developer.DebugDrawBuffer.
            </summary>
        </member>
        <member name="F:GDX.Developer.DebugDrawBuffer.m_MaximumVerticesPerMesh">
            <summary>
                The established maximum number of vertices per meshReference for this particular GDX.Developer.DebugDrawBuffer.
            </summary>
            <remarks>
                Once this is set in the constructor it cannot be changed. Arbitrary meshReference adds are not effected by this
            </remarks>
        </member>
        <member name="F:GDX.Developer.DebugDrawBuffer.m_CurrentToken">
            <summary>
                The current incremental token used when associating draw commands.
            </summary>
            <remarks>
                This is used to provide a stable index in an extremely simple form. While it will eventually roll over,
                at that threshold you should be considering if multiple GDX.Developer.DebugDrawBuffer may be more
                optimal.
            </remarks>
        </member>
        <member name="F:GDX.Developer.DebugDrawBuffer.m_DottedLineMaterials">
            <summary>
                An indexed dictionary of all dotted line materials, referenced by the hashcode of the color.
            </summary>
        </member>
        <member name="F:GDX.Developer.DebugDrawBuffer.m_DrawCommands">
            <summary>
                An indexed dictionary of all of the draw commands to use with the buffer.
            </summary>
            <remarks>
                This includes the meshReference and an index of the material to use with that meshReference when drawing. As items are
                added, the GDX.Developer.DebugDrawBuffer.m_CurrentToken is incremented to simulate a stable ID.
            </remarks>
        </member>
        <member name="F:GDX.Developer.DebugDrawBuffer.m_LineMaterials">
            <summary>
                An indexed dictionary of all line materials, referenced by the hashcode of the color.
            </summary>
        </member>
        <member name="F:GDX.Developer.DebugDrawBuffer.m_Materials">
            <summary>
                An ever expanding list of materials used with the GDX.Developer.DebugDrawBuffer.
            </summary>
            <remarks>
                Both GDX.Developer.DebugDrawBuffer.m_DottedLineMaterials and GDX.Developer.DebugDrawBuffer.m_LineMaterials store indexes of
                UnityEngine.Materials inside of this list.
            </remarks>
        </member>
        <member name="F:GDX.Developer.DebugDrawBuffer.m_WorkingPoints">
            <summary>
                A storage of working vertices information indexed based on the hashcode of the material it is meant to
                be drawn with.
            </summary>
        </member>
        <member name="F:GDX.Developer.DebugDrawBuffer.m_WorkingSegments">
            <summary>
                A storage of working segment indices pairs indexed based on the hashcode of the material it is meant to
                be drawn with.
            </summary>
        </member>
        <member name="F:GDX.Developer.DebugDrawBuffer.m_WorkingTokens">
            <summary>
                A storage of working expected tokens of meshes to be created in the future.
            </summary>
        </member>
        <member name="M:GDX.Developer.DebugDrawBuffer.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
                Create a GDX.Developer.DebugDrawBuffer.
            </summary>
            <param name="key">The internally cached key associated with this buffer.</param>
            <param name="initialMaterialCount">
                An initial allocation of the expected number of materials that will be used.
            </param>
            <param name="verticesPerMesh">The number of vertices to ingest before a meshReference is split.</param>
        </member>
        <member name="P:GDX.Developer.DebugDrawBuffer.Finalized">
            <summary>
                Has the GDX.Developer.DebugDrawBuffer been converged?
            </summary>
            <remarks>
                A finalized GDX.Developer.DebugDrawBuffer has had its command buffer filled with the fixed draw calls
                based on the meshes/materials outlined. If a meshReference is invalidated by GDX.Developer.DebugDrawBuffer.Invalidate(System.Int32), the
                GDX.Developer.DebugDrawBuffer will become not finalized and will re-converge itself next
                GDX.Developer.DebugDrawBuffer.Execute.
            </remarks>
        </member>
        <member name="M:GDX.Developer.DebugDrawBuffer.Converge">
            <summary>
                Converges all working vertices/material additions into finalized meshReference forms and fills the command
                buffer with the appropriate data.
            </summary>
        </member>
        <member name="M:GDX.Developer.DebugDrawBuffer.DrawDottedCube(UnityEngine.Color,UnityEngine.Vector3,UnityEngine.Vector3)">
            <summary>
                Draw a dotted line cube of a specific color to the buffer.
            </summary>
            <param name="color">The color which to draw the dotted line cube with.</param>
            <param name="center">The center world position of the cube.</param>
            <param name="size">The unit size of the cube</param>
            <returns>The created cube's invalidation token.</returns>
        </member>
        <member name="M:GDX.Developer.DebugDrawBuffer.DrawDottedLine(UnityEngine.Color,UnityEngine.Vector3,UnityEngine.Vector3)">
            <summary>
                Draw a dotted line of a specific color as defined to the buffer.
            </summary>
            <remarks>
                If multiple lines are being drawn it is much more performant to use
                GDX.Developer.DebugDrawBuffer.DrawDottedLines(UnityEngine.Color,UnityEngine.Vector3[]@,System.Int32[]@).
            </remarks>
            <param name="color">The color which to draw the dotted line with.</param>
            <param name="startPoint">The start of the line in world space.</param>
            <param name="endPoint">The end of the line in world space.</param>
            <returns>The dotted line's invalidation token.</returns>
        </member>
        <member name="M:GDX.Developer.DebugDrawBuffer.DrawDottedLines(UnityEngine.Color,UnityEngine.Vector3[]@,System.Int32[]@)">
            <summary>
                Draw dotted lines of a specific color as defined to the buffer.
            </summary>
            <param name="color">The color which to draw the dotted lines with.</param>
            <param name="vertices">The vertices of the dotted lines.</param>
            <param name="segments">The segment pairs based on vertices.</param>
            <returns>The dotted lines' invalidation token.</returns>
        </member>
        <member name="M:GDX.Developer.DebugDrawBuffer.DrawDottedLines(UnityEngine.Color,UnityEngine.Vector3[]@,System.Int32,System.Int32,System.Int32[]@,System.Int32,System.Int32)">
            <summary>
                Draw dotted lines of a specific color as defined to the buffer.
            </summary>
            <param name="color">The color which to draw the dotted lines with.</param>
            <param name="vertices">The vertices of the dotted lines.</param>
            <param name="verticesStartIndex">The index to start at in the vertices array.</param>
            <param name="verticesLength">The number of elements in the vertices array to use.</param>
            <param name="segments">The segment pairs based on vertices.</param>
            <param name="segmentsStartIndex">The index to start at in the segments array.</param>
            <param name="segmentsLength">The number of elements in the segments array to use.</param>
            <returns>The dotted lines' invalidation token.</returns>
        </member>
        <member name="M:GDX.Developer.DebugDrawBuffer.DrawLine(UnityEngine.Color,UnityEngine.Vector3,UnityEngine.Vector3)">
            <summary>
                Draw a line of a specific color as defined to the buffer.
            </summary>
            <remarks>
                If multiple lines are being drawn it is much more performant to use
                GDX.Developer.DebugDrawBuffer.DrawLines(UnityEngine.Color,UnityEngine.Vector3[]@,System.Int32[]@).
            </remarks>
            <param name="color">The color which to draw the line with.</param>
            <param name="startPoint">The start of the line in world space.</param>
            <param name="endPoint">The end of the line in world space.</param>
            <returns>The line's invalidation token.</returns>
        </member>
        <member name="M:GDX.Developer.DebugDrawBuffer.DrawLines(UnityEngine.Color,UnityEngine.Vector3[]@,System.Int32[]@)">
            <summary>
                Draw lines of a specific color as defined to the buffer.
            </summary>
            <param name="color">The color which to draw the lines with.</param>
            <param name="vertices">The vertices of the lines.</param>
            <param name="segments">The segment pairs based on vertices.</param>
            <returns>The lines' invalidation token.</returns>
        </member>
        <member name="M:GDX.Developer.DebugDrawBuffer.DrawLines(UnityEngine.Color,UnityEngine.Vector3[]@,System.Int32,System.Int32,System.Int32[]@,System.Int32,System.Int32)">
            <summary>
                Draw lines of a specific color as defined to the buffer.
            </summary>
            <param name="color">The color which to draw the lines with.</param>
            <param name="vertices">The vertices of the lines.</param>
            <param name="verticesStartIndex">The index to start at in the vertices array.</param>
            <param name="verticesLength">The number of elements in the vertices array to use.</param>
            <param name="segments">The segment pairs based on vertices.</param>
            <param name="segmentsStartIndex">The index to start at in the segments array.</param>
            <param name="segmentsLength">The number of elements in the segments array to use.</param>
            <returns>The lines' invalidation token.</returns>
        </member>
        <member name="M:GDX.Developer.DebugDrawBuffer.DrawLines(UnityEngine.Material,UnityEngine.Vector3[]@,System.Int32,System.Int32,System.Int32[]@,System.Int32,System.Int32)">
            <summary>
                Draw lines with a specific material to the buffer.
            </summary>
            <param name="material">A <em>potentially</em> unlit material to draw the lines with. This will only be drawin</param>
            <param name="vertices">The vertices of the lines.</param>
            <param name="verticesStartIndex">The index to start at in the vertices array.</param>
            <param name="verticesLength">The number of elements in the vertices array to use.</param>
            <param name="segments">The segment pairs based on vertices.</param>
            <param name="segmentsStartIndex">The index to start at in the segments array.</param>
            <param name="segmentsLength">The number of elements in the segments array to use.</param>
            <returns>The lines' invalidation token.</returns>
        </member>
        <member name="M:GDX.Developer.DebugDrawBuffer.DrawWireCube(UnityEngine.Color,UnityEngine.Vector3,UnityEngine.Vector3)">
            <summary>
                Draw a wireframe cube of a specific color to the buffer.
            </summary>
            <param name="color">The color which to draw the wire cube with.</param>
            <param name="center">The center world position of the cube.</param>
            <param name="size">The unit size of the cube</param>
            <returns>The created cube's invalidation token.</returns>
        </member>
        <member name="M:GDX.Developer.DebugDrawBuffer.Execute">
            <summary>
                Execute the GDX.Developer.DebugDrawBuffer, rendering its outputs to the screen.
            </summary>
            <remarks>
                This will finalize the command buffer, converging all data into meshes, etc. In order to change the
                buffer, you will need to
            </remarks>
        </member>
        <member name="M:GDX.Developer.DebugDrawBuffer.GetBuffer">
            <summary>
                Get the internal command buffer being used by this GDX.Developer.DebugDrawBuffer.
            </summary>
            <returns>A UnityEngine.Rendering.CommandBuffer.</returns>
        </member>
        <member name="M:GDX.Developer.DebugDrawBuffer.HasToken(System.Int32)">
            <summary>
            Is the given token present in the draw commands buffer.
            </summary>
            <param name="token">The token of the draw commands to check for.</param>
            <returns>Returns true if the token is found in the existing draw commands.</returns>
        </member>
        <member name="M:GDX.Developer.DebugDrawBuffer.Invalidate(System.Int32)">
            <summary>
                Invalidates a GDX.Developer.DebugDrawBuffer.DrawCommand based on the provided token, forcing the buffer to be refilled.
            </summary>
            <param name="token">The token of the draw commands to invalidate.</param>
        </member>
        <member name="M:GDX.Developer.DebugDrawBuffer.InvalidateAll">
            <summary>
                Invalidates the entire GDX.Developer.DebugDrawBuffer.
            </summary>
        </member>
        <member name="M:GDX.Developer.DebugDrawBuffer.NextDottedLineBatch(UnityEngine.Color)">
            <summary>
                Move to the next batch for a given dotted line color.
            </summary>
            <param name="color">The color which the dotted line is drawn as.</param>
        </member>
        <member name="M:GDX.Developer.DebugDrawBuffer.NextLineBatch(UnityEngine.Color)">
            <summary>
                Move to the next batch for a given line color.
            </summary>
            <param name="color">The color which the line is drawn as.</param>
        </member>
        <member name="M:GDX.Developer.DebugDrawBuffer.NextLineBatch(UnityEngine.Material)">
            <summary>
                Move to the next batch for a given material.
            </summary>
            <param name="material">The material used by a batch.</param>
        </member>
        <member name="M:GDX.Developer.DebugDrawBuffer.Reset">
            <summary>
                Resets the GDX.Developer.DebugDrawBuffer, as if it were newly created. However all fields are already
                allocating their previous sizes.
            </summary>
        </member>
        <member name="M:GDX.Developer.DebugDrawBuffer.GetCubeVertices(UnityEngine.Vector3,UnityEngine.Vector3)">
            <summary>
                Get the vertices that make up a cube.
            </summary>
            <remarks>
                Ordered based on GDX.Developer.DebugDrawBuffer.CubeSegmentIndices.
            </remarks>
            <param name="center">The world space center location of the cube.</param>
            <param name="size">The size of the cube.</param>
            <returns>An array of ordered vertices.</returns>
        </member>
        <member name="M:GDX.Developer.DebugDrawBuffer.AddLineDrawCommand(UnityEngine.Material,UnityEngine.Vector3[]@,System.Int32[]@,System.Int32)">
            <summary>
                Builds a line based meshReference from the given vertices and adds it to the draw buffer.
            </summary>
            <param name="material">The material to use when drawing the created meshReference.</param>
            <param name="vertices">The vertices of the created meshReference.</param>
            <param name="segments">The segment pairs based on vertices.</param>
            <param name="token">Force a specific token for the meshReference. Don't use this.</param>
            <returns>The created meshReference's invalidation token.</returns>
        </member>
        <member name="M:GDX.Developer.DebugDrawBuffer.GetDottedLineMaterialByColor(UnityEngine.Color)">
            <summary>
                Gets the cached dotted line material, or creates one for the given color.
            </summary>
            <param name="color">A defined draw color.</param>
            <returns>The qualified dotted line material of the color.</returns>
        </member>
        <member name="M:GDX.Developer.DebugDrawBuffer.GetMaterialByHashCode(System.Int32)">
            <summary>
                Gets a material from the internal cache based on its !:Material.GetHashCode.
            </summary>
            <remarks>A warning will be thrown in the editor if the material is not found.</remarks>
            <param name="hashCode">The integer based hash code of the material.</param>
            <returns>The material if found, otherwise a default material will be returned.</returns>
        </member>
        <member name="M:GDX.Developer.DebugDrawBuffer.GetSolidLineMaterialByColor(UnityEngine.Color)">
            <summary>
                Gets the cached solid line material, or creates one for the given color.
            </summary>
            <param name="color">A defined draw color.</param>
            <returns>The qualified line material of the color.</returns>
        </member>
        <member name="T:GDX.Developer.DebugDrawBuffer.DrawCommand">
            <summary>
                A structure describing a finalized meshReference/material and its draw operation.
            </summary>
        </member>
        <member name="T:GDX.Developer.CommandLineParser">
            <summary>
                A simplified commandline parser that handles arguments which follow the <c>--FLAG</c> or <c>--KEY=VALUE</c> format.
                Automatically initialized during normal runtime operations, however can be manually triggered for author time
                use cases as well.
            </summary>
            <remarks>
                <para>
                    The prefix and divider are configurable via the GDX.Config, however the always, the <c>FLAG</c>
                    and <c>KEY</c> will be Uppercase.
                </para>
            </remarks>
        </member>
        <member name="F:GDX.Developer.CommandLineParser.Arguments">
            <summary>
                The processed arguments found after parsing the arguments
            </summary>
        </member>
        <member name="F:GDX.Developer.CommandLineParser.Flags">
            <summary>
                The processed flags found in the arguments.
            </summary>
        </member>
        <member name="M:GDX.Developer.CommandLineParser.ProcessArguments(System.String[],System.Boolean)">
            <summary>
                Process an array of arguments into GDX.Developer.CommandLineParser.Arguments and GDX.Developer.CommandLineParser.Flags.
            </summary>
            <param name="argumentArray">An array of arguments to process.</param>
            <param name="shouldClear">Should the storage containers be cleared.</param>
        </member>
        <member name="T:GDX.Developer.Profiling">
            <summary>
                A set of functionality useful for creating profiling data to reason about the performance of an application.
            </summary>
            <exception cref="T:GDX.UnsupportedRuntimeException">Not supported on DOTS Runtime.</exception>
        </member>
        <member name="F:GDX.Developer.Profiling.k_MemoryCaptureFilePrefix">
            <summary>
                The prefix to use with all capture files.
            </summary>
        </member>
        <member name="F:GDX.Developer.Profiling.k_MemoryCapturesToKeep">
            <summary>
                The number of memory captures to keep in the output folder.
            </summary>
        </member>
        <member name="F:GDX.Developer.Profiling.k_ProfilesToKeep">
            <summary>
                The number of profile captures to keep in the output folder.
            </summary>
        </member>
        <member name="F:GDX.Developer.Profiling.k_ProfileFilePrefix">
            <summary>
                The prefix to use with all binary profile files.
            </summary>
        </member>
        <member name="F:GDX.Developer.Profiling.k_AllCaptureFlags">
            <summary>
                The default flags (all) used when capturing memory.
            </summary>
        </member>
        <member name="M:GDX.Developer.Profiling.TakeMemorySnapshot(System.String,System.Action{System.String,System.Boolean},UnityEngine.Profiling.Memory.Experimental.CaptureFlags,System.Boolean)">
            <summary>
                Take a memory snapshot and save it to GDX.Platform.GetOutputFolder(System.String).
            </summary>
            <param name="prefix">Override the default prefix GDX.Developer.Profiling.k_MemoryCaptureFilePrefix.</param>
            <param name="finishCallback">Optional callback action once the memory capture has been made.</param>
            <param name="captureFlags">Override of the memory capture flags, defaults to GDX.Developer.Profiling.k_AllCaptureFlags.</param>
            <param name="manageCaptures">Should the number of captures found in the output folder be managed?</param>
        </member>
        <member name="M:GDX.Developer.Profiling.StartProfiling(System.String,System.Boolean)">
            <summary>
                Setup a profiling session used during an import. This will create a binary file when finished profiling.
            </summary>
            <param name="prefix">Optional descriptor for profile run used in filename.</param>
            <param name="manageProfiles">Should the number of profiles be managed.</param>
        </member>
        <member name="M:GDX.Developer.Profiling.StopProfiling">
            <summary>
                Finalize a profiling session during an import.
            </summary>
        </member>
        <member name="T:GDX.Developer.TransientReference">
            <summary>
                A comparable weak reference to an object which will not prevent garbage collection. It will positively
                compare against similar targeted reference trackers as well as the actual target object.
            </summary>
            <remarks>
                There isn't a lot of great use cases for using this sort of thing; System.WeakReference on its own
                is sufficient in most of the use cases, however this particular arrangement is useful for developer-ish
                stuff.
            </remarks>
        </member>
        <member name="M:GDX.Developer.TransientReference.#ctor(System.Object)">
            <summary>
                Create a GDX.Developer.TransientReference referencing the target.
            </summary>
            <param name="target">The target System.Object to reference.</param>
        </member>
        <member name="M:GDX.Developer.TransientReference.#ctor(System.Object,System.Boolean)">
            <summary>
                Create a GDX.Developer.TransientReference referencing the target.
            </summary>
            <param name="target">The target System.Object to reference.</param>
            <param name="trackResurrection">Should the object remain tracked after it has been finalized.</param>
        </member>
        <member name="M:GDX.Developer.TransientReference.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
                Create a GDX.Developer.TransientReference from the info.
            </summary>
            <param name="info">A System.Runtime.Serialization.SerializationInfo representation of a GDX.Developer.TransientReference.</param>
            <param name="context">Describes the source of the System.Runtime.Serialization.SerializationInfo.</param>
        </member>
        <member name="M:GDX.Developer.TransientReference.CompareTo(System.Object)">
            <summary>
                Compare this GDX.Developer.TransientReference to the target System.Object.
            </summary>
            <param name="obj">The target System.Object to compare against.</param>
            <returns>1 if the same, 0 otherwise.</returns>
        </member>
        <member name="M:GDX.Developer.TransientReference.CompareTo(GDX.Developer.TransientReference)">
            <summary>
                Compare this GDX.Developer.TransientReference to the target GDX.Developer.TransientReference.
            </summary>
            <param name="obj">The target GDX.Developer.TransientReference to compare against.</param>
            <returns>1 if the same, 0 otherwise.</returns>
        </member>
        <member name="M:GDX.Developer.TransientReference.CompareTo(System.WeakReference)">
            <summary>
                Compare this GDX.Developer.TransientReference to the target System.WeakReference.
            </summary>
            <param name="obj">The target System.WeakReference to compare against.</param>
            <returns>1 if the same, 0 otherwise.</returns>
        </member>
        <member name="M:GDX.Developer.TransientReference.Equals(GDX.Developer.TransientReference)">
            <summary>
                Does this GDX.Developer.TransientReference equal the target GDX.Developer.TransientReference.
            </summary>
            <param name="other">The target GDX.Developer.TransientReference to compare with.</param>
            <returns>true if it is the same, false otherwise.</returns>
        </member>
        <member name="M:GDX.Developer.TransientReference.Equals(System.WeakReference)">
            <summary>
                Does this GDX.Developer.TransientReference equal the target System.WeakReference.
            </summary>
            <param name="other">The target System.WeakReference to compare with.</param>
            <returns>true if it is the same, false otherwise.</returns>
        </member>
        <member name="M:GDX.Developer.TransientReference.Equals(System.Object)">
            <summary>
                Does this GDX.Developer.TransientReference equal the target System.Object.
            </summary>
            <param name="obj">The target System.Object to compare with.</param>
            <returns>true if it is the same, false otherwise.</returns>
        </member>
        <member name="M:GDX.Developer.TransientReference.GetHashCode">
            <summary>
                Return the hashcode of the P:System.WeakReference.Target.
            </summary>
            <returns>Returns the P:System.WeakReference.Target's hash code, or -1 if null.</returns>
        </member>
        <member name="M:GDX.Developer.TransientReference.op_Equality(GDX.Developer.TransientReference,GDX.Developer.TransientReference)">
            <summary>
                Compare GDX.Developer.TransientReferences to see if they are equal.
            </summary>
            <param name="left">Left-side GDX.Developer.TransientReference.</param>
            <param name="right">Right-side GDX.Developer.TransientReference.</param>
            <returns>true/false if they are equal.</returns>
        </member>
        <member name="M:GDX.Developer.TransientReference.op_Inequality(GDX.Developer.TransientReference,GDX.Developer.TransientReference)">
            <summary>
                Compare GDX.Developer.TransientReferences to see if they are not equal.
            </summary>
            <param name="left">Left-side GDX.Developer.TransientReference.</param>
            <param name="right">Right-side GDX.Developer.TransientReference.</param>
            <returns>true/false if they are not equal.</returns>
        </member>
        <member name="T:GDX.Developer.DebugDraw">
            <summary>
                A debug draw system useful in both the editor and at runtime.
            </summary>
        </member>
        <member name="F:GDX.Developer.DebugDraw.s_UnmanagedBuffers">
            <summary>
                A dictionary of known GDX.Developer.DebugDrawBuffer and their ID which are not automatically executed.
            </summary>
        </member>
        <member name="M:GDX.Developer.DebugDraw.GetUnmanagedBuffer(System.Int32,System.Int32,System.Int32)">
            <summary>
            Get an instance of GDX.Developer.DebugDrawBuffer based on the provided key that is not managed.
            </summary>
            <example>
                By checking the P:GDX.Developer.DebugDrawBuffer.Finalized property we can skip over the expensive building step.
                <code>
                    DebugDrawBuffer buffer = DebugDraw.GetUnmanagedBuffer(gameObjet.GetInstanceID());
                    if (!buffer.Finalized)
                    {
                        /// Draw lots of stuff ...
                        buffer.DrawWireCube(Color.white, worldPosition, size);
                    }
                    buffer.Execute();
                </code>
            </example>
            <param name="key">
                A value based key used to reference a GDX.Developer.DebugDrawBuffer in a
                GDX.Collections.Generic.IntKeyDictionary`1.
            </param>
            <param name="initialColorCount">Initial number of internal materials to allocate (x2).</param>
            <param name="verticesPerMesh">The number of vertices to split batched meshes on.</param>
            <returns>
                A newly created GDX.Developer.DebugDrawBuffer if the provided key is not found, or the previously
                created GDX.Developer.DebugDrawBuffer identified by the key.
            </returns>
        </member>
        <member name="M:GDX.Developer.DebugDraw.HasUnmanagedBuffer(System.Int32)">
            <summary>
                Returns if the provided key has an unmanaged GDX.Developer.DebugDrawBuffer referenced.
            </summary>
            <param name="key">
                The key used to reference the GDX.Developer.DebugDrawBuffer.
            </param>
            <returns>true/false if the key has a GDX.Developer.DebugDrawBuffer associated with it.</returns>
        </member>
        <member name="M:GDX.Developer.DebugDraw.RemoveUnmanagedBuffer(System.Int32)">
            <summary>
                Dereference the indicated unmanaged GDX.Developer.DebugDrawBuffer from the provider.
            </summary>
            <param name="key">
                The key used to reference the GDX.Developer.DebugDrawBuffer.
            </param>
        </member>
        <member name="T:GDX.OriginalValueAttribute">
            <summary>
                An attribute allowing for the storage of some additional data along side of a field or property.
            </summary>
        </member>
        <member name="M:GDX.OriginalValueAttribute.GetValue``1(System.Reflection.FieldInfo)">
            <summary>
            Get the original value associated with the given field.
            </summary>
            <param name="field">A given System.Reflection.FieldInfo.</param>
            <typeparam name="T">The type of data being read.</typeparam>
            <returns>The original value.</returns>
        </member>
        <member name="M:GDX.OriginalValueAttribute.GetValue``1(System.Reflection.PropertyInfo)">
            <summary>
            Get the original value associated with the given property.
            </summary>
            <param name="property">A given System.Reflection.PropertyInfo.</param>
            <typeparam name="T">The type of data being read.</typeparam>
            <returns>The original value.</returns>
        </member>
        <member name="T:GDX.IListExtensions">
            <summary>
                System.Collections.Generic.IList`1 Based Extension Methods
            </summary>
        </member>
        <member name="M:GDX.IListExtensions.AddUniqueItem``1(System.Collections.Generic.IList{``0},``0)">
            <summary>
                Add an item to a System.Collections.Generic.IList`1, but only if it is not already contained.
            </summary>
            <param name="targetList">The System.Collections.Generic.IList`1 to add too.</param>
            <param name="targetItem">The target object to add.</param>
            <typeparam name="T">The type of the System.Collections.Generic.IList`1.</typeparam>
            <returns>true/false if this operation was able to add the item.</returns>
        </member>
        <member name="M:GDX.IListExtensions.AddUniqueRange``1(System.Collections.Generic.IList{``0},``0[])">
            <summary>
                Add a range of items to a System.Collections.Generic.IList`1, checking if each item is
                unique prior to adding.
            </summary>
            <param name="targetList">The System.Collections.Generic.IList`1 to add too.</param>
            <param name="targetItems">The array of items to add.</param>
            <typeparam name="T">The type of the System.Collections.Generic.IList`1.</typeparam>
        </member>
        <member name="M:GDX.IListExtensions.ContainsItem``1(System.Collections.Generic.IList{``0},``0)">
            <summary>
                <para>Does targetList contain targetItem?</para>
            </summary>
            <remarks>Avoids using System.Collections.Generic.EqualityComparer`1.</remarks>
            <param name="targetList">The System.Collections.Generic.IList`1 to look in.</param>
            <param name="targetItem">The target object to look for.</param>
            <typeparam name="T">The type of the System.Collections.Generic.IList`1.</typeparam>
            <returns>true/false</returns>
        </member>
        <member name="M:GDX.IListExtensions.ContainsReference``1(System.Collections.Generic.IList{``0},``0)">
            <summary>
                <para>Does targetList contain targetItem?</para>
            </summary>
            <remarks>Ignores equality check and end up comparing object pointers.</remarks>
            <param name="targetList">The System.Collections.Generic.IList`1 to look in.</param>
            <param name="targetItem">The target object to look for.</param>
            <typeparam name="T">The type of the System.Collections.Generic.IList`1.</typeparam>
            <returns>true/false</returns>
        </member>
        <member name="M:GDX.IListExtensions.RemoveFirstItem``1(System.Collections.Generic.IList{``0},``0)">
            <summary>
                <para>Removes the first targetItem from the provided targetList.</para>
            </summary>
            <remarks>Avoids using System.Collections.Generic.EqualityComparer`1.</remarks>
            <param name="targetList">The target System.Collections.Generic.IList`1.</param>
            <param name="targetItem">The target object to remove from the targetList.</param>
            <typeparam name="T">The type of the System.Collections.Generic.IList`1.</typeparam>
            <returns>true/false if the item was removed.</returns>
        </member>
        <member name="M:GDX.IListExtensions.RemoveItems``1(System.Collections.Generic.IList{``0},``0)">
            <summary>
                <para>Removes all targetItem from the provided targetList.</para>
            </summary>
            <remarks>Avoids using System.Collections.Generic.EqualityComparer`1, uses object pointers.</remarks>
            <param name="targetList">The target System.Collections.Generic.IList`1.</param>
            <param name="targetItem">The target object to remove from the targetList.</param>
            <typeparam name="T">The type of the System.Collections.Generic.IList`1.</typeparam>
            <returns>true/false if the item was removed.</returns>
        </member>
        <member name="M:GDX.IListExtensions.RemoveItemSwap``1(System.Collections.Generic.IList{``0},System.Int32)">
            <summary>
                <para>
                    Replaces the object found at the provided index with the last object in
                    targetList, then removes the last item from the targetList.
                </para>
            </summary>
            <remarks>
                This make sure that you are always removing from the end of a
                System.Collections.Generic.IList`1.
            </remarks>
            <param name="targetList">The target System.Collections.Generic.IList`1.</param>
            <param name="index">The index of the item to remove.</param>
            <typeparam name="T">The type of the System.Collections.Generic.IList`1.</typeparam>
        </member>
        <member name="M:GDX.IListExtensions.RemoveLastItem``1(System.Collections.Generic.IList{``0},``0)">
            <summary>
                <para>Removes the last targetItem from the provided targetList.</para>
            </summary>
            <remarks>Avoids using System.Collections.Generic.EqualityComparer`1.</remarks>
            <param name="targetList">The target System.Collections.Generic.IList`1.</param>
            <param name="targetItem">The target object to remove from the targetList.</param>
            <typeparam name="T">The type of the System.Collections.Generic.IList`1.</typeparam>
            <returns>true/false if the item was removed.</returns>
        </member>
        <member name="M:GDX.IListExtensions.Shuffle``1(System.Collections.Generic.IList{``0})">
            <summary>
                Shuffle the items in the targetList.
            </summary>
            <param name="targetList">The target System.Collections.Generic.IList`1.</param>
            <typeparam name="T">The type of the System.Collections.Generic.IList`1.</typeparam>
        </member>
        <member name="T:GDX.Collections.Generic.NativeArray2D`1">
            <summary>
                A 2-dimension Unity.Collections.NativeArray`1 backed array.
            </summary>
            <remarks>Use X (horizontal) and Y (vertical) arrangement.</remarks>
            <typeparam name="T">Type of objects.</typeparam>
        </member>
        <member name="F:GDX.Collections.Generic.NativeArray2D`1.Array">
            <summary>
                The backing Unity.Collections.NativeArray`1.
            </summary>
        </member>
        <member name="F:GDX.Collections.Generic.NativeArray2D`1.ColumnCount">
            <summary>
                The length of each pseudo-array in the dataset.
            </summary>
            <remarks>CAUTION! Changing this will alter the understanding of the data.</remarks>
        </member>
        <member name="F:GDX.Collections.Generic.NativeArray2D`1.RowCount">
            <summary>
                The number of pseudo-arrays created to support the dimensionality.
            </summary>
            <remarks>CAUTION! Changing this will alter the understanding of the data.</remarks>
        </member>
        <member name="M:GDX.Collections.Generic.NativeArray2D`1.#ctor(System.Int32,System.Int32,Unity.Collections.Allocator,Unity.Collections.NativeArrayOptions)">
            <summary>
                Create a GDX.Collections.Generic.NativeArray2D`1.
            </summary>
            <param name="rowCount">The number of rows (X).</param>
            <param name="columnCount">The number of columns (Y).</param>
            <param name="allocator">The Unity.Collections.Allocator type to use.</param>
            <param name="nativeArrayOptions">Should the memory be cleared on allocation?</param>
        </member>
        <member name="P:GDX.Collections.Generic.NativeArray2D`1.Item(System.Int32,System.Int32)">
            <summary>
                Get a typed object at a specific 2-dimensional index in GDX.Collections.Generic.NativeArray2D`1.Array.
            </summary>
            <param name="x">The row/line number (vertical axis).</param>
            <param name="y">The column number (horizontal axis).</param>
        </member>
        <member name="M:GDX.Collections.Generic.NativeArray2D`1.AddRows(System.Int32,Unity.Collections.Allocator,Unity.Collections.NativeArrayOptions)">
            <summary>
                Add additional rows to the dataset.
            </summary>
            <param name="numberOfNewRows">The number of rows/arrays to add.</param>
            <param name="allocator">The Unity.Collections.Allocator type to use.</param>
            <param name="nativeArrayOptions">Should the memory be cleared on allocation?</param>
        </member>
        <member name="M:GDX.Collections.Generic.NativeArray2D`1.AddColumns(System.Int32,Unity.Collections.Allocator,Unity.Collections.NativeArrayOptions)">
            <summary>
                Add additional columns to the dataset.
            </summary>
            <param name="numberOfNewColumns">The number of columns add.</param>
            <param name="allocator">The Unity.Collections.Allocator type to use.</param>
            <param name="nativeArrayOptions">Should the memory be cleared on allocation?</param>
        </member>
        <member name="M:GDX.Collections.Generic.NativeArray2D`1.Dispose">
            <summary>
                Properly dispose of GDX.Collections.Generic.NativeArray2D`1.Array.
            </summary>
        </member>
        <member name="M:GDX.Collections.Generic.NativeArray2D`1.ReverseColumns">
            <summary>
                Reverse the order of the columns in the backing GDX.Collections.Generic.NativeArray2D`1.Array.
            </summary>
        </member>
        <member name="M:GDX.Collections.Generic.NativeArray2D`1.ReverseRows">
            <summary>
                Reverse the order of the rows in the backing GDX.Collections.Generic.NativeArray2D`1.Array.
            </summary>
        </member>
        <member name="M:GDX.Collections.Generic.NativeArray2D`1.ToMultiDimensionalArray">
            <summary>
                Creates a copy of the internal array as a traditional multi-dimensional array.
            </summary>
            <remarks>Useful for scenarios where fills need to be done with [,] structured multi-dimensional arrays.</remarks>
            <returns>A new copy of the backing GDX.Collections.Generic.NativeArray2D`1.Array in multi-dimensional form.</returns>
        </member>
        <member name="T:GDX.Collections.Generic.DictionaryPrimes">
            <summary>
                A default selection of prime numbers used with different collections.
            </summary>
        </member>
        <member name="F:GDX.Collections.Generic.DictionaryPrimes.s_Primes">
            <summary>
                The cached array of prime numbers.
            </summary>
        </member>
        <member name="F:GDX.Collections.Generic.DictionaryPrimes.s_PrimesLength">
            <summary>
                The number of predetermined prime numbers in GDX.Collections.Generic.DictionaryPrimes.s_Primes.
            </summary>
        </member>
        <member name="M:GDX.Collections.Generic.DictionaryPrimes.GetPrime(System.Int32)">
            <summary>
                Get the nearest prime number greater then or equal to the provided minimum.
            </summary>
            <param name="minimum">The lowest possible value.</param>
            <returns>A prime number.</returns>
        </member>
        <member name="M:GDX.Collections.Generic.DictionaryPrimes.GetPrimeAtIndex(System.Int32)">
            <summary>
                Get the prime number in GDX.Collections.Generic.DictionaryPrimes.s_Primes at index.
            </summary>
            <remarks>No out of bounds detection.</remarks>
            <param name="index">The valid array index requested.</param>
            <returns>A prime number.</returns>
        </member>
        <member name="M:GDX.Collections.Generic.DictionaryPrimes.GetPrimesLength">
            <summary>
                Get the number of prime numbers
            </summary>
            <returns></returns>
        </member>
        <member name="M:GDX.Collections.Generic.DictionaryPrimes.GetNextSize(System.Int32)">
            <summary>
            Returns size of hashtable to grow to.
            </summary>
            <param name="oldSize"></param>
            <returns></returns>
        </member>
        <member name="M:GDX.Collections.Generic.DictionaryPrimes.SetDefaultPrimes">
            <summary>
                Establish the default prime numbers in GDX.Collections.Generic.DictionaryPrimes.s_Primes.
            </summary>
        </member>
        <member name="M:GDX.Collections.Generic.DictionaryPrimes.SetPrimes(System.Int32[])">
            <summary>
                Set the GDX.Collections.Generic.DictionaryPrimes.s_Primes array with the provided primes.
            </summary>
            <param name="primes">An array of prime numbers.</param>
        </member>
        <member name="T:GDX.Collections.Generic.CoalesceArray`1">
            <summary>
                Multiple arrays acting as one uniform coalesced array.
            </summary>
            <remarks>Stores a maximum of 18,446,744,073,709,551,615 elements.</remarks>
            <typeparam name="T">The type of data to be stored.</typeparam>
        </member>
        <member name="F:GDX.Collections.Generic.CoalesceArray`1.m_Buckets">
            <summary>
                The internal arrays storage
            </summary>
        </member>
        <member name="F:GDX.Collections.Generic.CoalesceArray`1.m_BucketSize">
            <summary>
                The block size used to allocate new arrays.
            </summary>
        </member>
        <member name="F:GDX.Collections.Generic.CoalesceArray`1.m_BucketSizeMinusOne">
            <summary>
                Cached version of the bucket size, minus one used in GDX.Collections.Generic.CoalesceArray`1.GetBucketLocation(System.UInt64).
            </summary>
        </member>
        <member name="F:GDX.Collections.Generic.CoalesceArray`1.m_Length">
            <summary>
                The number of elements the GDX.Collections.Generic.CoalesceArray`1 is capable of holding.
            </summary>
        </member>
        <member name="T:GDX.Collections.Generic.SerializableDictionary`2">
            <summary>
                A Unity serializable System.Collections.Generic.Dictionary`2.
            </summary>
            <remarks>
                <para>
                    This will NOT work with System.Object based objects, use UnityEngine.Object if
                    you must. While .NET has solutions for creating custom serialization paths, Unity uses its own system to
                    serialize data into YAML structures. This also assumes that the types provided can be serialized by Unity.
                </para>
                <para>
                    The process of serializing and deserializing this dictionary should not be considered performant.
                </para>
                <para>
                    The property drawer will not show structs, it will be blank. It does work however if done through code.
                </para>
            </remarks>
            <typeparam name="TKey">The dictionary's key System.Type.</typeparam>
            <typeparam name="TValue">The dictionary's value System.Type.</typeparam>
            <exception cref="T:GDX.UnsupportedRuntimeException">Not supported on DOTS Runtime.</exception>
        </member>
        <member name="F:GDX.Collections.Generic.SerializableDictionary`2.m_IsSerializable">
            <summary>
                Is the dictionary completely capable of being serialized by Unity?
            </summary>
            <remarks>This field is determined/cached in the constructor.</remarks>
        </member>
        <member name="F:GDX.Collections.Generic.SerializableDictionary`2.m_SerializedLength">
            <summary>
                The length of the serialized data arrays.
            </summary>
        </member>
        <member name="F:GDX.Collections.Generic.SerializableDictionary`2.m_SerializedKeys">
            <summary>
                An array of all of the keys, in order, used to recreate the base System.Collections.Generic.Dictionary`2.
            </summary>
        </member>
        <member name="F:GDX.Collections.Generic.SerializableDictionary`2.m_SerializedValues">
            <summary>
                An array of all of the values, in order, used to recreate the base System.Collections.Generic.Dictionary`2.
            </summary>
        </member>
        <member name="M:GDX.Collections.Generic.SerializableDictionary`2.#ctor">
            <summary>
                Type constructor.
            </summary>
        </member>
        <member name="M:GDX.Collections.Generic.SerializableDictionary`2.GetSerializedDataLength">
            <summary>
                Get the length of the serialized data arrays.
            </summary>
            <returns>An integer value representing the count.</returns>
        </member>
        <member name="M:GDX.Collections.Generic.SerializableDictionary`2.IsSerializableType(System.Type)">
            <summary>
                Is the type capable of being serialized by the
                GDX.Collections.Generic.SerializableDictionary`2, utilizing Unity's own serialization system?
            </summary>
            <returns>true/false if the type is valid.</returns>
        </member>
        <member name="M:GDX.Collections.Generic.SerializableDictionary`2.LoadSerializedData(System.Boolean)">
            <summary>
                Load the data into the System.Collections.Generic.Dictionary`2 cached in the serialized data.
            </summary>
            <param name="clearAfterLoad">Should the serialized data be cleared after loading?</param>
        </member>
        <member name="M:GDX.Collections.Generic.SerializableDictionary`2.OnAfterDeserialize">
            <summary>
                Rehydrate the serialized data arrays back into a cohesive System.Collections.Generic.Dictionary`2.
            </summary>
            <remarks>Invoked by Unity, calls GDX.Collections.Generic.SerializableDictionary`2.LoadSerializedData(System.Boolean).</remarks>
        </member>
        <member name="M:GDX.Collections.Generic.SerializableDictionary`2.OnBeforeSerialize">
            <summary>
                Build out serialized data arrays and associative data, used to rehydrate during deserialization.
            </summary>
            <remarks>Invoked by Unity, calls GDX.Collections.Generic.SerializableDictionary`2.SaveSerializedData.</remarks>
        </member>
        <member name="M:GDX.Collections.Generic.SerializableDictionary`2.OverwriteSerializedData(`0[],`1[])">
            <summary>
                Overwrite data in the serialized arrays with the provided data.
            </summary>
            <param name="keyArray">An array of keys.</param>
            <param name="valueArray">An array of values.</param>
        </member>
        <member name="M:GDX.Collections.Generic.SerializableDictionary`2.SaveSerializedData">
            <summary>
                Fill serializable arrays from dictionary data.
            </summary>
            <remarks>We will always create the arrays so the property drawers function nicely.</remarks>
        </member>
        <member name="T:GDX.Collections.Generic.IntKeyDictionary`1">
            <summary>
                An optimized System.Collections.Generic.Dictionary`2-like data structure with a
                System.String key requirement.
            </summary>
        </member>
        <member name="M:GDX.Collections.Generic.IntKeyDictionary`1.#ctor(System.Int32)">
            <summary>
            Initializes the dictionary with at least minCapacity capacity.
            </summary>
            <param name="minCapacity">The minimal initial capacity to reserve.</param>
        </member>
        <member name="M:GDX.Collections.Generic.IntKeyDictionary`1.AddWithExpandCheck(System.Int32,`0)">
            <summary>
            Adds the key value pair to the dictionary, expanding if necessary but not checking for duplicate entries.
            </summary>
            <param name="key">The key to add.</param>
            <param name="value">The value to add.</param>
        </member>
        <member name="M:GDX.Collections.Generic.IntKeyDictionary`1.AddWithUniqueCheck(System.Int32,`0)">
            <summary>
            Adds the key value pair to the dictionary, checking for duplicates but not expanding if necessary.
            </summary>
            <param name="key">The key to add.</param>
            <param name="value">The value to add.</param>
            <returns>True if the entry was successfully created.</returns>
        </member>
        <member name="M:GDX.Collections.Generic.IntKeyDictionary`1.AddSafe(System.Int32,`0)">
            <summary>
            Adds the key value pair to the dictionary, checking for duplicate entries and expanding if necessary.
            </summary>
            <param name="key">The key to add.</param>
            <param name="value">The value to add.</param>
            <returns>True if the entry was successfully created.</returns>
        </member>
        <member name="M:GDX.Collections.Generic.IntKeyDictionary`1.AddUnchecked(System.Int32,`0)">
            <summary>
            Adds the key value pair to the dictionary, without checking for available capacity or duplicate entries.
            </summary>
            <param name="key">The key to add.</param>
            <param name="value">The value to add.</param>
        </member>
        <member name="M:GDX.Collections.Generic.IntKeyDictionary`1.ContainsKey(System.Int32)">
            <summary>
            Checks if the dictionary contains the given key.
            </summary>
            <param name="key">The key to check for.</param>
            <returns>True if the dictionary contains the key.</returns>
        </member>
        <member name="M:GDX.Collections.Generic.IntKeyDictionary`1.ExpandWhenFull">
            <summary>
            Resizes the dictionary with the assumption that it is full. Do not use otherwise.
            </summary>
        </member>
        <member name="M:GDX.Collections.Generic.IntKeyDictionary`1.Reserve(System.Int32)">
            <summary>
            Expands the dictionary if it does not have enough empty space for capacityToReserve.
            </summary>
            <param name="capacityToReserve"></param>
        </member>
        <member name="M:GDX.Collections.Generic.IntKeyDictionary`1.IndexOf(System.Int32)">
            <summary>
            Finds the index of the entry corresponding to a key.
            </summary>
            <param name="key">The key to find the index of.</param>
            <returns>The index of the entry, or -1 if the entry does not exist.</returns>
        </member>
        <member name="M:GDX.Collections.Generic.IntKeyDictionary`1.TryModifyValue(System.Int32,`0)">
            <summary>
            Replaces the value of the entry if the entry exists.
            </summary>
            <param name="key">The key of the entry to modify.</param>
            <param name="value">The new value of the entry.</param>
            <returns>True if the entry was found.</returns>
        </member>
        <member name="M:GDX.Collections.Generic.IntKeyDictionary`1.TryRemove(System.Int32)">
            <summary>
            Removes the entry if it exists.
            </summary>
            <param name="key">The key to remove.</param>
            <returns>True if the entry was found.</returns>
        </member>
        <member name="M:GDX.Collections.Generic.IntKeyDictionary`1.TryRemoveNoValueClear(System.Int32)">
            <summary>
            Removes the entry if it exists, but does not remove the value of the key value pair.
            </summary>
            <param name="key">The key to remove.</param>
            <returns>True if the entry was found.</returns>
        </member>
        <member name="M:GDX.Collections.Generic.IntKeyDictionary`1.TryGetValue(System.Int32,`0@)">
            <summary>
            Attempts to get the value for the given key; returns true if key was found, false otherwise.
            </summary>
            <param name="key">The key to retrieve.</param>
            <param name="value">The value of the entry found.</param>
            <returns>True if the entry was found; false otherwise.</returns>
        </member>
        <member name="P:GDX.Collections.Generic.IntKeyDictionary`1.Item(System.Int32)">
            <summary>
                Directly access a value by key.
            </summary>
            <param name="key">The target key to look for a value identified by.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when a null key is provided to lookup.</exception>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown when the key is not found in the GDX.Collections.Generic.StringKeyDictionary`1.</exception>
        </member>
        <member name="M:GDX.Collections.Generic.IntKeyDictionary`1.MoveNext(System.Int32@,System.Int32,System.Int32@,GDX.Collections.Generic.IntKeyEntry{`0}@)">
            <summary>
            Iterates the dictionary.
            </summary>
            <param name="iteratedIndexCount">The number of indices iterated so far - pass in 0 at the start of iteration.</param>
            <param name="iteratorVersion">The version when iteration started.</param>
            <param name="dictionaryVersion">The current version of the dictionary - update this on add, remove, or clear operations.</param>
            <param name="entry">The entry returned by the iterator</param>
            <returns>Whether the iterator found an entry, finished iteration, or could not continue due to an invalid version.</returns>
        </member>
        <member name="M:GDX.Collections.Generic.IntKeyDictionary`1.MoveNext(System.Int32@,GDX.Collections.Generic.IntKeyEntry{`0}@)">
            <summary>
            Iterates the dictionary.
            NOTE: if you suspect the dictionary might be modified while iterating, this will not catch the error -- use the other overload instead.
            </summary>
            <param name="iteratedIndexCount">The number of indices iterated so far - pass in 0 at the start of iteration.</param>
            <param name="entry">The entry returned by the iterator</param>
            <returns>Whether or not the iterator found an entry</returns>
        </member>
        <member name="M:GDX.Collections.Generic.IntKeyDictionary`1.MoveNext(System.Int32@)">
            <summary>
                Iterates the dictionary.
            </summary>
            <remarks>
                <para>
                    If you use iteratedIndexCount during iteration, you need to decrement it by 1 to
                    properly access the current iterations index.
                </para>
                <para>
                    If you suspect the dictionary might be modified while iterating, this will not catch the error.
                    You must use the other overload instead.
                </para>
            </remarks>
            <param name="iteratedIndexCount">The number of indices iterated so far - pass in 0 at the start of iteration.</param>
            <returns>Whether or not the iterator found an entry</returns>
        </member>
        <member name="M:GDX.Collections.Generic.IntKeyDictionary`1.Clear">
            <summary>
            Clears the dictionary.
            </summary>
        </member>
        <member name="T:GDX.Collections.Generic.Array3D`1">
            <summary>
                A three-dimensional array backed a flat array.
            </summary>
            <typeparam name="T">Type of objects.</typeparam>
        </member>
        <member name="F:GDX.Collections.Generic.Array3D`1.Array">
            <summary>
                The backing flat array.
            </summary>
        </member>
        <member name="F:GDX.Collections.Generic.Array3D`1.Depth">
            <summary>
                The stride of the z-axis segment in GDX.Collections.Generic.Array3D`1.Array.
            </summary>
        </member>
        <member name="F:GDX.Collections.Generic.Array3D`1.DepthLength">
            <summary>
                The total length of a single GDX.Collections.Generic.Array3D`1.Depth.
            </summary>
        </member>
        <member name="F:GDX.Collections.Generic.Array3D`1.Height">
            <summary>
                The stride of the y-axis segment in GDX.Collections.Generic.Array3D`1.Array.
            </summary>
        </member>
        <member name="F:GDX.Collections.Generic.Array3D`1.Length">
            <summary>
                The length of GDX.Collections.Generic.Array3D`1.Array.
            </summary>
        </member>
        <member name="F:GDX.Collections.Generic.Array3D`1.Width">
            <summary>
                The stride of the x-axis segment in GDX.Collections.Generic.Array3D`1.Array.
            </summary>
        </member>
        <member name="M:GDX.Collections.Generic.Array3D`1.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
                Create a GDX.Collections.Generic.Array3D`1 with a uniform dimensional length.
            </summary>
            <remarks></remarks>
            <param name="width">X-axis length.</param>
            <param name="height">Y-axis length.</param>
            <param name="depth">Z-axis length.</param>
        </member>
        <member name="P:GDX.Collections.Generic.Array3D`1.Item(System.Int32,System.Int32,System.Int32)">
            <summary>
                Access a specific location in the voxel.
            </summary>
            <param name="x">X location index.</param>
            <param name="y">Y location index.</param>
            <param name="z">Z location index.</param>
        </member>
        <member name="P:GDX.Collections.Generic.Array3D`1.Item(Unity.Mathematics.int3)">
            <summary>
                Access a specific location in the voxel.
            </summary>
            <param name="index">A three-dimensional index.</param>
        </member>
        <member name="M:GDX.Collections.Generic.Array3D`1.Dispose">
            <summary>
                Properly dispose of the GDX.Collections.Generic.Array3D`1.
            </summary>
        </member>
        <member name="M:GDX.Collections.Generic.Array3D`1.GetFromIndex(System.Int32)">
            <summary>
                Get the three-dimensional index of a flat array index.
            </summary>
            <param name="index">A flat array index.</param>
            <returns>A three-dimensional voxel index.</returns>
        </member>
        <member name="T:GDX.Collections.Generic.NativeArray3D`1">
            <summary>
                A three-dimensional Unity.Collections.NativeArray`1 backed array.
            </summary>
            <typeparam name="T">Type of objects.</typeparam>
        </member>
        <member name="F:GDX.Collections.Generic.NativeArray3D`1.Array">
            <summary>
                The backing Unity.Collections.NativeArray`1.
            </summary>
        </member>
        <member name="F:GDX.Collections.Generic.NativeArray3D`1.Depth">
            <summary>
                The stride of the z-axis segment in GDX.Collections.Generic.NativeArray3D`1.Array.
            </summary>
        </member>
        <member name="F:GDX.Collections.Generic.NativeArray3D`1.DepthLength">
            <summary>
                The total length of a single GDX.Collections.Generic.NativeArray3D`1.Depth.
            </summary>
        </member>
        <member name="F:GDX.Collections.Generic.NativeArray3D`1.Height">
            <summary>
                The stride of the y-axis segment in GDX.Collections.Generic.NativeArray3D`1.Array.
            </summary>
        </member>
        <member name="F:GDX.Collections.Generic.NativeArray3D`1.Length">
            <summary>
                The length of GDX.Collections.Generic.NativeArray3D`1.Array.
            </summary>
        </member>
        <member name="F:GDX.Collections.Generic.NativeArray3D`1.Width">
            <summary>
                The stride of the x-axis segment in GDX.Collections.Generic.NativeArray3D`1.Array.
            </summary>
        </member>
        <member name="M:GDX.Collections.Generic.NativeArray3D`1.#ctor(System.Int32,System.Int32,System.Int32,Unity.Collections.Allocator,Unity.Collections.NativeArrayOptions)">
            <summary>
                Create a GDX.Collections.Generic.NativeArray3D`1 with a uniform dimensional length.
            </summary>
            <remarks></remarks>
            <param name="width">X-axis length.</param>
            <param name="height">Y-axis length.</param>
            <param name="depth">Z-axis length.</param>
            <param name="allocator">The Unity.Collections.Allocator type to use.</param>
            <param name="nativeArrayOptions">Should the memory be cleared on allocation?</param>
        </member>
        <member name="P:GDX.Collections.Generic.NativeArray3D`1.Item(System.Int32,System.Int32,System.Int32)">
            <summary>
                Access a specific location in the voxel.
            </summary>
            <param name="x">X location index.</param>
            <param name="y">Y location index.</param>
            <param name="z">Z location index.</param>
        </member>
        <member name="P:GDX.Collections.Generic.NativeArray3D`1.Item(Unity.Mathematics.int3)">
            <summary>
                Access a specific location in the voxel.
            </summary>
            <param name="index">A three-dimensional index.</param>
        </member>
        <member name="M:GDX.Collections.Generic.NativeArray3D`1.Dispose">
            <summary>
                Properly dispose of the GDX.Collections.Generic.NativeUniformArray3D`1.
            </summary>
        </member>
        <member name="M:GDX.Collections.Generic.NativeArray3D`1.GetFromIndex(System.Int32)">
            <summary>
                Get the three-dimensional index of a flat array index.
            </summary>
            <param name="index">A flat array index.</param>
            <returns>A three-dimensional voxel index.</returns>
        </member>
        <member name="T:GDX.Collections.Generic.UniformArray3D`1">
            <summary>
                A uniform three-dimensional array.
            </summary>
            <typeparam name="T">Type of objects.</typeparam>
        </member>
        <member name="F:GDX.Collections.Generic.UniformArray3D`1.Array">
            <summary>
                The backing GDX.Collections.Generic.UniformArray3D`1.Array.
            </summary>
        </member>
        <member name="F:GDX.Collections.Generic.UniformArray3D`1.Length">
            <summary>
                The length of GDX.Collections.Generic.UniformArray3D`1.Array.
            </summary>
        </member>
        <member name="F:GDX.Collections.Generic.UniformArray3D`1.Stride">
            <summary>
                The stride of each dimensional segment in GDX.Collections.Generic.UniformArray3D`1.Array.
            </summary>
        </member>
        <member name="F:GDX.Collections.Generic.UniformArray3D`1.StrideSquared">
            <summary>
                Stores a cached copy of the stride squared.
            </summary>
        </member>
        <member name="M:GDX.Collections.Generic.UniformArray3D`1.#ctor(System.Int32)">
            <summary>
                Create a GDX.Collections.Generic.UniformArray3D`1 with a uniform dimensional length.
            </summary>
            <remarks></remarks>
            <param name="stride">X length, Y length and Z length will all be set to this value.</param>
        </member>
        <member name="P:GDX.Collections.Generic.UniformArray3D`1.Item(System.Int32,System.Int32,System.Int32)">
            <summary>
                Access a specific location in the voxel.
            </summary>
            <remarks>x + WIDTH * (y + DEPTH * z)</remarks>
            <param name="x">X location index.</param>
            <param name="y">Y location index.</param>
            <param name="z">Z location index.</param>
        </member>
        <member name="P:GDX.Collections.Generic.UniformArray3D`1.Item(Unity.Mathematics.int3)">
            <summary>
                Access a specific location in the voxel.
            </summary>
            <param name="index">A three-dimensional index.</param>
        </member>
        <member name="M:GDX.Collections.Generic.UniformArray3D`1.Dispose">
            <summary>
                Properly dispose of the GDX.Collections.Generic.UniformArray3D`1.
            </summary>
        </member>
        <member name="M:GDX.Collections.Generic.UniformArray3D`1.GetFromIndex(System.Int32)">
            <summary>
                Get the three-dimensional index of a flat array index.
            </summary>
            <param name="index">A flat array index.</param>
            <returns>A three-dimensional voxel index.</returns>
        </member>
        <member name="M:GDX.Collections.Generic.UniformArray3D`1.GetFromIndex(System.Int32,System.Int32,System.Int32)">
            <summary>
                Get the three-dimensional index of a flat array index.
            </summary>
            <param name="index">A flat array index.</param>
            <param name="stride">The predetermined length of an axis.</param>
            <param name="strideSquared">The squared value of stride.</param>
            <returns>A three-dimensional voxel index.</returns>
        </member>
        <member name="T:GDX.Collections.Generic.Array2D`1">
            <summary>
                A 2-dimensional array backed by a flat array.
            </summary>
            <remarks>Mimics multi-dimensional array format.</remarks>
            <typeparam name="T">Type of objects.</typeparam>
        </member>
        <member name="F:GDX.Collections.Generic.Array2D`1.Array">
            <summary>
                The backing flat array.
            </summary>
        </member>
        <member name="F:GDX.Collections.Generic.Array2D`1.ColumnCount">
            <summary>
                The length of each pseudo-array in the dataset.
            </summary>
            <remarks>CAUTION! Changing this will alter the understanding of the data.</remarks>
        </member>
        <member name="F:GDX.Collections.Generic.Array2D`1.RowCount">
            <summary>
                The number of pseudo-arrays created to support the dimensionality.
            </summary>
            <remarks>CAUTION! Changing this will alter the understanding of the data.</remarks>
        </member>
        <member name="M:GDX.Collections.Generic.Array2D`1.#ctor(System.Int32,System.Int32)">
            <summary>
                Create a GDX.Collections.Generic.Array2D`1.
            </summary>
            <param name="rowCount">The number of rows (X).</param>
            <param name="columnCount">The number of columns (Y).</param>
        </member>
        <member name="M:GDX.Collections.Generic.Array2D`1.#ctor(System.Int32,System.Int32,`0[])">
            <summary>
                Create a GDX.Collections.Generic.Array2D`1 providing an existing arrayToUse.
            </summary>
            <param name="rowCount">The number of rows (X).</param>
            <param name="columnCount">The number of columns (Y).</param>
            <param name="arrayToUse">An existing array to use in the GDX.Collections.Generic.Array2D`1.</param>
        </member>
        <member name="P:GDX.Collections.Generic.Array2D`1.Item(System.Int32,System.Int32)">
            <summary>
                Get a typed object at a specific 2-dimensional index in GDX.Collections.Generic.Array2D`1.Array.
            </summary>
            <param name="x">The row/line number (vertical axis).</param>
            <param name="y">The column number (horizontal axis).</param>
        </member>
        <member name="M:GDX.Collections.Generic.Array2D`1.Dispose">
            <summary>
                Properly dispose of the GDX.Collections.Generic.Array2D`1.
            </summary>
        </member>
        <member name="M:GDX.Collections.Generic.Array2D`1.AddRows(System.Int32)">
            <summary>
                Add additional rows to the dataset.
            </summary>
            <param name="numberOfNewRows">The number of rows/arrays to add.</param>
        </member>
        <member name="M:GDX.Collections.Generic.Array2D`1.AddColumns(System.Int32)">
            <summary>
                Add additional columns to the dataset.
            </summary>
            <param name="numberOfNewColumns">The number of columns add.</param>
        </member>
        <member name="M:GDX.Collections.Generic.Array2D`1.GetColumnIndex(System.Int32)">
            <summary>
            Get the column index of the provided index.
            </summary>
            <param name="index">A valid index contained within GDX.Collections.Generic.Array2D`1.Array.</param>
            <returns>The column index.</returns>
        </member>
        <member name="M:GDX.Collections.Generic.Array2D`1.GetRowIndex(System.Int32)">
            <summary>
            Get the row index of the provided index.
            </summary>
            <param name="index">A valid index contained within GDX.Collections.Generic.Array2D`1.Array.</param>
            <returns>The row index.</returns>
        </member>
        <member name="M:GDX.Collections.Generic.Array2D`1.ReverseColumns">
            <summary>
                Reverse the order of the columns in the backing GDX.Collections.Generic.Array2D`1.Array.
            </summary>
        </member>
        <member name="M:GDX.Collections.Generic.Array2D`1.ReverseRows">
            <summary>
                Reverse the order of the rows in the backing GDX.Collections.Generic.Array2D`1.Array.
            </summary>
        </member>
        <member name="M:GDX.Collections.Generic.Array2D`1.RotateClockwise">
            <summary>
            Rotate internal dataset clockwise.
            </summary>
        </member>
        <member name="M:GDX.Collections.Generic.Array2D`1.RotateCounterClockwise">
            <summary>
            Rotate internal dataset counter-clockwise.
            </summary>
        </member>
        <member name="M:GDX.Collections.Generic.Array2D`1.ToMultiDimensionalArray">
            <summary>
                Creates a copy of the internal array as a traditional multi-dimensional array.
            </summary>
            <remarks>Useful for scenarios where fills need to be done with [,] structured multi-dimensional arrays.</remarks>
            <returns>A new copy of the backing GDX.Collections.Generic.Array2D`1.Array in multi-dimensional form.</returns>
        </member>
        <member name="T:GDX.Collections.Generic.SimpleList`1">
            <summary>
                An optimized System.Collections.Generic.List`1-like data structure.
            </summary>
            <typeparam name="T">The type of the System.Objects contained within.</typeparam>
        </member>
        <member name="F:GDX.Collections.Generic.SimpleList`1.Array">
            <summary>
                Internal array of backed data for the GDX.Collections.Generic.SimpleList`1.
            </summary>
        </member>
        <member name="F:GDX.Collections.Generic.SimpleList`1.Count">
            <summary>
                The current number of occupied elements in the GDX.Collections.Generic.CircularBuffer`1.
            </summary>
            <remarks>CAUTION! Changing this will alter the understanding of the data.</remarks>
        </member>
        <member name="M:GDX.Collections.Generic.SimpleList`1.#ctor(System.Int32)">
            <summary>
                Create a GDX.Collections.Generic.SimpleList`1 with an initial capacity.
            </summary>
            <param name="capacity">An initial sizing for the GDX.Collections.Generic.SimpleList`1.Array.</param>
        </member>
        <member name="M:GDX.Collections.Generic.SimpleList`1.#ctor(`0[])">
            <summary>
                Create a GDX.Collections.Generic.SimpleList`1 providing an existing arrayToUse.
            </summary>
            <param name="arrayToUse">An existing array to use in the GDX.Collections.Generic.SimpleList`1.</param>
        </member>
        <member name="M:GDX.Collections.Generic.SimpleList`1.#ctor(`0[],System.Int32)">
            <summary>
                Create a GDX.Collections.Generic.SimpleList`1 providing an existing arrayToUse and setting the
                GDX.Collections.Generic.SimpleList`1.Count.
            </summary>
            <param name="arrayToUse">An existing array to use in the GDX.Collections.Generic.SimpleList`1.</param>
            <param name="count">An existing element count.</param>
        </member>
        <member name="M:GDX.Collections.Generic.SimpleList`1.AddUnchecked(`0)">
            <summary>
                Add an item to the GDX.Collections.Generic.SimpleList`1 without checking the GDX.Collections.Generic.SimpleList`1.Array size.
            </summary>
            <param name="item">A typed System.Object to add.</param>
        </member>
        <member name="M:GDX.Collections.Generic.SimpleList`1.AddWithExpandCheck(`0)">
            <summary>
                Add an item to the GDX.Collections.Generic.SimpleList`1, checking if GDX.Collections.Generic.SimpleList`1.Array needs to be resized.
            </summary>
            <param name="item">A typed System.Object to add.</param>
        </member>
        <member name="M:GDX.Collections.Generic.SimpleList`1.AddWithExpandCheck(`0,System.Int32)">
            <summary>
                Add an item to the GDX.Collections.Generic.SimpleList`1, checking if GDX.Collections.Generic.SimpleList`1.Array needs to be resized.
            </summary>
            <param name="item">A typed System.Object to add.</param>
            <param name="howMuchToExpand">How much to expand the array by.</param>
        </member>
        <member name="M:GDX.Collections.Generic.SimpleList`1.AddExpandNoClear(`0,GDX.Collections.Pooling.ArrayPool{`0})">
            <summary>
                Add an item to the GDX.Collections.Generic.SimpleList`1, checking if GDX.Collections.Generic.SimpleList`1.Array needs to be resized.
            </summary>
            <param name="item">A typed System.Object to add.</param>
            <param name="pool">Pool to allocate the array from if resizing.</param>
        </member>
        <member name="M:GDX.Collections.Generic.SimpleList`1.AddExpandClearOld(`0,GDX.Collections.Pooling.ArrayPool{`0})">
            <summary>
                Add an item to the GDX.Collections.Generic.SimpleList`1, checking if GDX.Collections.Generic.SimpleList`1.Array needs to be resized. Clears the old array on resize after copying its contents.
            </summary>
            <param name="item">A typed System.Object to add.</param>
            <param name="pool">Pool to allocate the array from if resizing.</param>
        </member>
        <member name="M:GDX.Collections.Generic.SimpleList`1.AddExpandClearNew(`0,GDX.Collections.Pooling.ArrayPool{`0})">
            <summary>
                Add an item to the GDX.Collections.Generic.SimpleList`1, checking if GDX.Collections.Generic.SimpleList`1.Array needs to be resized. Clears unused indices of the new array on resize.
            </summary>
            <param name="item">A typed System.Object to add.</param>
            <param name="pool">Pool to allocate the array from if resizing.</param>
        </member>
        <member name="M:GDX.Collections.Generic.SimpleList`1.AddExpandClearBoth(`0,GDX.Collections.Pooling.ArrayPool{`0})">
            <summary>
                Add an item to the GDX.Collections.Generic.SimpleList`1, checking if GDX.Collections.Generic.SimpleList`1.Array needs to be resized.  Clears old and new arrays on resize.
            </summary>
            <param name="item">A typed System.Object to add.</param>
            <param name="pool">Pool to allocate the array from if resizing.</param>
        </member>
        <member name="M:GDX.Collections.Generic.SimpleList`1.Clear">
            <summary>
                Clear out the GDX.Collections.Generic.SimpleList`1.Array in GDX.Collections.Generic.SimpleList`1 and sets the GDX.Collections.Generic.SimpleList`1.Count to 0.
            </summary>
        </member>
        <member name="M:GDX.Collections.Generic.SimpleList`1.Compact">
            <summary>
                Shrink/compact the backing GDX.Collections.Generic.SimpleList`1.Array so there is no unused space.
            </summary>
        </member>
        <member name="M:GDX.Collections.Generic.SimpleList`1.InsertUnchecked(System.Int32,`0)">
            <summary>
                Insert an item into the GDX.Collections.Generic.SimpleList`1 without checking the GDX.Collections.Generic.SimpleList`1.Array size.
            </summary>
            <param name="item">A typed System.Object to insert.</param>
            <param name="index">The index in GDX.Collections.Generic.SimpleList`1.Array to add the item at.</param>
        </member>
        <member name="M:GDX.Collections.Generic.SimpleList`1.InsertWithExpandCheck(System.Int32,`0)">
            <summary>
                Insert an item into the GDX.Collections.Generic.SimpleList`1, checking if GDX.Collections.Generic.SimpleList`1.Array needs to be resized.
            </summary>
            <param name="item">A typed System.Object to insert.</param>
            <param name="index">The index in GDX.Collections.Generic.SimpleList`1.Array to add the item at.</param>
        </member>
        <member name="M:GDX.Collections.Generic.SimpleList`1.InsertWithExpandCheck(System.Int32,`0,System.Int32)">
            <summary>
                Insert an item into the GDX.Collections.Generic.SimpleList`1, checking if GDX.Collections.Generic.SimpleList`1.Array needs to be resized.
            </summary>
            <param name="item">A typed System.Object to insert.</param>
            <param name="index">The index in GDX.Collections.Generic.SimpleList`1.Array to add the item at.</param>
            <param name="howMuchToExpand">The number of elements to add at the end of the array when expanding.</param>
        </member>
        <member name="M:GDX.Collections.Generic.SimpleList`1.InsertExpandNoClear(System.Int32,`0,GDX.Collections.Pooling.ArrayPool{`0})">
            <summary>
                Insert an item into the GDX.Collections.Generic.SimpleList`1, checking if GDX.Collections.Generic.SimpleList`1.Array needs to be resized.
            </summary>
            <param name="item">A typed System.Object to insert.</param>
            <param name="index">The index in GDX.Collections.Generic.SimpleList`1.Array to add the item at.</param>
            <param name="pool">Pool to allocate the array from if resizing.</param>
        </member>
        <member name="M:GDX.Collections.Generic.SimpleList`1.InsertExpandClearOld(System.Int32,`0,GDX.Collections.Pooling.ArrayPool{`0})">
            <summary>
                Insert an item into the GDX.Collections.Generic.SimpleList`1, checking if GDX.Collections.Generic.SimpleList`1.Array needs to be resized. Clears the old array on resize after copying its contents.
            </summary>
            <param name="item">A typed System.Object to insert.</param>
            <param name="index">The index in GDX.Collections.Generic.SimpleList`1.Array to add the item at.</param>
            <param name="pool">Pool to allocate the array from if resizing.</param>
        </member>
        <member name="M:GDX.Collections.Generic.SimpleList`1.InsertExpandClearNew(System.Int32,`0,GDX.Collections.Pooling.ArrayPool{`0})">
            <summary>
                Insert an item into the GDX.Collections.Generic.SimpleList`1, checking if GDX.Collections.Generic.SimpleList`1.Array needs to be resized. Clears unused indices of the new array on resize.
            </summary>
            <param name="item">A typed System.Object to insert.</param>
            <param name="index">The index in GDX.Collections.Generic.SimpleList`1.Array to add the item at.</param>
            <param name="pool">Pool to allocate the array from if resizing.</param>
        </member>
        <member name="M:GDX.Collections.Generic.SimpleList`1.InsertExpandClearBoth(System.Int32,`0,GDX.Collections.Pooling.ArrayPool{`0})">
            <summary>
                Insert an item into the GDX.Collections.Generic.SimpleList`1, checking if GDX.Collections.Generic.SimpleList`1.Array needs to be resized. Clears old and new arrays on resize.
            </summary>
            <param name="item">A typed System.Object to insert.</param>
            <param name="index">The index in GDX.Collections.Generic.SimpleList`1.Array to add the item at.</param>
            <param name="pool">Pool to allocate the array from if resizing.</param>
        </member>
        <member name="M:GDX.Collections.Generic.SimpleList`1.RemoveAt(System.Int32)">
            <summary>
                Remove an item from the GDX.Collections.Generic.SimpleList`1 at a specific index.
            </summary>
            <param name="index">The target index.</param>
        </member>
        <member name="M:GDX.Collections.Generic.SimpleList`1.RemoveAtSwapBack(System.Int32)">
            <summary>
                Remove an item from the GDX.Collections.Generic.SimpleList`1 at a specific index, swapping it with the item from the highest used index.
            </summary>
            <param name="index">The target index.</param>
        </member>
        <member name="M:GDX.Collections.Generic.SimpleList`1.RemoveFromBack">
            <summary>
                Remove the last element in the GDX.Collections.Generic.SimpleList`1.
            </summary>
        </member>
        <member name="M:GDX.Collections.Generic.SimpleList`1.Reserve(System.Int32)">
            <summary>
                Resizes the GDX.Collections.Generic.SimpleList`1.Array, ensuring there are the provided number of empty spots in it.
            </summary>
            <param name="numberToReserve">Number of desired empty spots.</param>
        </member>
        <member name="M:GDX.Collections.Generic.SimpleList`1.ReserveNoClear(System.Int32,GDX.Collections.Pooling.ArrayPool{`0})">
            <summary>
                Resizes the GDX.Collections.Generic.SimpleList`1.Array, ensuring there are the provided number of empty spots in it.
            </summary>
            <param name="numberToReserve">Number of desired empty spots.</param>
            <param name="pool">Pool to allocate the array from if resizing.</param>
        </member>
        <member name="M:GDX.Collections.Generic.SimpleList`1.ReserveClearOld(System.Int32,GDX.Collections.Pooling.ArrayPool{`0})">
            <summary>
                Resizes the GDX.Collections.Generic.SimpleList`1.Array, ensuring there are the provided number of empty spots in it. Clears the old array on resize after copying its contents.
            </summary>
            <param name="numberToReserve">Number of desired empty spots.</param>
            <param name="pool">Pool to allocate the array from if resizing.</param>
        </member>
        <member name="M:GDX.Collections.Generic.SimpleList`1.ReserveClearNew(System.Int32,GDX.Collections.Pooling.ArrayPool{`0})">
            <summary>
                Resizes the GDX.Collections.Generic.SimpleList`1.Array, ensuring there are the provided number of empty spots in it.  Clears unused indices of the new array on resize.
            </summary>
            <param name="numberToReserve">Number of desired empty spots.</param>
            <param name="pool">Pool to allocate the array from if resizing.</param>
        </member>
        <member name="M:GDX.Collections.Generic.SimpleList`1.ReserveClearBoth(System.Int32,GDX.Collections.Pooling.ArrayPool{`0})">
            <summary>
                Resizes the GDX.Collections.Generic.SimpleList`1.Array, ensuring there are the provided number of empty spots in it. Clears old and new arrays on resize.
            </summary>
            <param name="numberToReserve">Number of desired empty spots.</param>
            <param name="pool">Pool to allocate the array from if resizing.</param>
        </member>
        <member name="M:GDX.Collections.Generic.SimpleList`1.Reverse">
            <summary>
                Reverse the order of GDX.Collections.Generic.SimpleList`1.Array.
            </summary>
        </member>
        <member name="T:GDX.Collections.Generic.NativeUniformArray3D`1">
            <summary>
                A three-dimensional Unity.Collections.NativeArray`1 backed array.
            </summary>
            <typeparam name="T">Type of objects.</typeparam>
        </member>
        <member name="F:GDX.Collections.Generic.NativeUniformArray3D`1.Array">
            <summary>
                The backing Unity.Collections.NativeArray`1.
            </summary>
        </member>
        <member name="F:GDX.Collections.Generic.NativeUniformArray3D`1.Length">
            <summary>
                The length of GDX.Collections.Generic.NativeUniformArray3D`1.Array.
            </summary>
        </member>
        <member name="F:GDX.Collections.Generic.NativeUniformArray3D`1.Stride">
            <summary>
                The stride of each dimensional segment in GDX.Collections.Generic.NativeUniformArray3D`1.Array.
            </summary>
        </member>
        <member name="F:GDX.Collections.Generic.NativeUniformArray3D`1.StrideSquared">
            <summary>
                Stores a cached copy of the stride squared.
            </summary>
        </member>
        <member name="M:GDX.Collections.Generic.NativeUniformArray3D`1.#ctor(System.Int32,Unity.Collections.Allocator,Unity.Collections.NativeArrayOptions)">
            <summary>
                Create a GDX.Collections.Generic.NativeUniformArray3D`1 with a uniform dimensional length.
            </summary>
            <remarks></remarks>
            <param name="stride">X length, Y length and Z length will all be set to this value.</param>
            <param name="allocator">The Unity.Collections.Allocator type to use.</param>
            <param name="nativeArrayOptions">Should the memory be cleared on allocation?</param>
        </member>
        <member name="P:GDX.Collections.Generic.NativeUniformArray3D`1.Item(System.Int32,System.Int32,System.Int32)">
            <summary>
                Access a specific location in the voxel.
            </summary>
            <param name="x">X location index.</param>
            <param name="y">Y location index.</param>
            <param name="z">Z location index.</param>
        </member>
        <member name="P:GDX.Collections.Generic.NativeUniformArray3D`1.Item(Unity.Mathematics.int3)">
            <summary>
                Access a specific location in the voxel.
            </summary>
            <param name="index">A 3-Dimensional index.</param>
        </member>
        <member name="M:GDX.Collections.Generic.NativeUniformArray3D`1.Dispose">
            <summary>
                Properly dispose of the GDX.Collections.Generic.NativeUniformArray3D`1.
            </summary>
        </member>
        <member name="M:GDX.Collections.Generic.NativeUniformArray3D`1.GetFromIndex(System.Int32)">
            <summary>
                Get the three-dimensional index of a flat array index.
            </summary>
            <param name="index">A flat array index.</param>
            <returns>A three-dimensional voxel index.</returns>
        </member>
        <member name="T:GDX.Collections.Generic.StringKeyDictionary`1">
            <summary>
                An optimized System.Collections.Generic.Dictionary`2-like data structure with a
                System.String key requirement.
            </summary>
        </member>
        <member name="M:GDX.Collections.Generic.StringKeyDictionary`1.#ctor(System.Int32)">
            <summary>
            Initializes the dictionary with at least minCapacity capacity.
            </summary>
            <param name="minCapacity">The minimal initial capacity to reserve.</param>
        </member>
        <member name="M:GDX.Collections.Generic.StringKeyDictionary`1.AddWithExpandCheck(System.String,`0)">
            <summary>
            Adds the key value pair to the dictionary, expanding if necessary but not checking for duplicate entries.
            </summary>
            <param name="key">The key to add.</param>
            <param name="value">The value to add.</param>
        </member>
        <member name="M:GDX.Collections.Generic.StringKeyDictionary`1.AddWithUniqueCheck(System.String,`0)">
            <summary>
            Adds the key value pair to the dictionary, checking for duplicates but not expanding if necessary.
            </summary>
            <param name="key">The key to add.</param>
            <param name="value">The value to add.</param>
            <returns>True if the entry was successfully created.</returns>
        </member>
        <member name="M:GDX.Collections.Generic.StringKeyDictionary`1.AddSafe(System.String,`0)">
            <summary>
            Adds the key value pair to the dictionary, checking for duplicate entries and expanding if necessary.
            </summary>
            <param name="key">The key to add.</param>
            <param name="value">The value to add.</param>
            <returns>True if the entry was successfully created.</returns>
        </member>
        <member name="M:GDX.Collections.Generic.StringKeyDictionary`1.AddUnchecked(System.String,`0)">
            <summary>
            Adds the key value pair to the dictionary, without checking for available capacity or duplicate entries.
            </summary>
            <param name="key">The key to add.</param>
            <param name="value">The value to add.</param>
        </member>
        <member name="M:GDX.Collections.Generic.StringKeyDictionary`1.ContainsKey(System.String)">
            <summary>
            Checks if the dictionary contains the given key.
            </summary>
            <param name="key">The key to check for.</param>
            <returns>True if the dictionary contains the key.</returns>
        </member>
        <member name="M:GDX.Collections.Generic.StringKeyDictionary`1.ExpandWhenFull">
            <summary>
            Resizes the dictionary with the assumption that it is full. Do not use otherwise.
            </summary>
        </member>
        <member name="M:GDX.Collections.Generic.StringKeyDictionary`1.Reserve(System.Int32)">
            <summary>
            Expands the dictionary if it does not have enough empty space for capacityToReserve.
            </summary>
            <param name="capacityToReserve"></param>
        </member>
        <member name="M:GDX.Collections.Generic.StringKeyDictionary`1.IndexOf(System.String)">
            <summary>
            Finds the index of the entry corresponding to a key.
            </summary>
            <param name="key">The key to find the index of.</param>
            <returns>The index of the entry, or -1 if the entry does not exist.</returns>
        </member>
        <member name="M:GDX.Collections.Generic.StringKeyDictionary`1.TryModifyValue(System.String,`0)">
            <summary>
            Replaces the value of the entry if the entry exists.
            </summary>
            <param name="key">The key of the entry to modify.</param>
            <param name="value">The new value of the entry.</param>
            <returns>True if the entry was found.</returns>
        </member>
        <member name="M:GDX.Collections.Generic.StringKeyDictionary`1.TryRemove(System.String)">
            <summary>
            Removes the entry if it exists.
            </summary>
            <param name="key">The key to remove.</param>
            <returns>True if the entry was found.</returns>
        </member>
        <member name="M:GDX.Collections.Generic.StringKeyDictionary`1.TryRemoveNoValueClear(System.String)">
            <summary>
            Removes the entry if it exists, but does not remove the value of the key value pair.
            </summary>
            <param name="key">The key to remove.</param>
            <returns>True if the entry was found.</returns>
        </member>
        <member name="M:GDX.Collections.Generic.StringKeyDictionary`1.TryGetValue(System.String,`0@)">
            <summary>
            Attempts to get the value for the given key; returns true if key was found, false otherwise.
            </summary>
            <param name="key">The key to retrieve.</param>
            <param name="value">The value of the entry found.</param>
            <returns>True if the entry was found; false otherwise.</returns>
        </member>
        <member name="P:GDX.Collections.Generic.StringKeyDictionary`1.Item(System.String)">
            <summary>
                Directly access a value by key.
            </summary>
            <param name="key">The target key to look for a value identified by.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when a null key is provided to lookup.</exception>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown when the key is not found in the GDX.Collections.Generic.StringKeyDictionary`1.</exception>
        </member>
        <member name="M:GDX.Collections.Generic.StringKeyDictionary`1.MoveNext(System.Int32@,System.Int32,System.Int32@,GDX.Collections.Generic.StringKeyEntry{`0}@)">
            <summary>
            Iterates the dictionary.
            </summary>
            <param name="iteratedIndexCount">The number of indices iterated so far - pass in 0 at the start of iteration.</param>
            <param name="iteratorVersion">The version when iteration started.</param>
            <param name="dictionaryVersion">The current version of the dictionary - update this on add, remove, or clear operations.</param>
            <param name="entry">The entry returned by the iterator</param>
            <returns>Whether the iterator found an entry, finished iteration, or could not continue due to an invalid version.</returns>
        </member>
        <member name="M:GDX.Collections.Generic.StringKeyDictionary`1.MoveNext(System.Int32@,GDX.Collections.Generic.StringKeyEntry{`0}@)">
            <summary>
            Iterates the dictionary.
            NOTE: if you suspect the dictionary might be modified while iterating, this will not catch the error -- use the other overload instead.
            </summary>
            <param name="iteratedIndexCount">The number of indices iterated so far - pass in 0 at the start of iteration.</param>
            <param name="entry">The entry returned by the iterator</param>
            <returns>Whether or not the iterator found an entry</returns>
        </member>
        <member name="M:GDX.Collections.Generic.StringKeyDictionary`1.MoveNext(System.Int32@)">
            <summary>
            Iterates the dictionary.
            NOTE: if you suspect the dictionary might be modified while iterating, this will not catch the error -- use the other overload instead.
            </summary>
            <param name="iteratedIndexCount">The number of indices iterated so far - pass in 0 at the start of iteration.</param>
            <returns>Whether or not the iterator found an entry</returns>
        </member>
        <member name="M:GDX.Collections.Generic.StringKeyDictionary`1.Clear">
            <summary>
            Clears the dictionary.
            </summary>
        </member>
        <member name="T:GDX.Collections.Generic.IteratorState">
            <summary>
                State of Iterator
            </summary>
        </member>
        <member name="F:GDX.Collections.Generic.IteratorState.Finished">
            <summary>
                Unable to iterate any further.
            </summary>
        </member>
        <member name="F:GDX.Collections.Generic.IteratorState.FoundEntry">
            <summary>
                Found an entry meeting criteria.
            </summary>
        </member>
        <member name="F:GDX.Collections.Generic.IteratorState.InvalidVersion">
            <summary>
                The data being iterated over has changed.
            </summary>
        </member>
        <member name="T:GDX.Collections.Generic.CircularBuffer`1">
            <summary>
                A sized buffer which loops back over itself as elements are used.
            </summary>
            <typeparam name="T">The type of System.Objects contained within.</typeparam>
        </member>
        <member name="F:GDX.Collections.Generic.CircularBuffer`1.Array">
            <summary>
                Internal array of backed data for the GDX.Collections.Generic.CircularBuffer`1.
            </summary>
        </member>
        <member name="F:GDX.Collections.Generic.CircularBuffer`1.Capacity">
            <summary>
                The cached array length for GDX.Collections.Generic.CircularBuffer`1.Array.
            </summary>
        </member>
        <member name="F:GDX.Collections.Generic.CircularBuffer`1.Count">
            <summary>
                The current size of occupied elements in the GDX.Collections.Generic.CircularBuffer`1.
            </summary>
            <remarks>CAUTION! Changing this will alter the understanding of the data.</remarks>
        </member>
        <member name="F:GDX.Collections.Generic.CircularBuffer`1.EndIndex">
            <summary>
                The index of the last item in GDX.Collections.Generic.CircularBuffer`1.Array.
            </summary>
            <remarks>CAUTION! Changing this will alter the understanding of the data.</remarks>
        </member>
        <member name="F:GDX.Collections.Generic.CircularBuffer`1.StartIndex">
            <summary>
                The index of the first item in GDX.Collections.Generic.CircularBuffer`1.Array.
            </summary>
            <remarks>CAUTION! Changing this will alter the understanding of the data.</remarks>
        </member>
        <member name="M:GDX.Collections.Generic.CircularBuffer`1.#ctor(System.Int32)">
            <summary>
                Create a GDX.Collections.Generic.CircularBuffer`1 with a capacity.
            </summary>
            <param name="capacity">The maximum number of items allowed in the GDX.Collections.Generic.CircularBuffer`1</param>
        </member>
        <member name="M:GDX.Collections.Generic.CircularBuffer`1.#ctor(System.Int32,`0[])">
            <summary>
                Create a GDX.Collections.Generic.CircularBuffer`1 with a capacity, filling with
                targetItems.
            </summary>
            <param name="capacity">The maximum number of items allowed in the GDX.Collections.Generic.CircularBuffer`1</param>
            <param name="targetItems">An array of values to fill the GDX.Collections.Generic.CircularBuffer`1 with.</param>
            <exception cref="T:System.ArgumentException">
                Invalid number of entries provided to the GDX.Collections.Generic.CircularBuffer`1
                constructor.
            </exception>
            <exception cref="T:System.ArgumentNullException">No items were provided to the GDX.Collections.Generic.CircularBuffer`1 constructor.</exception>
        </member>
        <member name="P:GDX.Collections.Generic.CircularBuffer`1.Item(System.Int32)">
            <summary>
                Access item at pseudoIndex.
            </summary>
            <param name="pseudoIndex"></param>
            <exception cref="T:System.IndexOutOfRangeException">Provided index is out of buffers range.</exception>
        </member>
        <member name="M:GDX.Collections.Generic.CircularBuffer`1.Add(`0)">
            <summary>
                Add an item to the GDX.Collections.Generic.CircularBuffer`1.Array.
            </summary>
            <param name="item">The typed System.Object to add.</param>
        </member>
        <member name="M:GDX.Collections.Generic.CircularBuffer`1.Clear">
            <summary>
                Clear all values of the GDX.Collections.Generic.CircularBuffer`1.Array.
            </summary>
        </member>
        <member name="M:GDX.Collections.Generic.CircularBuffer`1.GetBack">
            <summary>
                Get the last item in the GDX.Collections.Generic.CircularBuffer`1.Array.
            </summary>
            <returns>The last typed object in GDX.Collections.Generic.CircularBuffer`1.Array.</returns>
        </member>
        <member name="M:GDX.Collections.Generic.CircularBuffer`1.GetFront">
            <summary>
                Get the first item in the GDX.Collections.Generic.CircularBuffer`1.Array.
            </summary>
            <returns>The first typed object in GDX.Collections.Generic.CircularBuffer`1.Array.</returns>
        </member>
        <member name="M:GDX.Collections.Generic.CircularBuffer`1.IsEmpty">
            <summary>
                Does the GDX.Collections.Generic.CircularBuffer`1.Array have any items in it?
            </summary>
            <returns>true/false</returns>
        </member>
        <member name="M:GDX.Collections.Generic.CircularBuffer`1.IsFull">
            <summary>
                Is the GDX.Collections.Generic.CircularBuffer`1.Array at capacity?
            </summary>
            <returns>true/false</returns>
        </member>
        <member name="M:GDX.Collections.Generic.CircularBuffer`1.PopBack">
            <summary>
                Remove an item from the end of the GDX.Collections.Generic.CircularBuffer`1.Array.
            </summary>
        </member>
        <member name="M:GDX.Collections.Generic.CircularBuffer`1.PopFront">
            <summary>
                Remove an item from the start of the GDX.Collections.Generic.CircularBuffer`1.Array.
            </summary>
        </member>
        <member name="M:GDX.Collections.Generic.CircularBuffer`1.PushBack(`0)">
            <summary>
                Add an item to the end of the GDX.Collections.Generic.CircularBuffer`1.Array.
            </summary>
            <param name="targetItem">The item to add to the end of GDX.Collections.Generic.CircularBuffer`1.Array.</param>
        </member>
        <member name="M:GDX.Collections.Generic.CircularBuffer`1.PushFront(`0)">
            <summary>
                Add an item to the start of the GDX.Collections.Generic.CircularBuffer`1.Array.
            </summary>
            <param name="targetItem">The item to add to the start of GDX.Collections.Generic.CircularBuffer`1.Array.</param>
        </member>
        <member name="M:GDX.Collections.Generic.CircularBuffer`1.ToArray">
            <summary>
                Copy GDX.Collections.Generic.CircularBuffer`1.Array to an array of the same type.
            </summary>
            <returns>A copied version of the GDX.Collections.Generic.CircularBuffer`1.Array as an array.</returns>
        </member>
        <member name="T:GDX.Collections.BitArray8">
            <summary>
                A 8-bit array.
            </summary>
            <example>
                Useful for packing a bunch of data with known indices tightly.
                <code>
                    if(myBitArray8[1])
                    {
                        BeAwesome();
                    }
                </code>
            </example>
        </member>
        <member name="F:GDX.Collections.BitArray8.Bits0">
            <summary>
                First reserved System.Byte memory block (8-bits).
            </summary>
            <remarks>Indices 0-7</remarks>
        </member>
        <member name="M:GDX.Collections.BitArray8.#ctor(System.Byte)">
            <summary>
                Create a new GDX.Collections.BitArray8 based on provided bits0.
            </summary>
            <param name="bits0">An existing value to be used to create the backing data for a GDX.Collections.BitArray8</param>
        </member>
        <member name="P:GDX.Collections.BitArray8.Item(System.Byte)">
            <summary>
                Access bit in array.
            </summary>
            <param name="index">Target bit index.</param>
        </member>
        <member name="T:GDX.Collections.BitArray16">
            <summary>
                A 16-bit array.
            </summary>
            <example>
                Useful for packing a bunch of data with known indices tightly.
                <code>
                    if(myBitArray16[1])
                    {
                        BeAwesome();
                    }
                </code>
            </example>
        </member>
        <member name="F:GDX.Collections.BitArray16.Bits0">
            <summary>
                First reserved System.UInt16 memory block (16-bits).
            </summary>
            <remarks>Indices 0-15</remarks>
        </member>
        <member name="M:GDX.Collections.BitArray16.#ctor(System.UInt16)">
            <summary>
                Create a new GDX.Collections.BitArray16 based on provided bits0.
            </summary>
            <param name="bits0">An existing value to be used to create the backing data for a GDX.Collections.BitArray16</param>
        </member>
        <member name="P:GDX.Collections.BitArray16.Item(System.Byte)">
            <summary>
                Access bit in array.
            </summary>
            <param name="index">Target bit index.</param>
        </member>
        <member name="T:GDX.Collections.BitArray256">
            <summary>
                A 256-bit array.
            </summary>
            <example>
                Useful for packing a bunch of data with known indices tightly.
                <code>
                    if(myBitArray256[1])
                    {
                        BeAwesome();
                    }
                </code>
            </example>
        </member>
        <member name="F:GDX.Collections.BitArray256.Bits0">
            <summary>
                First reserved System.Int32 memory block.
            </summary>
            <remarks>Indices 0-31</remarks>
        </member>
        <member name="F:GDX.Collections.BitArray256.Bits1">
            <summary>
                Second reserved System.Int32 memory block.
            </summary>
            <remarks>Indices 32-63</remarks>
        </member>
        <member name="F:GDX.Collections.BitArray256.Bits2">
            <summary>
                Third reserved System.Int32 memory block.
            </summary>
            <remarks>Indices 64-95</remarks>
        </member>
        <member name="F:GDX.Collections.BitArray256.Bits3">
            <summary>
                Fourth reserved System.Int32 memory block.
            </summary>
            <remarks>Indices 96-127</remarks>
        </member>
        <member name="F:GDX.Collections.BitArray256.Bits4">
            <summary>
                Fifth reserved System.Int32 memory block.
            </summary>
            <remarks>Indices 128-159</remarks>
        </member>
        <member name="F:GDX.Collections.BitArray256.Bits5">
            <summary>
                Sixth reserved System.Int32 memory block.
            </summary>
            <remarks>Indices 160-191</remarks>
        </member>
        <member name="F:GDX.Collections.BitArray256.Bits6">
            <summary>
                Seventh reserved System.Int32 memory block.
            </summary>
            <remarks>Indices 192-223</remarks>
        </member>
        <member name="F:GDX.Collections.BitArray256.Bits7">
            <summary>
                Eighth reserved System.Int32 memory block.
            </summary>
            <remarks>Indices 224-255</remarks>
        </member>
        <member name="P:GDX.Collections.BitArray256.Item(System.Int32)">
            <summary>
                Access bit in array.
            </summary>
            <param name="index">Target bit index.</param>
        </member>
        <member name="T:GDX.Collections.Pooling.SimpleListManagedPool">
            <summary>
                A System.Object GDX.Collections.Generic.SimpleList`1 backed pool implementation.
            </summary>
        </member>
        <member name="F:GDX.Collections.Pooling.SimpleListManagedPool.k_AllowCreateMoreFlag">
            <summary>
                The GDX.Collections.Pooling.SimpleListManagedPool.Flags index used to determine if the GDX.Collections.Pooling.SimpleListManagedPool is able to create
                more items as necessary.
            </summary>
        </member>
        <member name="F:GDX.Collections.Pooling.SimpleListManagedPool.k_AllowManagedTeardownFlag">
            <summary>
                The GDX.Collections.Pooling.SimpleListManagedPool.Flags index used to if GDX.Collections.Pooling.SimpleListManagedPool.TearDown can be called by a manager.
            </summary>
        </member>
        <member name="F:GDX.Collections.Pooling.SimpleListManagedPool.k_AllowReuseFlag">
            <summary>
                The GDX.Collections.Pooling.SimpleListManagedPool.Flags index used to determine if items should be reused when the pool is starved.
            </summary>
        </member>
        <member name="F:GDX.Collections.Pooling.SimpleListManagedPool.k_PrewarmPoolFlag">
            <summary>
                The GDX.Collections.Pooling.SimpleListManagedPool.Flags index used to determine if the pool should create items during its constructor.
            </summary>
        </member>
        <member name="F:GDX.Collections.Pooling.SimpleListManagedPool.m_CreateItemFunc">
            <summary>
                A defined function to create items for the pool.
            </summary>
        </member>
        <member name="F:GDX.Collections.Pooling.SimpleListManagedPool.m_Key">
            <summary>
                The absolutely unique identifier for this pool.
            </summary>
        </member>
        <member name="F:GDX.Collections.Pooling.SimpleListManagedPool.m_MaximumObjects">
            <summary>
                The Maximum number of objects to be managed by the pool.
            </summary>
        </member>
        <member name="F:GDX.Collections.Pooling.SimpleListManagedPool.m_MinimumObjects">
            <summary>
                The minimum number of objects to be managed by the pool.
            </summary>
        </member>
        <member name="F:GDX.Collections.Pooling.SimpleListManagedPool.m_OutItems">
            <summary>
                A collection of items that are currently considered out of the pool, that have been spawned.
            </summary>
        </member>
        <member name="F:GDX.Collections.Pooling.SimpleListManagedPool.InCachedCount">
            <summary>
                A cached count of the number of items contained in GDX.Collections.Pooling.SimpleListManagedPool.InItems.
            </summary>
        </member>
        <member name="F:GDX.Collections.Pooling.SimpleListManagedPool.OutCachedCount">
            <summary>
                A cached count of the number of items contained in GDX.Collections.Pooling.SimpleListManagedPool.m_OutItems.
            </summary>
        </member>
        <member name="F:GDX.Collections.Pooling.SimpleListManagedPool.BaseObject">
            <summary>
                The object which the pool is based off of, used as a model when creating new items.
            </summary>
        </member>
        <member name="F:GDX.Collections.Pooling.SimpleListManagedPool.ContainerObject">
            <summary>
                The object which serves as a container for all objects of the pool.
            </summary>
            <remarks>Used more by implementations of pools, then this base class.</remarks>
        </member>
        <member name="F:GDX.Collections.Pooling.SimpleListManagedPool.destroyedItem">
            <summary>
                An <c>event</c> invoked when an item is destroyed by the GDX.Collections.Pooling.SimpleListManagedPool.
            </summary>
        </member>
        <member name="F:GDX.Collections.Pooling.SimpleListManagedPool.InItems">
            <summary>
                A collection of items that are currently contained in the pool for use when spawning items upon request.
            </summary>
        </member>
        <member name="F:GDX.Collections.Pooling.SimpleListManagedPool.Flags">
            <summary>
                A GDX.Collections.BitArray8 used to store pool based flags, as well as provide additional spots for implementations.
            </summary>
            <remarks>
                Index 0-3 (GDX.Collections.Pooling.SimpleListManagedPool.k_AllowCreateMoreFlag, GDX.Collections.Pooling.SimpleListManagedPool.k_AllowManagedTeardownFlag,
                GDX.Collections.Pooling.SimpleListManagedPool.k_AllowReuseFlag, and GDX.Collections.Pooling.SimpleListManagedPool.k_PrewarmPoolFlag) are used by the
                GDX.Collections.Pooling.SimpleListManagedPool itself, leaving 4-7 for additional use.
            </remarks>
        </member>
        <member name="F:GDX.Collections.Pooling.SimpleListManagedPool.returnedItem">
            <summary>
                An <c>event</c> invoked when an item is returned to the GDX.Collections.Pooling.SimpleListManagedPool.
            </summary>
        </member>
        <member name="F:GDX.Collections.Pooling.SimpleListManagedPool.spawnedItem">
            <summary>
                An <c>event</c> invoked when an item is spawned from the GDX.Collections.Pooling.SimpleListManagedPool.
            </summary>
        </member>
        <member name="F:GDX.Collections.Pooling.SimpleListManagedPool.tearingDown">
            <summary>
                An <c>event</c> invoked when a pool is tearing down, before the items are pooled.
            </summary>
        </member>
        <member name="M:GDX.Collections.Pooling.SimpleListManagedPool.#ctor(System.Object,System.Func{GDX.Collections.Pooling.SimpleListManagedPool,System.Object},System.Int32,System.Int32,System.Object,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
                Create a GDX.Collections.Pooling.SimpleListManagedPool.
            </summary>
            <param name="baseObject">The object which going to be cloned.</param>
            <param name="createItemFunc">The function used to create new items for the pool.</param>
            <param name="minimumObjects">The minimum number of objects to be managed by the pool.</param>
            <param name="maximumObjects">The maximum number of objects to be managed by the pool.</param>
            <param name="containerObject">A reference to an object which should be used as the container for created items.</param>
            <param name="prewarmPool">Should this pool create its items during the constructor?</param>
            <param name="allowCreateMore">Can more items be created as needed when starved for items?</param>
            <param name="allowReuseWhenCapped">Should we reuse oldest items when starving for items?</param>
            <param name="allowManagedTearDown">Does the pool allow a managed tear down event call?</param>
        </member>
        <member name="M:GDX.Collections.Pooling.SimpleListManagedPool.CreateItem">
            <inheritdoc />
        </member>
        <member name="M:GDX.Collections.Pooling.SimpleListManagedPool.ForceRemove(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:GDX.Collections.Pooling.SimpleListManagedPool.Get(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:GDX.Collections.Pooling.SimpleListManagedPool.GetBaseObject">
            <inheritdoc />
        </member>
        <member name="M:GDX.Collections.Pooling.SimpleListManagedPool.GetKey">
            <inheritdoc />
        </member>
        <member name="M:GDX.Collections.Pooling.SimpleListManagedPool.HasMinimumPooledItems">
            <inheritdoc />
        </member>
        <member name="M:GDX.Collections.Pooling.SimpleListManagedPool.IsAllowedManagedTearDown">
            <inheritdoc />
        </member>
        <member name="M:GDX.Collections.Pooling.SimpleListManagedPool.IsManaged(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:GDX.Collections.Pooling.SimpleListManagedPool.IsPooled(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:GDX.Collections.Pooling.SimpleListManagedPool.Return(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:GDX.Collections.Pooling.SimpleListManagedPool.ReturnAll(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:GDX.Collections.Pooling.SimpleListManagedPool.TearDown">
            <inheritdoc />
        </member>
        <member name="M:GDX.Collections.Pooling.SimpleListManagedPool.Finalize">
            <summary>
                The GDX.Collections.Pooling.SimpleListManagedPool destructor which unregisters itself from GDX.Collections.Pooling.ManagedPools.
            </summary>
        </member>
        <member name="T:GDX.Collections.Pooling.ArrayPool`1">
            <summary>
                An object pool for arrays with power-of-two lengths.
            </summary>
            <typeparam name="T">The data type contained by pooled arrays.</typeparam>
        </member>
        <member name="M:GDX.Collections.Pooling.ArrayPool`1.#ctor(System.Int32[],System.Int32[])">
            <summary>
                Initialize the array pool with initial and maximum sizes for each power-of-two, 0 through 30 inclusive (the maximum
                power-of-two length supported in C#).
            </summary>
            <param name="initialPoolCounts"></param>
            <param name="maxPoolCapacities"></param>
        </member>
        <member name="M:GDX.Collections.Pooling.ArrayPool`1.Get(System.Int32)">
            <summary>
                Allocates an array from the pool. Finds an array of the smallest power-of-two length larger than or equal to the
                requested size.
            </summary>
            <param name="requestedSize">
                The desired array length. The returned array will be the smallest power-of-two larger than
                or equal to this size.
            </param>
            <returns></returns>
        </member>
        <member name="M:GDX.Collections.Pooling.ArrayPool`1.Return(`0[])">
            <summary>
                Return a power-of-two sized array to the pool. Only pass power-of-two sized arrays to this function. Does not clear
                the array.
            </summary>
            <param name="array">The power-of-two sized array to return to the pool. Power-of-two sizes only.</param>
        </member>
        <member name="T:GDX.Collections.Pooling.IManagedPool">
            <summary>
                An interface describing the functionality needed for a pool to be understood by GDX.Collections.Pooling.ManagedPools.
            </summary>
        </member>
        <member name="M:GDX.Collections.Pooling.IManagedPool.CreateItem">
            <summary>
                Create a pooled item and add it to the GDX.Collections.Pooling.IManagedPool.
            </summary>
        </member>
        <member name="M:GDX.Collections.Pooling.IManagedPool.ForceRemove(System.Object)">
            <summary>
                Remove an item from an GDX.Collections.Pooling.IManagedPool immediately, removing it from tracking and
                not calling any actions on it.
            </summary>
            <param name="item">The target System.Object to attempt to remove.</param>
        </member>
        <member name="M:GDX.Collections.Pooling.IManagedPool.Get(System.Boolean)">
            <summary>
                Get the next available item from an GDX.Collections.Pooling.IManagedPool.
            </summary>
            <returns>An item if available, otherwise null.</returns>
        </member>
        <member name="M:GDX.Collections.Pooling.IManagedPool.GetBaseObject">
            <summary>
                Return the System.Object which the pool is built from.
            </summary>
            <returns>The System.Object the GDX.Collections.Pooling.IManagedPool is modelled around.</returns>
        </member>
        <member name="M:GDX.Collections.Pooling.IManagedPool.GetKey">
            <summary>
                Get the unique identifier for the GDX.Collections.Pooling.IManagedPool.
            </summary>
            <returns>A unique identifier.</returns>
        </member>
        <member name="M:GDX.Collections.Pooling.IManagedPool.HasMinimumPooledItems">
            <summary>
                Does the GDX.Collections.Pooling.IManagedPool contain the minimum number of items.
            </summary>
            <returns>true/false if enough items are found contained in the GDX.Collections.Pooling.IManagedPool.</returns>
        </member>
        <member name="M:GDX.Collections.Pooling.IManagedPool.IsAllowedManagedTearDown">
            <summary>
                Should theGDX.Collections.Pooling.IManagedPool destroy itself when GDX.Collections.Pooling.ManagedPools requests a tear down?
            </summary>
            <returns>true/false if flagged to allow for managed tear down / clean up.</returns>
        </member>
        <member name="M:GDX.Collections.Pooling.IManagedPool.IsManaged(System.Object)">
            <summary>
                Is the item managed by this GDX.Collections.Pooling.IManagedPool?
            </summary>
            <param name="item">The System.Object to evaluate.</param>
            <returns>true/false if the item is managed by the GDX.Collections.Pooling.IManagedPool.</returns>
        </member>
        <member name="M:GDX.Collections.Pooling.IManagedPool.IsPooled(System.Object)">
            <summary>
                Is the provided item found in the GDX.Collections.Pooling.IManagedPool's internal available pool of
                objects?
            </summary>
            <param name="item">The item to evaluate.</param>
        </member>
        <member name="M:GDX.Collections.Pooling.IManagedPool.Return(System.Object)">
            <summary>
                Return the item to the GDX.Collections.Pooling.IManagedPool's internal collection.
            </summary>
            <param name="item">The item to return to the GDX.Collections.Pooling.IManagedPool.</param>
        </member>
        <member name="M:GDX.Collections.Pooling.IManagedPool.ReturnAll(System.Boolean)">
            <summary>
                Return all spawned System.Objects to the GDX.Collections.Pooling.IManagedPool.
            </summary>
            <remarks>Shrinking the pools helps with pools that have grown out of necessity past their maximum size</remarks>
            <param name="shouldShrink">Should the GDX.Collections.Pooling.IManagedPool be shrunk to its original maximum size?</param>
        </member>
        <member name="M:GDX.Collections.Pooling.IManagedPool.TearDown">
            <summary>
                Destroy all System.Objects associated with the GDX.Collections.Pooling.IManagedPool.
            </summary>
        </member>
        <member name="T:GDX.Collections.Pooling.GameObjectPool">
            <summary>
                UnityEngine.GameObject based functionality extending the GDX.Collections.Pooling.SimpleListManagedPool to better support
                UnityEngine.GameObject patterns.
            </summary>
            <exception cref="T:GDX.UnsupportedRuntimeException">Not supported on DOTS Runtime.</exception>
        </member>
        <member name="F:GDX.Collections.Pooling.GameObjectPool.k_HasInterfaceFlag">
            <summary>
                The GDX.Collections.Pooling.SimpleListManagedPool flags index used to determine if the object which is used to create new objects
                has the GDX.Collections.Pooling.IGameObjectPoolItem interface on a root component.
            </summary>
        </member>
        <member name="M:GDX.Collections.Pooling.GameObjectPool.CreatePool(UnityEngine.GameObject,UnityEngine.Transform,System.Int32,System.Int32,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
                Create a UnityEngine.GameObject based GDX.Collections.Pooling.SimpleListManagedPool for the provided
                gameObject.
            </summary>
            <param name="gameObject">The object which going to be cloned.</param>
            <param name="parent">The container object.</param>
            <param name="minimumObjects">The minimum number of objects to be pooled.</param>
            <param name="maximumObjects">The maximum number of objects to be pooled.</param>
            <param name="allowCreateMore">Can more items be created as needed when starved for items?</param>
            <param name="allowReuseWhenCapped">Should we reuse oldest items when starving for items?</param>
            <param name="allowManagedTearDown">Does the pool allow a managed tear down event call?</param>
        </member>
        <member name="M:GDX.Collections.Pooling.GameObjectPool.Get(GDX.Collections.Pooling.SimpleListManagedPool,System.Boolean)">
            <summary>
                Get the next available item from the pool.
            </summary>
            <param name="pool">The GDX.Collections.Pooling.SimpleListManagedPool created with GDX.Collections.Pooling.GameObjectPool to pull an item from.</param>
            <param name="triggerOnSpawnedFromPool">Should the GDX.Collections.Pooling.GameObjectPool.OnSpawnedFromPoolAction(GDX.Collections.Pooling.SimpleListManagedPool,System.Object) be called when getting this item.</param>
            <returns>A UnityEngine.GameObject from the GDX.Collections.Pooling.SimpleListManagedPool, or null if no item is available.</returns>
        </member>
        <member name="M:GDX.Collections.Pooling.GameObjectPool.Get(GDX.Collections.Pooling.SimpleListManagedPool,UnityEngine.Transform,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
                Get the next available item from the pool and parent it to a UnityEngine.Transform.
            </summary>
            <param name="pool">The GDX.Collections.Pooling.SimpleListManagedPool created with GDX.Collections.Pooling.GameObjectPool to pull an item from.</param>
            <param name="parent">The transform parent on the item pulled from the GDX.Collections.Pooling.SimpleListManagedPool.</param>
            <param name="worldPositionStays">Ensure that the world position of the item pulled from the GDX.Collections.Pooling.SimpleListManagedPool remains the same through parenting.</param>
            <param name="zeroLocalPosition">Set the local position of the item pulled from the GDX.Collections.Pooling.SimpleListManagedPool to being P:UnityEngine.Vector3.zero after parenting.</param>
            <param name="triggerOnSpawnedFromPool">Should the GDX.Collections.Pooling.GameObjectPool.OnSpawnedFromPoolAction(GDX.Collections.Pooling.SimpleListManagedPool,System.Object) be called when getting this item.</param>
            <returns>A UnityEngine.GameObject from the GDX.Collections.Pooling.SimpleListManagedPool, or null if no item is available.</returns>
        </member>
        <member name="M:GDX.Collections.Pooling.GameObjectPool.Get(GDX.Collections.Pooling.SimpleListManagedPool,UnityEngine.Transform,UnityEngine.Vector3,UnityEngine.Quaternion,System.Boolean)">
            <summary>
                Get the next available item from the pool, parent it to a UnityEngine.Transform, and then set it's local position and rotation.
            </summary>
            <param name="pool">The GDX.Collections.Pooling.SimpleListManagedPool created with GDX.Collections.Pooling.GameObjectPool to pull an item from.</param>
            <param name="parent">The transform parent on the item pulled from the GDX.Collections.Pooling.SimpleListManagedPool.</param>
            <param name="localPosition">The local position to set on the item pulled from the GDX.Collections.Pooling.SimpleListManagedPool after parenting.</param>
            <param name="localRotation">The local rotation to set on the item pulled from the GDX.Collections.Pooling.SimpleListManagedPool after parenting.</param>
            <param name="triggerOnSpawnedFromPool">Should the GDX.Collections.Pooling.GameObjectPool.OnSpawnedFromPoolAction(GDX.Collections.Pooling.SimpleListManagedPool,System.Object) be called when getting this item.</param>
            <returns>A UnityEngine.GameObject from the GDX.Collections.Pooling.SimpleListManagedPool, or null if no item is available.</returns>
        </member>
        <member name="M:GDX.Collections.Pooling.GameObjectPool.Get(GDX.Collections.Pooling.SimpleListManagedPool,UnityEngine.Transform,UnityEngine.Vector3,UnityEngine.Vector3,System.Boolean)">
            <summary>
                Get the next available item from the pool, parent it to a UnityEngine.Transform, and then setting it's local position and where it is looking.
            </summary>
            <param name="pool">The GDX.Collections.Pooling.SimpleListManagedPool created with GDX.Collections.Pooling.GameObjectPool to pull an item from.</param>
            <param name="parent">The transform parent on the item pulled from the GDX.Collections.Pooling.SimpleListManagedPool.</param>
            <param name="localPosition">The local position to set on the item pulled from the GDX.Collections.Pooling.SimpleListManagedPool after parenting.</param>
            <param name="worldLookAtPosition">The world position to have the item pulled from the GDX.Collections.Pooling.SimpleListManagedPool look at</param>
            <param name="triggerOnSpawnedFromPool">Should the GDX.Collections.Pooling.GameObjectPool.OnSpawnedFromPoolAction(GDX.Collections.Pooling.SimpleListManagedPool,System.Object) be called when getting this item.</param>
            <returns>A UnityEngine.GameObject from the GDX.Collections.Pooling.SimpleListManagedPool, or null if no item is available.</returns>
        </member>
        <member name="M:GDX.Collections.Pooling.GameObjectPool.Get(GDX.Collections.Pooling.SimpleListManagedPool,UnityEngine.Vector3,UnityEngine.Vector3,System.Boolean)">
            <summary>
                Get the next available item from the pool, and set its world position and where it is looking.
            </summary>
            <param name="pool">The GDX.Collections.Pooling.SimpleListManagedPool created with GDX.Collections.Pooling.GameObjectPool to pull an item from.</param>
            <param name="worldPosition">The world position to set on the item pulled from the GDX.Collections.Pooling.SimpleListManagedPool.</param>
            <param name="worldLookAtPosition">The world position to have the item pulled from the GDX.Collections.Pooling.SimpleListManagedPool look at</param>
            <param name="triggerOnSpawnedFromPool">Should the GDX.Collections.Pooling.GameObjectPool.OnSpawnedFromPoolAction(GDX.Collections.Pooling.SimpleListManagedPool,System.Object) be called when getting this item.</param>
            <returns>A UnityEngine.GameObject from the GDX.Collections.Pooling.SimpleListManagedPool, or null if no item is available.</returns>
        </member>
        <member name="M:GDX.Collections.Pooling.GameObjectPool.Get(GDX.Collections.Pooling.SimpleListManagedPool,UnityEngine.Vector3,UnityEngine.Quaternion,System.Boolean)">
            <summary>
                Get the next available item from the pool, and set its world position and rotation.
            </summary>
            <param name="pool">The GDX.Collections.Pooling.SimpleListManagedPool created with GDX.Collections.Pooling.GameObjectPool to pull an item from.</param>
            <param name="worldPosition">The world position to set on the item pulled from the GDX.Collections.Pooling.SimpleListManagedPool.</param>
            <param name="worldRotation">The world rotation to set on the item pulled from the GDX.Collections.Pooling.SimpleListManagedPool.</param>
            <param name="triggerOnSpawnedFromPool">Should the GDX.Collections.Pooling.GameObjectPool.OnSpawnedFromPoolAction(GDX.Collections.Pooling.SimpleListManagedPool,System.Object) be called when getting this item.</param>
            <returns>A UnityEngine.GameObject from the GDX.Collections.Pooling.SimpleListManagedPool, or null if no item is available.</returns>
        </member>
        <member name="M:GDX.Collections.Pooling.GameObjectPool.Get(GDX.Collections.Pooling.SimpleListManagedPool,UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Transform,System.Boolean)">
            <summary>
                Get the next available item from the pool, and set its world position and rotation after parenting.
            </summary>
            <param name="pool">The GDX.Collections.Pooling.SimpleListManagedPool created with GDX.Collections.Pooling.GameObjectPool to pull an item from.</param>
            <param name="worldPosition">The world position to set on the item pulled from the GDX.Collections.Pooling.SimpleListManagedPool after parenting.</param>
            <param name="worldRotation">The world rotation to set on the item pulled from the GDX.Collections.Pooling.SimpleListManagedPool after parenting.</param>
            <param name="parent">The transform parent on the item pulled from the GDX.Collections.Pooling.SimpleListManagedPool.</param>
            <param name="triggerOnSpawnedFromPool">Should the GDX.Collections.Pooling.GameObjectPool.OnSpawnedFromPoolAction(GDX.Collections.Pooling.SimpleListManagedPool,System.Object) be called when getting this item.</param>
            <returns>A UnityEngine.GameObject from the GDX.Collections.Pooling.SimpleListManagedPool, or null if no item is available.</returns>
        </member>
        <member name="M:GDX.Collections.Pooling.GameObjectPool.Get(GDX.Collections.Pooling.SimpleListManagedPool,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Transform,System.Boolean)">
            <summary>
                Get the next available item from the pool, and set its world position and look at position after parenting.
            </summary>
            <param name="pool">The GDX.Collections.Pooling.SimpleListManagedPool created with GDX.Collections.Pooling.GameObjectPool to pull an item from.</param>
            <param name="worldPosition">The world position to set on the item pulled from the GDX.Collections.Pooling.SimpleListManagedPool after parenting.</param>
            <param name="worldLookAtPosition">The world position to have the item pulled from the GDX.Collections.Pooling.SimpleListManagedPool look at after parenting.</param>
            <param name="parent">The transform parent on the item pulled from the GDX.Collections.Pooling.SimpleListManagedPool.</param>
            <param name="triggerOnSpawnedFromPool">Should the GDX.Collections.Pooling.GameObjectPool.OnSpawnedFromPoolAction(GDX.Collections.Pooling.SimpleListManagedPool,System.Object) be called when getting this item.</param>
            <returns>A UnityEngine.GameObject from the GDX.Collections.Pooling.SimpleListManagedPool, or null if no item is available.</returns>
        </member>
        <member name="M:GDX.Collections.Pooling.GameObjectPool.GetOrCreatePool(UnityEngine.GameObject,UnityEngine.Transform,System.Int32,System.Int32,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
                Gets a pool for the gameObject, or creates a new GDX.Collections.Pooling.SimpleListManagedPool for it.
            </summary>
            <param name="gameObject">The object which going to be cloned.</param>
            <param name="parent">The container object.</param>
            <param name="minimumObjects">The minimum number of objects to be pooled.</param>
            <param name="maximumObjects">The maximum number of objects to be pooled.</param>
            <param name="allowCreateMore">Can more items be created as needed when starved for items?</param>
            <param name="allowReuseWhenCapped">Should we reuse oldest items when starving for items?</param>
            <param name="allowManagedTearDown">Does the pool allow a managed tear down event call?</param>
        </member>
        <member name="M:GDX.Collections.Pooling.GameObjectPool.CreateItem(GDX.Collections.Pooling.SimpleListManagedPool)">
            <summary>
                Create a new item for the pool.
            </summary>
            <param name="pool">The GDX.Collections.Pooling.SimpleListManagedPool to create an item for, and assign too.</param>
            <returns>The newly created item.</returns>
        </member>
        <member name="M:GDX.Collections.Pooling.GameObjectPool.OnDestroyItemAction(System.Object)">
            <summary>
                The subscribed action called when an item is requested to be destroyed..
            </summary>
            <param name="item">The item being destroyed.</param>
        </member>
        <member name="M:GDX.Collections.Pooling.GameObjectPool.OnReturnedToPoolAction(GDX.Collections.Pooling.SimpleListManagedPool,System.Object)">
            <summary>
                The subscribed action called when an item is returned to the pool.
            </summary>
            <param name="pool">The GDX.Collections.Pooling.SimpleListManagedPool which the item is being returned to.</param>
            <param name="item">The item being returned to the pool.</param>
        </member>
        <member name="M:GDX.Collections.Pooling.GameObjectPool.OnSpawnedFromPoolAction(GDX.Collections.Pooling.SimpleListManagedPool,System.Object)">
            <summary>
                The subscribed action called when an item is spawned from the pool.
            </summary>
            <param name="pool">The GDX.Collections.Pooling.SimpleListManagedPool which has had the item spawned from.</param>
            <param name="item">The spawned item.</param>
        </member>
        <member name="M:GDX.Collections.Pooling.GameObjectPool.OnTearDownAction(GDX.Collections.Pooling.SimpleListManagedPool)">
            <summary>
                The subscribed action called when the pool is asked to GDX.Collections.Pooling.IManagedPool.TearDown before items were returned to the pool.
            </summary>
            <param name="pool">The GDX.Collections.Pooling.SimpleListManagedPool being torn down.</param>
        </member>
        <member name="T:GDX.Collections.Pooling.ManagedPoolBuilder">
            <summary>
                A time-slicing builder behaviour for GDX.Collections.Pooling.IManagedPool.
            </summary>
            <remarks>A demonstration of usage can be found in GDX.Collections.Pooling.GameObjectPool.</remarks>
            <exception cref="T:GDX.UnsupportedRuntimeException">Not supported on DOTS Runtime.</exception>
        </member>
        <member name="F:GDX.Collections.Pooling.ManagedPoolBuilder.InstantiatesPerFrame">
            <summary>
                The number of instantiates to make per frame.
            </summary>
            <remarks>
                During defined loading periods this value could be increased for faster allocations,
                and then returned to a much more performant value afterwards.
            </remarks>
        </member>
        <member name="F:GDX.Collections.Pooling.ManagedPoolBuilder.DestroyBuilderOnFinish">
            <summary>
                Should the GDX.Collections.Pooling.ManagedPoolBuilder destroy itself when finished?
            </summary>
        </member>
        <member name="F:GDX.Collections.Pooling.ManagedPoolBuilder.s_BuilderObject">
            <summary>
                A cached reference to the UnityEngine.GameObject the builder created for itself.
            </summary>
        </member>
        <member name="F:GDX.Collections.Pooling.ManagedPoolBuilder.k_TargetPools">
            <summary>
                A System.Collections.Generic.List`1 of GDX.Collections.Pooling.IManagedPool which are being built out.
            </summary>
        </member>
        <member name="F:GDX.Collections.Pooling.ManagedPoolBuilder.s_TargetPoolsCount">
            <summary>
                A cached numerical count of the number of GDX.Collections.Pooling.IManagedPool contained in GDX.Collections.Pooling.ManagedPoolBuilder.k_TargetPools.
            </summary>
        </member>
        <member name="M:GDX.Collections.Pooling.ManagedPoolBuilder.LateUpdate">
            <summary>
                Unity's LateUpdate event.
            </summary>
        </member>
        <member name="M:GDX.Collections.Pooling.ManagedPoolBuilder.AddManagedPool(GDX.Collections.Pooling.IManagedPool)">
            <summary>
                Add an GDX.Collections.Pooling.IManagedPool to the builder to be built out.
            </summary>
            <param name="targetManagedPool">The GDX.Collections.Pooling.IManagedPool to build out.</param>
        </member>
        <member name="M:GDX.Collections.Pooling.ManagedPoolBuilder.RemoveManagedPool(GDX.Collections.Pooling.IManagedPool)">
            <summary>
                Remove an GDX.Collections.Pooling.IManagedPool from the builder.
            </summary>
            <param name="targetManagedPool">The GDX.Collections.Pooling.IManagedPool to be removed.</param>
        </member>
        <member name="M:GDX.Collections.Pooling.ManagedPoolBuilder.Tick">
            <summary>
                Extracted tick update for the builder; creating a limited number of items per tick.
            </summary>
        </member>
        <member name="T:GDX.Collections.Pooling.IGameObjectPoolItem">
            <summary>
                An interface describing the functionality needed for an item to be understood by GDX.Collections.Pooling.GameObjectPool,
                if callbacks are to be made.
            </summary>
            <exception cref="T:GDX.UnsupportedRuntimeException">Not supported on DOTS Runtime.</exception>
        </member>
        <member name="M:GDX.Collections.Pooling.IGameObjectPoolItem.GetParentPool">
            <summary>
                Return the GDX.Collections.Pooling.IManagedPool which the GDX.Collections.Pooling.IGameObjectPoolItem is currently managed by.
            </summary>
            <remarks>It is possible that a pooled item may exist without a parent in some custom scenario.</remarks>
            <returns>
                An GDX.Collections.Pooling.IManagedPool if the GDX.Collections.Pooling.IGameObjectPoolItem is attached to a pool, otherwise
                null.
            </returns>
        </member>
        <member name="M:GDX.Collections.Pooling.IGameObjectPoolItem.IsValidItem">
            <summary>
                Is the GDX.Collections.Pooling.IGameObjectPoolItem thought to be valid?
            </summary>
            <remarks>
                Sometimes a UnityEngine.GameObject may get destroyed without the pool knowing, this contains
                checks to validate if the item can be returned to a pool and reused appropriately.
            </remarks>
            <returns>true/false if the item is found to be valid.</returns>
        </member>
        <member name="M:GDX.Collections.Pooling.IGameObjectPoolItem.OnReturnedToPool">
            <summary>
                Called when this item is returned to the GDX.Collections.Pooling.IManagedPool.
            </summary>
            <remarks>
                This should handle everything, including disabling the UnityEngine.GameObject.
            </remarks>
        </member>
        <member name="M:GDX.Collections.Pooling.IGameObjectPoolItem.OnSpawnedFromPool">
            <summary>
                Called when this item is spawned from the GDX.Collections.Pooling.IManagedPool.
            </summary>
            <remarks>
                This should handle everything, including enabling the UnityEngine.GameObject.
            </remarks>
        </member>
        <member name="M:GDX.Collections.Pooling.IGameObjectPoolItem.ReturnToPool">
            <summary>
                Return the item to the GDX.Collections.Pooling.IManagedPool which it is associated too.
            </summary>
        </member>
        <member name="M:GDX.Collections.Pooling.IGameObjectPoolItem.SetParentPool(GDX.Collections.Pooling.IManagedPool)">
            <summary>
                Set the GDX.Collections.Pooling.IManagedPool which this item believes it belongs too.
            </summary>
            <remarks>This is used during creation to assign the parent that is creating the item.</remarks>
            <param name="targetManagedPool">The parent GDX.Collections.Pooling.IManagedPool.</param>
        </member>
        <member name="T:GDX.Collections.Pooling.ManagedPools">
            <summary>
                A managed pooling system implementation primarily meant for the object oriented patterns, based on the C# base
                object.
            </summary>
        </member>
        <member name="F:GDX.Collections.Pooling.ManagedPools.s_LastPoolKey">
            <summary>
                The last issued pool key used by internal dictionary's System.Collections.Generic.KeyValuePair`2 when referencing an
                GDX.Collections.Pooling.IManagedPool.
            </summary>
            <remarks>
                This value resets on domain reload, and as such the keys should not be relied on through any sort of
                serialization (including networking) or session based process.
            </remarks>
        </member>
        <member name="F:GDX.Collections.Pooling.ManagedPools.k_Pools">
            <summary>
                An internal dictionary containing the GDX.Collections.Pooling.IManagedPools, uniquely indexed by constant ticket-like
                system.
            </summary>
        </member>
        <member name="M:GDX.Collections.Pooling.ManagedPools.GetNextPoolKey">
            <summary>
                Get the next available pool key.
            </summary>
            <remarks>Increments the previously issued stored value, and returns the new value.</remarks>
            <returns>A unique pool identifying key.</returns>
        </member>
        <member name="M:GDX.Collections.Pooling.ManagedPools.GetPool(System.UInt32)">
            <summary>
                Get a registered GDX.Collections.Pooling.IManagedPool based on its key.
            </summary>
            <param name="key">The unique key to use when looking for the GDX.Collections.Pooling.IManagedPool.</param>
            <returns>An GDX.Collections.Pooling.IManagedPool identified by the provided key.</returns>
        </member>
        <member name="M:GDX.Collections.Pooling.ManagedPools.GetPool``1(System.UInt32)">
            <summary>
                Get a registered GDX.Collections.Pooling.IManagedPool based on its key.
            </summary>
            <param name="key">The unique key to use when looking for the GDX.Collections.Pooling.IManagedPool.</param>
            <typeparam name="T">The type of the pool, used to cast the return pool</typeparam>
            <returns>A type casted pool identified by the provided key.</returns>
        </member>
        <member name="M:GDX.Collections.Pooling.ManagedPools.GetPoolWithContainsCheck(System.UInt32)">
            <summary>
                Get a registered GDX.Collections.Pooling.IManagedPool based on its key, first checking if it is
                registered.
            </summary>
            <param name="key">The unique key to use when looking for the GDX.Collections.Pooling.IManagedPool.</param>
            <returns>An GDX.Collections.Pooling.IManagedPool identified by the provided key, null if not found.</returns>
        </member>
        <member name="M:GDX.Collections.Pooling.ManagedPools.GetPoolWithContainsCheck``1(System.UInt32)">
            <summary>
                Get a registered GDX.Collections.Pooling.IManagedPool based on its key, first checking if it is
                registered.
            </summary>
            <param name="key">The unique key to use when looking for the GDX.Collections.Pooling.IManagedPool.</param>
            <typeparam name="T">The type of the pool, used to cast the return pool</typeparam>
            <returns>A type casted pool identified by the provided key, null if not found.</returns>
        </member>
        <member name="M:GDX.Collections.Pooling.ManagedPools.HasPool(System.UInt32)">
            <summary>
                Is an GDX.Collections.Pooling.IManagedPool registered with the provided key?
            </summary>
            <param name="key">A unique pool key</param>
            <returns>true if a pool is found registered with this system, false otherwise.</returns>
        </member>
        <member name="M:GDX.Collections.Pooling.ManagedPools.ReturnAll(System.Boolean)">
            <summary>
                Attempts to return all spawned items to their original GDX.Collections.Pooling.IManagedPools.
            </summary>
            <param name="shouldShrink">Should the pool be shrunk (destroying created items) to its original set minimum size?</param>
        </member>
        <member name="M:GDX.Collections.Pooling.ManagedPools.Register(GDX.Collections.Pooling.IManagedPool)">
            <summary>
                Register a GDX.Collections.Pooling.IManagedPool with the global management system.
            </summary>
            <param name="managedPool">Target GDX.Collections.Pooling.IManagedPool</param>
        </member>
        <member name="M:GDX.Collections.Pooling.ManagedPools.TearDown(System.Boolean)">
            <summary>
                Execute GDX.Collections.Pooling.IManagedPool.TearDown (destroying contents) on all registered GDX.Collections.Pooling.IManagedPool
                which have been flagged to accept it, evaluated by GDX.Collections.Pooling.IManagedPool.IsAllowedManagedTearDown.
            </summary>
            <remarks>
                This will unregister the GDX.Collections.Pooling.IManagedPool itself as well.
            </remarks>
            <param name="forceAll">
                Execute GDX.Collections.Pooling.IManagedPool.TearDown regardless of the
                GDX.Collections.Pooling.IManagedPool.IsAllowedManagedTearDown response.
            </param>
        </member>
        <member name="M:GDX.Collections.Pooling.ManagedPools.TryGetFirstPool(System.Object,GDX.Collections.Pooling.IManagedPool@)">
            <summary>
                Attempt to get an GDX.Collections.Pooling.IManagedPool based on the baseObject.
            </summary>
            <param name="baseObject">The System.Object which was used to create the pool.</param>
            <param name="pool">The first found GDX.Collections.Pooling.IManagedPool created with baseObject.</param>
            <returns>true/false if an GDX.Collections.Pooling.IManagedPool was found.</returns>
        </member>
        <member name="M:GDX.Collections.Pooling.ManagedPools.Unregister(GDX.Collections.Pooling.IManagedPool)">
            <summary>
                Unregister a GDX.Collections.Pooling.IManagedPool from with the management system.
            </summary>
            <param name="managedPool">Target GDX.Collections.Pooling.IManagedPool</param>
        </member>
        <member name="T:GDX.Collections.BitArray64">
            <summary>
                A 64-bit array.
            </summary>
            <example>
                Useful for packing a bunch of data with known indices tightly.
                <code>
                    if(myBitArray64[1])
                    {
                        BeAwesome();
                    }
                </code>
            </example>
        </member>
        <member name="F:GDX.Collections.BitArray64.Bits0">
            <summary>
                First reserved System.Int64 memory block (64-bits).
            </summary>
            <remarks>Indices 0-63</remarks>
        </member>
        <member name="M:GDX.Collections.BitArray64.#ctor(System.Int64)">
            <summary>
                Create a new GDX.Collections.BitArray64 based on provided bits0.
            </summary>
            <param name="bits0">An existing value to be used to create the backing data for a GDX.Collections.BitArray64</param>
        </member>
        <member name="P:GDX.Collections.BitArray64.Item(System.Byte)">
            <summary>
                Access bit in array.
            </summary>
            <param name="index">Target bit index.</param>
        </member>
        <member name="T:GDX.Collections.NativeArraySparseSet">
            <summary>
                An adapter collection for external data arrays that allows constant-time insertion, deletion, and lookup by
                handle, as well as array-like iteration.
            </summary>
        </member>
        <member name="F:GDX.Collections.NativeArraySparseSet.DenseArray">
            <summary>
                Holds references to the sparse array for swapping indices.
            </summary>
        </member>
        <member name="F:GDX.Collections.NativeArraySparseSet.SparseArray">
            <summary>
                Holds references to dense array indices.
            </summary>
            <remarks>
                Its own indices are claimed and freed via a free-list.
            </remarks>
        </member>
        <member name="F:GDX.Collections.NativeArraySparseSet.Count">
            <summary>
                How many indices are being used currently?
            </summary>
        </member>
        <member name="F:GDX.Collections.NativeArraySparseSet.FreeIndex">
            <summary>
                The first free (currently unused) index in the sparse array.
            </summary>
        </member>
        <member name="M:GDX.Collections.NativeArraySparseSet.#ctor(System.Int32,Unity.Collections.Allocator)">
            <summary>
                Create a GDX.Collections.NativeArraySparseSet with an initialCapacity.
            </summary>
            <param name="initialCapacity">The initial capacity of the sparse and dense int arrays.</param>
            <param name="allocator">The Unity.Collections.Allocator type to use.</param>
        </member>
        <member name="M:GDX.Collections.NativeArraySparseSet.#ctor(System.Int32,Unity.Collections.Allocator,Unity.Collections.NativeArray{System.UInt64}@)">
            <summary>
                Create a GDX.Collections.NativeArraySparseSet with an initialCapacity.
            </summary>
            <param name="initialCapacity">The initial capacity of the sparse and dense int arrays.</param>
            <param name="allocator">The Unity.Collections.Allocator type to use.</param>
            <param name="versionArray">Enables detection of use-after-free errors when using sparse indices as references.</param>
        </member>
        <member name="M:GDX.Collections.NativeArraySparseSet.AddWithExpandCheck(System.Int32,System.Int32@,System.Int32@,Unity.Collections.Allocator)">
            <summary>
                Adds a sparse/dense index pair to the set and expands the arrays if necessary.
            </summary>
            <param name="expandBy">How many indices to expand by.</param>
            <param name="sparseIndex">The sparse index allocated.</param>
            <param name="denseIndex">The dense index allocated.</param>
            <param name="allocator">The Unity.Collections.Allocator type to use.</param>
            <returns>True if the index pool expanded.</returns>
        </member>
        <member name="M:GDX.Collections.NativeArraySparseSet.AddWithExpandCheck(System.Int32,System.Int32@,System.Int32@,Unity.Collections.Allocator,Unity.Collections.NativeArray{System.UInt64}@)">
            <summary>
                Adds a sparse/dense index pair to the set and expands the arrays if necessary.
            </summary>
            <param name="expandBy">How many indices to expand by.</param>
            <param name="sparseIndex">The sparse index allocated.</param>
            <param name="denseIndex">The dense index allocated.</param>
            <param name="allocator">The Unity.Collections.Allocator type to use.</param>
            <param name="versionArray">Enables detection of use-after-free errors when using sparse indices as references.</param>
            <returns>True if the index pool expanded.</returns>
        </member>
        <member name="M:GDX.Collections.NativeArraySparseSet.AddUnchecked(System.Int32@,System.Int32@)">
            <summary>
                Adds a sparse/dense index pair to the set without checking if the set needs to expand.
            </summary>
            <param name="sparseIndex">The sparse index allocated.</param>
            <param name="denseIndex">The dense index allocated.</param>
        </member>
        <member name="M:GDX.Collections.NativeArraySparseSet.AddUnchecked(System.Int32@,System.Int32@,Unity.Collections.NativeArray{System.UInt64},System.UInt64@)">
            <summary>
                Adds a sparse/dense index pair to the set without checking if the set needs to expand.
            </summary>
            <param name="sparseIndex">The sparse index allocated.</param>
            <param name="denseIndex">The dense index allocated.</param>
            <param name="versionArray">The array containing the version number to check against.</param>
            <param name="version">Enables detection of use-after-free errors when using the sparse index as a reference.</param>
        </member>
        <member name="M:GDX.Collections.NativeArraySparseSet.GetDenseIndexUnchecked(System.Int32)">
            <summary>
                Gets the value of the sparse array at the given index without any data validation.
            </summary>
            <param name="sparseIndex">The index to check in the sparse array.</param>
            <returns>The dense index at the given sparse index.</returns>
        </member>
        <member name="M:GDX.Collections.NativeArraySparseSet.GetDenseIndexWithBoundsCheck(System.Int32)">
            <summary>
                Gets the value of the sparse array at the given index,
                or -1 if the dense and sparse indices don't point to each other or if the dense index is outside the dense bounds.
            </summary>
            <param name="sparseIndex">The index in the sparse array to check against.</param>
            <returns>The dense index pointed to by the current sparse index, or -1 if invalid.</returns>
        </member>
        <member name="M:GDX.Collections.NativeArraySparseSet.GetDenseIndexWithVersionCheck(System.Int32,System.UInt64,Unity.Collections.NativeArray{System.UInt64})">
            <summary>
                Gets the value of the sparse array at the given index,
                or -1 if the version number does not match.
            </summary>
            <param name="sparseIndex">The index in the sparse array to check against.</param>
            <param name="version">The version number associated with the sparse index.</param>
            <param name="versionArray">The array containing the version number to check against.</param>
            <returns>The dense index pointed to by the current sparse index, or -1 if invalid.</returns>
        </member>
        <member name="M:GDX.Collections.NativeArraySparseSet.GetDenseIndexWithBoundsAndVersionCheck(System.Int32,System.UInt64,Unity.Collections.NativeArray{System.UInt64})">
            <summary>
                Gets the value of the sparse array at the given index,
                or -1 if the given sparse index is invalid..
            </summary>
            <param name="sparseIndex">The index in the sparse array to check against.</param>
            <param name="version">The version number associated with the sparse index.</param>
            <param name="versionArray">The array containing the version number to check against.</param>
            <returns>The dense index pointed to by the current sparse index, or -1 if invalid.</returns>
        </member>
        <member name="M:GDX.Collections.NativeArraySparseSet.RemoveWithBoundsCheck(System.Int32@,System.Int32@,System.Int32@)">
            <summary>
                Removes the entry corresponding to the sparse index if the entry is within bounds and currently in use.
            </summary>
            <param name="sparseIndexToRemove">The sparse index corresponding to the entry to remove. Cleared to -1 in this operation.</param>
            <param name="dataIndexToSwapFrom">
                Set the data array value at this index to default after swapping with the data array
                value at indexToSwapTo.
            </param>
            <param name="dataIndexToSwapTo">Replace the data array value at this index with the data array value at indexToSwapFrom.</param>
            <returns>True if the index reference was valid, and thus removed.</returns>
        </member>
        <member name="M:GDX.Collections.NativeArraySparseSet.RemoveWithBoundsAndVersionChecks(System.Int32@,System.UInt64,Unity.Collections.NativeArray{System.UInt64},System.Int32@,System.Int32@)">
            <summary>
                Removes the associated sparse/dense index pair from active use.
                calls.
            </summary>
            <param name="sparseIndexToRemove">The sparse index to remove.</param>
            <param name="version">
                The version number of the int used to access the sparse index. Used to guard against accessing
                indices that have been removed and reused.
            </param>
            <param name="versionArray">The array containing the version number to check against.</param>
            <param name="indexToSwapFrom">
                Set the data array value at this index to default after swapping with the data array
                value at indexToSwapTo.
            </param>
            <param name="indexToSwapTo">Replace the data array value at this index with the data array value at indexToSwapFrom.</param>
            <returns>True if the element was successfully removed.</returns>
        </member>
        <member name="M:GDX.Collections.NativeArraySparseSet.RemoveUnchecked(System.Int32)">
            <summary>
                Removes the associated sparse/dense index pair from active use.
            </summary>
            <param name="sparseIndexToRemove">The sparse index to remove.</param>
        </member>
        <member name="M:GDX.Collections.NativeArraySparseSet.RemoveUnchecked(System.Int32,Unity.Collections.NativeArray{System.UInt64})">
            <summary>
                Removes the associated sparse/dense index pair from active use and increments the version.
            </summary>
            <param name="sparseIndexToRemove">The sparse index to remove.</param>
            <param name="versionArray">Enables detection of use-after-free errors when using sparse indices as references.</param>
        </member>
        <member name="M:GDX.Collections.NativeArraySparseSet.RemoveUnchecked(System.Int32,System.Int32@,System.Int32@)">
            <summary>
                Removes the associated sparse/dense index pair from active use.
                Out parameters used to manage parallel data arrays.
            </summary>
            <param name="sparseIndexToRemove">The sparse index to remove.</param>
            <param name="indexToSwapTo">Replace the data array value at this index with the data array value at indexToSwapFrom.</param>
            <param name="indexToSwapFrom">
                Set the data array value at this index to default after swapping with the data array
                value at indexToSwapTo.
            </param>
        </member>
        <member name="M:GDX.Collections.NativeArraySparseSet.RemoveUnchecked(System.Int32,Unity.Collections.NativeArray{System.UInt64},System.Int32@,System.Int32@)">
            <summary>
                Removes the associated sparse/dense index pair from active use and increments the version.
                Out parameters used to manage parallel data arrays.
            </summary>
            <param name="sparseIndexToRemove">The sparse index to remove.</param>
            <param name="versionArray">Enables detection of use-after-free errors when using sparse indices as references.</param>
            <param name="indexToSwapTo">Replace the data array value at this index with the data array value at indexToSwapFrom.</param>
            <param name="indexToSwapFrom">
                Set the data array value at this index to default after swapping with the data array
                value at indexToSwapTo.
            </param>
        </member>
        <member name="M:GDX.Collections.NativeArraySparseSet.RemoveUncheckedFromDenseIndex(System.Int32)">
            <summary>
                Removes the associated sparse/dense index pair from active use.
            </summary>
            <param name="denseIndexToRemove">The dense index associated with the sparse index to remove.</param>
        </member>
        <member name="M:GDX.Collections.NativeArraySparseSet.RemoveUncheckedFromDenseIndex(System.Int32,Unity.Collections.NativeArray{System.UInt64})">
            <summary>
                Removes the associated sparse/dense index pair from active use.
            </summary>
            <param name="denseIndexToRemove">The dense index associated with the sparse index to remove.</param>
            <param name="versionArray">Enables detection of use-after-free errors when using sparse indices as references.</param>
        </member>
        <member name="M:GDX.Collections.NativeArraySparseSet.RemoveUncheckedFromDenseIndex(System.Int32,System.Int32@)">
            <summary>
                Removes the associated sparse/dense index pair from active use.
                Out parameter used to manage parallel data arrays.
            </summary>
            <param name="denseIndexToRemove">The sparse index to remove.</param>
            <param name="indexToSwapFrom">
                Set the data array value at this index to default after swapping with the data array
                value at denseIndexToRemove.
            </param>
        </member>
        <member name="M:GDX.Collections.NativeArraySparseSet.RemoveUncheckedFromDenseIndex(System.Int32,Unity.Collections.NativeArray{System.UInt64},System.Int32@)">
            <summary>
                Removes the associated sparse/dense index pair from active use.
                Out parameter used to manage parallel data arrays.
            </summary>
            <param name="denseIndexToRemove">The sparse index to remove.</param>
            <param name="versionArray">Enables detection of use-after-free errors when using sparse indices as references.</param>
            <param name="indexToSwapFrom">
                Set the data array value at this index to default after swapping with the data array
                value at denseIndexToRemove.
            </param>
        </member>
        <member name="M:GDX.Collections.NativeArraySparseSet.RemoveWithVersionCheck(System.Int32,System.UInt64,Unity.Collections.NativeArray{System.UInt64},System.Int32@,System.Int32@)">
            <summary>
                Attempts to remove the associated sparse/dense index pair from active use and increments the version if successful.
                Out parameters used to manage parallel data arrays.
            </summary>
            <param name="sparseIndexToRemove">The sparse index to remove.</param>
            <param name="version">
                The version number of the int used to access the sparse index. Used to guard against accessing
                indices that have been removed and reused.
            </param>
            <param name="versionArray">The array containing the version number to check against.</param>
            <param name="indexToSwapTo">Replace the data array value at this index with the data array value at indexToSwapFrom.</param>
            <param name="indexToSwapFrom">
                Set the data array value at this index to default after swapping with the data array
                value at indexToSwapTo.
            </param>
            <returns>True if the entry was valid and thus removed.</returns>
        </member>
        <member name="M:GDX.Collections.NativeArraySparseSet.Clear">
            <summary>
                Clear the dense and sparse arrays.
            </summary>
        </member>
        <member name="M:GDX.Collections.NativeArraySparseSet.Clear(Unity.Collections.NativeArray{System.UInt64})">
            <summary>
                Clear the dense and sparse arrays.
            </summary>
            <param name="versionArray">Enables detection of use-after-free errors when using sparse indices as references.</param>
        </member>
        <member name="M:GDX.Collections.NativeArraySparseSet.ClearWithVersionArrayReset(Unity.Collections.NativeArray{System.UInt64})">
            <summary>
                Clear the dense and sparse arrays and reset the version array.
                Note: Only clear the version array if you are sure there are no outstanding dependencies on version numbers.
            </summary>
            ///
            <param name="versionArray">Enables detection of use-after-free errors when using sparse indices as references.</param>
        </member>
        <member name="M:GDX.Collections.NativeArraySparseSet.Expand(System.Int32,Unity.Collections.Allocator)">
            <summary>
                Reallocate the dense and sparse arrays with additional capacity.
            </summary>
            <param name="extraCapacity">How many indices to expand the dense and sparse arrays by.</param>
            <param name="allocator">The Unity.Collections.Allocator type to use.</param>
        </member>
        <member name="M:GDX.Collections.NativeArraySparseSet.Expand(System.Int32,Unity.Collections.Allocator,Unity.Collections.NativeArray{System.UInt64}@)">
            <summary>
                Reallocate the dense and sparse arrays with additional capacity.
            </summary>
            <param name="extraCapacity">How many indices to expand the dense and sparse arrays by.</param>
            <param name="allocator">Which Unity memory allocator to use with the backing array.</param>
            <param name="versionArray">Enables detection of use-after-free errors when using sparse indices as references.</param>
        </member>
        <member name="M:GDX.Collections.NativeArraySparseSet.Reserve(System.Int32,Unity.Collections.Allocator)">
            <summary>
            Reallocate the dense and sparse arrays with additional capacity if there are not at least numberToReserve unused entries.
            </summary>
            <param name="numberToReserve">The number of unused entries to ensure capacity for.</param>
            <param name="allocator">The allocator to use on expansion.</param>
        </member>
        <member name="M:GDX.Collections.NativeArraySparseSet.Reserve(System.Int32,Unity.Collections.Allocator,Unity.Collections.NativeArray{System.UInt64}@)">
            <summary>
            Reallocate the dense and sparse arrays with additional capacity if there are not at least numberToReserve unused entries.
            </summary>
            <param name="numberToReserve">The number of unused entries to ensure capacity for.</param>
            <param name="allocator">The allocator to use on expansion.</param>
            <param name="versionArray">Enables detection of use-after-free errors when using sparse indices as references.</param>
        </member>
        <member name="T:GDX.Collections.BitArray128">
            <summary>
                A 128-bit array.
            </summary>
            <example>
                Useful for packing a bunch of data with known indices tightly.
                <code>
                    if(myBitArray128[1])
                    {
                        BeAwesome();
                    }
                </code>
            </example>
        </member>
        <member name="F:GDX.Collections.BitArray128.Bits0">
            <summary>
                First reserved System.Int32 memory block.
            </summary>
            <remarks>Indices 0-31</remarks>
        </member>
        <member name="F:GDX.Collections.BitArray128.Bits1">
            <summary>
                Second reserved System.Int32 memory block.
            </summary>
            <remarks>Indices 32-63</remarks>
        </member>
        <member name="F:GDX.Collections.BitArray128.Bits2">
            <summary>
                Third reserved System.Int32 memory block.
            </summary>
            <remarks>Indices 64-95</remarks>
        </member>
        <member name="F:GDX.Collections.BitArray128.Bits3">
            <summary>
                Fourth reserved System.Int32 memory block.
            </summary>
            <remarks>Indices 96-127</remarks>
        </member>
        <member name="P:GDX.Collections.BitArray128.Item(System.Int32)">
            <summary>
                Access bit in array.
            </summary>
            <param name="index">Target bit index.</param>
        </member>
        <member name="T:GDX.Collections.BitArray32">
            <summary>
                A 32-bit array.
            </summary>
            <example>
                Useful for packing a bunch of data with known indices tightly.
                <code>
                    if(myBitArray32[1])
                    {
                        BeAwesome();
                    }
                </code>
            </example>
        </member>
        <member name="F:GDX.Collections.BitArray32.Bits0">
            <summary>
                First reserved System.UInt32 memory block (32-bits).
            </summary>
            <remarks>Indices 0-31</remarks>
        </member>
        <member name="M:GDX.Collections.BitArray32.#ctor(System.UInt32)">
            <summary>
                Create a new GDX.Collections.BitArray32 based on provided bits0.
            </summary>
            <param name="bits0">An existing value to be used to create the backing data for a GDX.Collections.BitArray32</param>
        </member>
        <member name="P:GDX.Collections.BitArray32.Item(System.Byte)">
            <summary>
                Access bit in array.
            </summary>
            <param name="index">Target bit index.</param>
        </member>
        <member name="T:GDX.Collections.SparseSet">
            <summary>
                An adapter collection for external data arrays that allows constant-time insertion, deletion, and lookup by
                handle, as well as array-like iteration.
            </summary>
        </member>
        <member name="F:GDX.Collections.SparseSet.DenseArray">
            <summary>
                Holds references to the sparse array for swapping indices.
            </summary>
        </member>
        <member name="F:GDX.Collections.SparseSet.SparseArray">
            <summary>
                Holds references to dense array indices.
            </summary>
            <remarks>
                Its own indices are claimed and freed via a free-list.
            </remarks>
        </member>
        <member name="F:GDX.Collections.SparseSet.Count">
            <summary>
                How many indices are being used currently?
            </summary>
        </member>
        <member name="F:GDX.Collections.SparseSet.FreeIndex">
            <summary>
                The first free (currently unused) index in the sparse array.
            </summary>
        </member>
        <member name="M:GDX.Collections.SparseSet.#ctor(System.Int32)">
            <summary>
                Create a GDX.Collections.SparseSet with an initialCapacity.
            </summary>
            <param name="initialCapacity">The initial capacity of the sparse and dense int arrays.</param>
        </member>
        <member name="M:GDX.Collections.SparseSet.#ctor(System.Int32,System.UInt64[]@)">
            <summary>
                Create a GDX.Collections.SparseSet with an initialCapacity.
            </summary>
            <param name="initialCapacity">The initial capacity of the sparse and dense int arrays.</param>
            <param name="versionArray">Array containing version numbers to check sparse references against.</param>
        </member>
        <member name="M:GDX.Collections.SparseSet.AddWithExpandCheck(System.Int32,System.Int32@,System.Int32@)">
            <summary>
                Adds a sparse/dense index pair to the set and expands the arrays if necessary.
            </summary>
            <param name="expandBy">How many indices to expand by.</param>
            <param name="sparseIndex">The sparse index allocated.</param>
            <param name="denseIndex">The dense index allocated.</param>
            <returns>True if the index pool expanded.</returns>
        </member>
        <member name="M:GDX.Collections.SparseSet.AddWithExpandCheck(System.Int32,System.Int32@,System.Int32@,System.UInt64[]@,System.UInt64@)">
            <summary>
                Adds a sparse/dense index pair to the set and expands the arrays if necessary.
            </summary>
            <param name="expandBy">How many indices to expand by.</param>
            <param name="sparseIndex">The sparse index allocated.</param>
            <param name="denseIndex">The dense index allocated.</param>
            <param name="versionArray">The array containing the version number to check against.</param>
            <param name="version">Enables detection of use-after-free errors when using the sparse index as a reference.</param>
            <returns>True if the index pool expanded.</returns>
        </member>
        <member name="M:GDX.Collections.SparseSet.AddUnchecked(System.Int32@,System.Int32@)">
            <summary>
                Adds a sparse/dense index pair to the set without checking if the set needs to expand.
            </summary>
            <param name="sparseIndex">The sparse index allocated.</param>
            <param name="denseIndex">The dense index allocated.</param>
        </member>
        <member name="M:GDX.Collections.SparseSet.AddUnchecked(System.Int32@,System.Int32@,System.UInt64[],System.UInt64@)">
            <summary>
                Adds a sparse/dense index pair to the set without checking if the set needs to expand.
            </summary>
            <param name="sparseIndex">The sparse index allocated.</param>
            <param name="denseIndex">The dense index allocated.</param>
            <param name="versionArray">The array containing the version number to check against.</param>
            <param name="version">Enables detection of use-after-free errors when using the sparse index as a reference.</param>
        </member>
        <member name="M:GDX.Collections.SparseSet.GetDenseIndexUnchecked(System.Int32)">
            <summary>
                Gets the value of the sparse array at the given index without any data validation.
            </summary>
            <param name="sparseIndex">The index to check in the sparse array.</param>
            <returns>The dense index at the given sparse index.</returns>
        </member>
        <member name="M:GDX.Collections.SparseSet.GetDenseIndexWithBoundsCheck(System.Int32)">
            <summary>
                Gets the value of the sparse array at the given index,
                or -1 if the dense and sparse indices don't point to each other or if the dense index is outside the dense bounds.
            </summary>
            <param name="sparseIndex">The index in the sparse array to check against.</param>
            <returns>The dense index pointed to by the current sparse index, or -1 if invalid.</returns>
        </member>
        <member name="M:GDX.Collections.SparseSet.GetDenseIndexWithVersionCheck(System.Int32,System.UInt64,System.UInt64[])">
            <summary>
                Gets the value of the sparse array at the given index,
                or -1 if the version number does not match.
            </summary>
            <param name="sparseIndex">The index in the sparse array to check against.</param>
            <param name="version">The version number associated with the sparse index.</param>
            <param name="versionArray">The array containing the version number to check against.</param>
            <returns>The dense index pointed to by the current sparse index, or -1 if invalid.</returns>
        </member>
        <member name="M:GDX.Collections.SparseSet.GetDenseIndexWithBoundsAndVersionCheck(System.Int32,System.UInt64,System.UInt64[])">
            <summary>
                Gets the value of the sparse array at the given index,
                or -1 if the given sparse index is invalid..
            </summary>
            <param name="sparseIndex">The index in the sparse array to check against.</param>
            <param name="version">The version number associated with the sparse index.</param>
            <param name="versionArray">The array containing the version number to check against.</param>
            <returns>The dense index pointed to by the current sparse index, or -1 if invalid.</returns>
        </member>
        <member name="M:GDX.Collections.SparseSet.RemoveWithBoundsCheck(System.Int32@,System.Int32@,System.Int32@)">
            <summary>
                Frees the allocated entry corresponding to the sparse index.
                WARNING: Will not protect against accidentally removing twice if the index in question was recycled between Remove calls.
            <param name="sparseIndexToRemove">The sparse index corresponding to the entry to remove.</param>
            <param name="dataIndexToSwapTo">Replace the data array value at this index with the data array value at indexToSwapFrom.</param>
            <param name="dataIndexToSwapFrom">
                Set the data array value at this index to default after swapping with the data array
                value at dataIndexToSwapTo.
            </param>
            </summary>
            <returns>True if the entry was valid and thus removed.</returns>
        </member>
        <member name="M:GDX.Collections.SparseSet.RemoveWithVersionCheck(System.Int32,System.UInt64,System.UInt64[],System.Int32@,System.Int32@)">
            <summary>
                Removes the allocated entry corresponding to the sparse index.
                Indicates which dense indices were swapped as a result of removing the entry.
            </summary>
            <param name="sparseIndexToRemove">The sparse index to remove.</param>
            <param name="version">
                The version number of the int used to access the sparse index. Used to guard against accessing
                indices that have been removed and reused.
            </param>
            <param name="versionArray">The array where version numbers to check against are stored.</param>
            <param name="dataIndexToSwapTo">Replace the data array value at this index with the data array value at indexToSwapFrom.</param>
            <param name="dataIndexToSwapFrom">
                Set the data array value at this index to default after swapping with the data array
                value at dataIndexToSwapTo.
            </param>
            <returns>Whether or not the remove attempt succeeded.</returns>
        </member>
        <member name="M:GDX.Collections.SparseSet.RemoveWithBoundsAndVersionChecks(System.Int32@,System.UInt64,System.UInt64[],System.Int32@,System.Int32@)">
            <summary>
                Removes the allocated entry corresponding to the sparse index.
            </summary>
            <param name="sparseIndexToRemove">The sparse index corresponding to the entry to remove.</param>
            <param name="version">
                The version number of the int used to access the sparse index. Used to guard against erroneously accessing
                freed indices currently in use with an outdated reference.
            </param>
            <param name="dataIndexToSwapTo">Replace the data array value at this index with the data array value at indexToSwapFrom.</param>
            <param name="dataIndexToSwapFrom">
                Set the data array value at this index to default after swapping with the data array
                value at dataIndexToSwapTo.
            </param>
            <param name="versionArray">The array where version numbers to check against are stored.</param>
            <returns>True if the entry was valid and thus removed.</returns>
        </member>
        <member name="M:GDX.Collections.SparseSet.RemoveUnchecked(System.Int32)">
            <summary>
                Removes the associated sparse/dense index pair from active use.
            </summary>
            <param name="sparseIndexToRemove">The sparse index to remove.</param>
        </member>
        <member name="M:GDX.Collections.SparseSet.RemoveUnchecked(System.Int32,System.Int32@,System.Int32@)">
            <summary>
                Removes the associated sparse/dense index pair from active use.
                Out parameters used to manage parallel data arrays.
            </summary>
            <param name="sparseIndexToRemove">The sparse index to remove.</param>
            <param name="indexToSwapTo">Replace the data array value at this index with the data array value at indexToSwapFrom.</param>
            <param name="indexToSwapFrom">
                Set the data array value at this index to default after swapping with the data array
                value at indexToSwapTo.
            </param>
        </member>
        <member name="M:GDX.Collections.SparseSet.RemoveUnchecked(System.Int32,System.UInt64[],System.Int32@,System.Int32@)">
            <summary>
                Removes the associated sparse/dense index pair from active use and increments the version.
                Out parameters used to manage parallel data arrays.
            </summary>
            <param name="sparseIndexToRemove">The sparse index to remove.</param>
            <param name="versionArray">The array where version numbers to check against are stored.</param>
            <param name="indexToSwapTo">Replace the data array value at this index with the data array value at indexToSwapFrom.</param>
            <param name="indexToSwapFrom">
                Set the data array value at this index to default after swapping with the data array
                value at indexToSwapTo.
            </param>
        </member>
        <member name="M:GDX.Collections.SparseSet.RemoveUncheckedFromDenseIndex(System.Int32)">
            <summary>
                Removes the associated sparse/dense index pair from active use.
            </summary>
            <param name="denseIndexToRemove">The dense index associated with the sparse index to remove.</param>
        </member>
        <member name="M:GDX.Collections.SparseSet.RemoveUncheckedFromDenseIndex(System.Int32,System.UInt64[])">
            <summary>
                Removes the associated sparse/dense index pair from active use.
            </summary>
            <param name="denseIndexToRemove">The dense index associated with the sparse index to remove.</param>
            <param name="versionArray">The array where version numbers to check against are stored.</param>
        </member>
        <member name="M:GDX.Collections.SparseSet.RemoveUncheckedFromDenseIndex(System.Int32,System.Int32@)">
            <summary>
                Removes the associated sparse/dense index pair from active use.
                Out parameter used to manage parallel data arrays.
            </summary>
            <param name="denseIndexToRemove">The sparse index to remove.</param>
            <param name="indexToSwapFrom">
                Set the data array value at this index to default after swapping with the data array
                value at denseIndexToRemove.
            </param>
        </member>
        <member name="M:GDX.Collections.SparseSet.RemoveUncheckedFromDenseIndex(System.Int32,System.UInt64[],System.Int32@)">
            <summary>
                Removes the associated sparse/dense index pair from active use.
                Out parameter used to manage parallel data arrays.
            </summary>
            <param name="denseIndexToRemove">The sparse index to remove.</param>
            <param name="versionArray">The array where version numbers to check against are stored.</param>
            <param name="indexToSwapFrom">
                Set the data array value at this index to default after swapping with the data array
                value at denseIndexToRemove.
            </param>
        </member>
        <member name="M:GDX.Collections.SparseSet.Clear">
            <summary>
                Clear the dense and sparse arrays.
            </summary>
        </member>
        <member name="M:GDX.Collections.SparseSet.Clear(System.UInt64[])">
            <summary>
                Clear the dense and sparse arrays.
            </summary>
            ///
            <param name="versionArray">Array containing version numbers to check against.</param>
        </member>
        <member name="M:GDX.Collections.SparseSet.ClearWithVersionArrayReset(System.UInt64[])">
            <summary>
                Clear the dense and sparse arrays and reset the version array.
                Note: Only clear the version array if you are sure there are no outstanding dependencies on version numbers.
            </summary>
            ///
            <param name="versionArray">Array containing version numbers to check against.</param>
        </member>
        <member name="M:GDX.Collections.SparseSet.Expand(System.Int32)">
            <summary>
                Reallocate the dense and sparse arrays with additional capacity.
            </summary>
            <param name="extraCapacity">How many indices to expand the dense and sparse arrays by.</param>
        </member>
        <member name="M:GDX.Collections.SparseSet.Expand(System.Int32,System.UInt64[]@)">
            <summary>
                Reallocate the dense and sparse arrays with additional capacity.
            </summary>
            <param name="extraCapacity">How many indices to expand the dense and sparse arrays by.</param>
            <param name="versionArray">Array containing version numbers to check against.</param>
        </member>
        <member name="M:GDX.Collections.SparseSet.AddWithExpandCheck``1(``0,``0[]@,System.Int32@,System.Int32)">
            <summary>
                Adds a sparse/dense index pair to the set and expands the arrays if necessary.
            </summary>
            <returns>True if the index pool expanded.</returns>
        </member>
        <member name="M:GDX.Collections.SparseSet.AddWithExpandCheck``2(``0,``0[]@,``1,``1[]@,System.Int32@,System.Int32)">
            <summary>
                Adds a sparse/dense index pair to the set and expands the arrays if necessary.
            </summary>
            <returns>True if the index pool expanded.</returns>
        </member>
        <member name="M:GDX.Collections.SparseSet.AddWithExpandCheck``3(``0,``0[]@,``1,``1[]@,``2,``2[]@,System.Int32@,System.Int32)">
            <summary>
                Adds a sparse/dense index pair to the set and expands the arrays if necessary.
            </summary>
            <returns>True if the index pool expanded.</returns>
        </member>
        <member name="M:GDX.Collections.SparseSet.AddWithExpandCheck``4(``0,``0[]@,``1,``1[]@,``2,``2[]@,``3,``3[]@,System.Int32@,System.Int32)">
            <summary>
                Adds a sparse/dense index pair to the set and expands the arrays if necessary.
            </summary>
            <returns>True if the index pool expanded.</returns>
        </member>
        <member name="M:GDX.Collections.SparseSet.AddWithExpandCheck``5(``0,``0[]@,``1,``1[]@,``2,``2[]@,``3,``3[]@,``4,``4[]@,System.Int32@,System.Int32)">
            <summary>
                Adds a sparse/dense index pair to the set and expands the arrays if necessary.
            </summary>
            <returns>True if the index pool expanded.</returns>
        </member>
        <member name="M:GDX.Collections.SparseSet.AddWithExpandCheck``6(``0,``0[]@,``1,``1[]@,``2,``2[]@,``3,``3[]@,``4,``4[]@,``5,``5[]@,System.Int32@,System.Int32)">
            <summary>
                Adds a sparse/dense index pair to the set and expands the arrays if necessary.
            </summary>
            <returns>True if the index pool expanded.</returns>
        </member>
        <member name="M:GDX.Collections.SparseSet.AddWithExpandCheck``7(``0,``0[]@,``1,``1[]@,``2,``2[]@,``3,``3[]@,``4,``4[]@,``5,``5[]@,``6,``6[]@,System.Int32@,System.Int32)">
            <summary>
                Adds a sparse/dense index pair to the set and expands the arrays if necessary.
            </summary>
            <returns>True if the index pool expanded.</returns>
        </member>
        <member name="M:GDX.Collections.SparseSet.AddWithExpandCheck``8(``0,``0[]@,``1,``1[]@,``2,``2[]@,``3,``3[]@,``4,``4[]@,``5,``5[]@,``6,``6[]@,``7,``7[]@,System.Int32@,System.Int32)">
            <summary>
                Adds a sparse/dense index pair to the set and expands the arrays if necessary.
            </summary>
            <returns>True if the index pool expanded.</returns>
        </member>
        <member name="M:GDX.Collections.SparseSet.AddUnchecked``1(``0,``0[])">
            <summary>
                Adds to the set without checking if the set needs to expand.
            </summary>
            <returns>The sparse index allocated</returns>
        </member>
        <member name="M:GDX.Collections.SparseSet.AddUnchecked``2(``0,``0[],``1,``1[])">
            <summary>
                Adds to the set without checking if the set needs to expand.
            </summary>
            <returns>The sparse index allocated</returns>
        </member>
        <member name="M:GDX.Collections.SparseSet.AddUnchecked``3(``0,``0[],``1,``1[],``2,``2[])">
            <summary>
                Adds to the set without checking if the set needs to expand.
            </summary>
            <returns>The sparse index allocated</returns>
        </member>
        <member name="M:GDX.Collections.SparseSet.AddUnchecked``4(``0,``0[],``1,``1[],``2,``2[],``3,``3[])">
            <summary>
                Adds to the set without checking if the set needs to expand.
            </summary>
            <returns>The sparse index allocated</returns>
        </member>
        <member name="M:GDX.Collections.SparseSet.AddUnchecked``5(``0,``0[],``1,``1[],``2,``2[],``3,``3[],``4,``4[])">
            <summary>
                Adds to the set without checking if the set needs to expand.
            </summary>
            <returns>The sparse index allocated</returns>
        </member>
        <member name="M:GDX.Collections.SparseSet.AddUnchecked``6(``0,``0[],``1,``1[],``2,``2[],``3,``3[],``4,``4[],``5,``5[])">
            <summary>
                Adds to the set without checking if the set needs to expand.
            </summary>
            <returns>The sparse index allocated</returns>
        </member>
        <member name="M:GDX.Collections.SparseSet.AddUnchecked``7(``0,``0[],``1,``1[],``2,``2[],``3,``3[],``4,``4[],``5,``5[],``6,``6[])">
            <summary>
                Adds to the set without checking if the set needs to expand.
            </summary>
            <returns>The sparse index allocated</returns>
        </member>
        <member name="M:GDX.Collections.SparseSet.AddUnchecked``8(``0,``0[],``1,``1[],``2,``2[],``3,``3[],``4,``4[],``5,``5[],``6,``6[],``7,``7[])">
            <summary>
                Adds to the set without checking if the set needs to expand.
            </summary>
            <returns>The sparse index allocated</returns>
        </member>
        <member name="T:GDX.Collections.BitArray512">
            <summary>
                A 512-bit array.
            </summary>
            <example>
                Useful for packing a bunch of data with known indices tightly.
                <code>
                    if(myBitArray512[1])
                    {
                        BeAwesome();
                    }
                </code>
            </example>
        </member>
        <member name="F:GDX.Collections.BitArray512.Bits0">
            <summary>
                First reserved System.Int32 memory block.
            </summary>
            <remarks>Indices 0-31</remarks>
        </member>
        <member name="F:GDX.Collections.BitArray512.Bits1">
            <summary>
                Second reserved System.Int32 memory block.
            </summary>
            <remarks>Indices 32-63</remarks>
        </member>
        <member name="F:GDX.Collections.BitArray512.Bits2">
            <summary>
                Third reserved System.Int32 memory block.
            </summary>
            <remarks>Indices 64-95</remarks>
        </member>
        <member name="F:GDX.Collections.BitArray512.Bits3">
            <summary>
                Fourth reserved System.Int32 memory block.
            </summary>
            <remarks>Indices 96-127</remarks>
        </member>
        <member name="F:GDX.Collections.BitArray512.Bits4">
            <summary>
                Fifth reserved System.Int32 memory block.
            </summary>
            <remarks>Indices 128-159</remarks>
        </member>
        <member name="F:GDX.Collections.BitArray512.Bits5">
            <summary>
                Sixth reserved System.Int32 memory block.
            </summary>
            <remarks>Indices 160-191</remarks>
        </member>
        <member name="F:GDX.Collections.BitArray512.Bits6">
            <summary>
                Seventh reserved System.Int32 memory block.
            </summary>
            <remarks>Indices 192-223</remarks>
        </member>
        <member name="F:GDX.Collections.BitArray512.Bits7">
            <summary>
                Eighth reserved System.Int32 memory block.
            </summary>
            <remarks>Indices 224-255</remarks>
        </member>
        <member name="F:GDX.Collections.BitArray512.Bits8">
            <summary>
                Ninth reserved System.Int32 memory block.
            </summary>
            <remarks>Indices 256-287</remarks>
        </member>
        <member name="F:GDX.Collections.BitArray512.Bits9">
            <summary>
                Tenth reserved System.Int32 memory block.
            </summary>
            <remarks>Indices 288-319</remarks>
        </member>
        <member name="F:GDX.Collections.BitArray512.Bits10">
            <summary>
                Eleventh reserved System.Int32 memory block.
            </summary>
            <remarks>Indices 320-351</remarks>
        </member>
        <member name="F:GDX.Collections.BitArray512.Bits11">
            <summary>
                Twelfth reserved System.Int32 memory block.
            </summary>
            <remarks>Indices 352-383</remarks>
        </member>
        <member name="F:GDX.Collections.BitArray512.Bits12">
            <summary>
                Thirteenth reserved System.Int32 memory block.
            </summary>
            <remarks>Indices 384-415</remarks>
        </member>
        <member name="F:GDX.Collections.BitArray512.Bits13">
            <summary>
                Fourteenth reserved System.Int32 memory block.
            </summary>
            <remarks>Indices 416-447</remarks>
        </member>
        <member name="F:GDX.Collections.BitArray512.Bits14">
            <summary>
                Fifteenth reserved System.Int32 memory block.
            </summary>
            <remarks>Indices 448-479</remarks>
        </member>
        <member name="F:GDX.Collections.BitArray512.Bits15">
            <summary>
                Sixteenth reserved System.Int32 memory block.
            </summary>
            <remarks>Indices 480-511</remarks>
        </member>
        <member name="P:GDX.Collections.BitArray512.Item(System.Int32)">
            <summary>
                Access bit in array.
            </summary>
            <param name="index">Target bit index.</param>
        </member>
        <member name="T:GDX.Collections.FreeList">
            <summary>
                An array where indices are allocated from and stored in an in-place linked list.
                Allocating or deallocating a single int from this array is very fast, as is single datum lookup,
                but neither the allocated indices nor the free indices can be reliably iterated without an external data structure.
                This structure can be adapted to an arbitrary of external, parallel arrays.
            </summary>
        </member>
        <member name="F:GDX.Collections.FreeList.Indices">
            <summary>
                Data storage for allocated indices as well as the in-place free-list.
            </summary>
        </member>
        <member name="F:GDX.Collections.FreeList.CurrentFreeIndex">
            <summary>
                The next available index of the free-list.
            </summary>
        </member>
        <member name="F:GDX.Collections.FreeList.Count">
            <summary>
                The total number of currently-allocated indices.
            </summary>
        </member>
        <member name="M:GDX.Collections.FreeList.#ctor(System.Int32)">
            <summary>
            </summary>
            <param name="initialCapacity">The initial capacity of the array.</param>
        </member>
        <member name="M:GDX.Collections.FreeList.Clear">
            <summary>
                Removes all allocated data and rebuilds the free-list.
            </summary>
        </member>
        <member name="M:GDX.Collections.FreeList.AddWithExpandCheck(System.Int32,System.Int32@,System.Int32)">
            <summary>
                Allocates an index from the free-list and stores an integer there, expanding the array if necessary.
            </summary>
            <param name="data">The integer value to store at the allocated index.</param>
            <param name="allocatedIndex">The index allocated from the free-list.</param>
            <param name="expandBy">How much the array should expand by when out of space.</param>
            <returns>True if the array expanded.</returns>
        </member>
        <member name="M:GDX.Collections.FreeList.AddWithExpandCheck(System.Int32,System.Int32@)">
            <summary>
                Allocates an index from the free-list and stores an integer there, expanding the array by twice the current size if
                necessary.
            </summary>
            <param name="data">The integer value to store at the allocated index.</param>
            <param name="allocatedIndex">The index allocated from the free-list.</param>
            <returns>True if the array expanded.</returns>
        </member>
        <member name="M:GDX.Collections.FreeList.AddUnchecked(System.Int32)">
            <summary>
                Allocates an index from the free-list and stores an integer there, without checking for expansion.
            </summary>
            <param name="data">The integer value to store at the allocated index.</param>
            <returns>The index allocated from the free-list.</returns>
        </member>
        <member name="M:GDX.Collections.FreeList.RemoveAt(System.Int32)">
            <summary>
                Deallocates the given index and adds it to the free-list.
            </summary>
            <param name="index">The index to add to the free-list.</param>
        </member>
        <member name="M:GDX.Collections.FreeList.GetAndRemoveAt(System.Int32)">
            <summary>
                Retrieves the value stored at the given index and deallocates the index, adding it to the free-list.
            </summary>
            <param name="index">The index to add to the free-list.</param>
            <returns>The value stored at the given index.</returns>
        </member>
        <member name="T:GDX.Mathematics.Smooth">
            <summary>
                Some helpful interpolation functionality.
            </summary>
        </member>
        <member name="M:GDX.Mathematics.Smooth.Exponential(System.Single,System.Single,System.Single,System.Single)">
            <summary>
                Smooths between previousValue and targetValue based on time since
                the last sample and a given half-life.
            </summary>
            <remarks>Assumes wibbly wobbly, timey wimey.</remarks>
            <param name="previousValue">Ideally, the previous output value.</param>
            <param name="targetValue">The target value.</param>
            <param name="halfLife">
                Half of the time it would take to go from previousValue to
                targetValue if time were constant.
            </param>
            <param name="elapsedTime">
                The amount of time that has transpired since the previousValue was
                generated.
            </param>
            <returns>A smoothed value.</returns>
        </member>
        <member name="M:GDX.Mathematics.Smooth.HalfLifeToSmoothingFactor(System.Single,System.Single)">
            <summary>
                Takes a halfLife value, and outputs a factor based on elapsedTime.
            </summary>
            <remarks>Not providing a value for elapsedTime will result in using <c>Time.deltaTime</c>.</remarks>
            <param name="halfLife">The desired half-life.</param>
            <param name="elapsedTime">The time since the last sample.</param>
            <returns>The coefficient value applied to the weight(t) of a lerp.</returns>
        </member>
        <member name="M:GDX.Mathematics.Random.IRandomProvider.NextBoolean(System.Single)">
            <summary>
                Returns a pseudorandom System.Boolean value based on chance, favoring false,
                with a default 50% chance.
            </summary>
            <param name="chance">The 0-1 System.Single percent chance of success.</param>
            <returns>A pseudorandom System.Boolean.</returns>
        </member>
        <member name="M:GDX.Mathematics.Random.IRandomProvider.NextBytes(System.Byte[])">
            <summary>
                Fills a buffer with pseudorandom System.Byte.
            </summary>
            <remarks>
                The buffer shouldn't be null.
            </remarks>
            <param name="buffer">The buffer to fill.</param>
        </member>
        <member name="M:GDX.Mathematics.Random.IRandomProvider.NextDouble(System.Double,System.Double)">
            <summary>
                Returns the next pseudorandom System.Double between minValue and
                less then maxValue.
            </summary>
            <remarks>
                Distribution of values falls within a linear scale.
                minValue should not be greater then maxValue.
            </remarks>
            <param name="minValue">The lowest possible value (inclusive).</param>
            <param name="maxValue">The highest possible value (exclusive).</param>
            <returns>A pseudorandom System.Double.</returns>
        </member>
        <member name="M:GDX.Mathematics.Random.IRandomProvider.NextInteger(System.Int32,System.Int32)">
            <summary>
                Returns the next pseudorandom System.Int32 between minValue and
                maxValue.
            </summary>
            <remarks>
                Distribution of values falls within a linear scale.
                minValue should not be greater then maxValue.
                Never pass System.Int32.MaxValue to maxValue.
            </remarks>
            <param name="minValue">The lowest possible value.</param>
            <param name="maxValue">The highest possible value, including itself.</param>
            <returns>A pseudorandom System.Int32.</returns>
        </member>
        <member name="M:GDX.Mathematics.Random.IRandomProvider.NextIntegerExclusive(System.Int32,System.Int32)">
            <summary>
                Returns the next pseudorandom System.Int32 between minValue and
                maxValue, excluding maxValue itself.
            </summary>
            <remarks>
                Distribution of values falls within a linear scale.
                minValue should not be greater then maxValue.
            </remarks>
            <param name="minValue">The lowest possible value.</param>
            <param name="maxValue">The highest possible value, excluding itself.</param>
            <returns>A pseudorandom System.Int32.</returns>
        </member>
        <member name="M:GDX.Mathematics.Random.IRandomProvider.NextSingle(System.Single,System.Single)">
            <summary>
                Returns the next pseudorandom System.Single between minValue and
                less then maxValue.
            </summary>
            <remarks>
                Distribution of values falls within a linear scale.
                minValue should not be greater then maxValue.
            </remarks>
            <param name="minValue">The lowest possible value (inclusive).</param>
            <param name="maxValue">The highest possible value (exclusive).</param>
            <returns>A pseudorandom System.Single.</returns>
        </member>
        <member name="M:GDX.Mathematics.Random.IRandomProvider.NextUnsignedInteger(System.UInt32,System.UInt32)">
            <summary>
                Returns the next pseudorandom System.UInt32 between minValue and
                maxValue.
            </summary>
            <remarks>
                Distribution of values falls within a linear scale.
                minValue should not be greater then maxValue.
                Never pass System.UInt32.MaxValue to maxValue.
            </remarks>
            <param name="minValue">The lowest possible value.</param>
            <param name="maxValue">The highest possible value, including itself.</param>
            <returns>A pseudorandom System.UInt32.</returns>
        </member>
        <member name="M:GDX.Mathematics.Random.IRandomProvider.NextUnsignedIntegerExclusive(System.UInt32,System.UInt32)">
            <summary>
                Returns the next pseudorandom System.UInt32 between minValue and
                maxValue, excluding maxValue itself.
            </summary>
            <remarks>
                Distribution of values falls within a linear scale.
                minValue should not be greater then maxValue.
            </remarks>
            <param name="minValue">The lowest possible value.</param>
            <param name="maxValue">The highest possible value, excluding itself.</param>
            <returns>A pseudorandom System.UInt32.</returns>
        </member>
        <member name="M:GDX.Mathematics.Random.IRandomProvider.Sample">
            <summary>
                Returns the next pseudorandom System.Double value, between 0.0 and 1.0.
            </summary>
            <returns>A pseudorandom System.Double floating point value.</returns>
        </member>
        <member name="M:GDX.Mathematics.Random.RandomWrapper.NextBoolean(System.Single)">
            <inheritdoc />
        </member>
        <member name="M:GDX.Mathematics.Random.RandomWrapper.NextBytes(System.Byte[])">
            <inheritdoc />
        </member>
        <member name="M:GDX.Mathematics.Random.RandomWrapper.NextDouble(System.Double,System.Double)">
            <inheritdoc />
        </member>
        <member name="M:GDX.Mathematics.Random.RandomWrapper.NextInteger(System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:GDX.Mathematics.Random.RandomWrapper.NextIntegerExclusive(System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:GDX.Mathematics.Random.RandomWrapper.NextSingle(System.Single,System.Single)">
            <inheritdoc />
        </member>
        <member name="M:GDX.Mathematics.Random.RandomWrapper.NextUnsignedInteger(System.UInt32,System.UInt32)">
            <inheritdoc />
        </member>
        <member name="M:GDX.Mathematics.Random.RandomWrapper.NextUnsignedIntegerExclusive(System.UInt32,System.UInt32)">
            <inheritdoc />
        </member>
        <member name="M:GDX.Mathematics.Random.RandomWrapper.Sample">
            <inheritdoc />
        </member>
        <member name="T:GDX.Mathematics.Random.WELL1024a">
            <summary>
                Generates pseudorandom values based on the WELL1024a algorithm. You must GDX.Mathematics.Random.WELL1024a.Dispose manually.
            </summary>
            <remarks>
                Primarily based on the work of <a href="http://lomont.org/papers/2008/Lomont_PRNG_2008.pdf">Chris Lomont</a>,
                accessed on 2021-04-23.
                Additional understanding from
                <a href="http://www.iro.umontreal.ca/~lecuyer/myftp/papers/lfsr04.pdf">Francois Panneton and Pierre L`Ecuyer</a>,
                accessed on 2021-04-23.
            </remarks>
        </member>
        <member name="F:GDX.Mathematics.Random.WELL1024a.State">
            <summary>
                The state array of the well.
            </summary>
        </member>
        <member name="F:GDX.Mathematics.Random.WELL1024a.OriginalSeed">
            <summary>
                A copy of the original seed used to initialize the GDX.Mathematics.Random.WELL1024a.
            </summary>
        </member>
        <member name="F:GDX.Mathematics.Random.WELL1024a.SampleCount">
            <summary>
                The number of times that this well has been sampled.
            </summary>
        </member>
        <member name="F:GDX.Mathematics.Random.WELL1024a.Index">
            <summary>
                The current index of use for the well array.
            </summary>
            <remarks>CAUTION! Changing this will alter the understanding of the data.</remarks>
        </member>
        <member name="M:GDX.Mathematics.Random.WELL1024a.#ctor(System.Int32)">
            <summary>
                Creates a new pseudorandom number generator with the given seed.
            </summary>
            <remarks>
                The seed will have its sign stripped and stored as such in
                GDX.Mathematics.Random.WELL1024a.OriginalSeed.
            </remarks>
            <param name="seed">A System.Int32 value to use as a seed.</param>
        </member>
        <member name="M:GDX.Mathematics.Random.WELL1024a.#ctor(System.UInt32)">
            <summary>
                Creates a new pseudorandom number generator with the given seed.
            </summary>
            <param name="seed">A System.UInt32 value to use as a seed.</param>
        </member>
        <member name="M:GDX.Mathematics.Random.WELL1024a.#ctor(System.String,System.Boolean)">
            <summary>
                Creates a new pseudorandom number generator with the given seed.
            </summary>
            <remarks>
                The created hashcode will have its sign stripped and stored as such in
                GDX.Mathematics.Random.WELL1024a.OriginalSeed.
            </remarks>
            <param name="seed">A System.String to create a System.UInt32 seed from.</param>
            <param name="forceUpperCase">
                Should the generated hashcode used as the seed be generated from an uppercase version of
                the seed.
            </param>
        </member>
        <member name="M:GDX.Mathematics.Random.WELL1024a.#ctor(GDX.Mathematics.Random.WELL1024a.WellState)">
            <summary>
                Create a pseudorandom number generator from a restoreState.
            </summary>
            <param name="restoreState">A saved GDX.Mathematics.Random.WELL1024a state.</param>
        </member>
        <member name="M:GDX.Mathematics.Random.WELL1024a.GetState">
            <summary>
                Get a GDX.Mathematics.Random.WELL1024a.WellState for the GDX.Mathematics.Random.WELL1024a.
            </summary>
            <remarks>Useful to save and restore the state of the GDX.Mathematics.Random.WELL1024a.</remarks>
            <returns></returns>
        </member>
        <member name="M:GDX.Mathematics.Random.WELL1024a.NextBoolean(System.Single)">
            <inheritdoc cref="M:GDX.Mathematics.Random.IRandomProvider.NextBoolean(System.Single)" />
        </member>
        <member name="M:GDX.Mathematics.Random.WELL1024a.NextBytes(System.Byte[])">
            <inheritdoc cref="M:GDX.Mathematics.Random.IRandomProvider.NextBytes(System.Byte[])" />
        </member>
        <member name="M:GDX.Mathematics.Random.WELL1024a.NextDouble(System.Double,System.Double)">
            <inheritdoc cref="M:GDX.Mathematics.Random.IRandomProvider.NextDouble(System.Double,System.Double)" />
        </member>
        <member name="M:GDX.Mathematics.Random.WELL1024a.NextInteger(System.Int32,System.Int32)">
            <inheritdoc cref="M:GDX.Mathematics.Random.IRandomProvider.NextInteger(System.Int32,System.Int32)" />
        </member>
        <member name="M:GDX.Mathematics.Random.WELL1024a.NextIntegerExclusive(System.Int32,System.Int32)">
            <inheritdoc cref="M:GDX.Mathematics.Random.IRandomProvider.NextIntegerExclusive(System.Int32,System.Int32)" />
        </member>
        <member name="M:GDX.Mathematics.Random.WELL1024a.NextSingle(System.Single,System.Single)">
            <inheritdoc cref="M:GDX.Mathematics.Random.IRandomProvider.NextSingle(System.Single,System.Single)" />
        </member>
        <member name="M:GDX.Mathematics.Random.WELL1024a.NextUnsignedInteger(System.UInt32,System.UInt32)">
            <inheritdoc cref="M:GDX.Mathematics.Random.IRandomProvider.NextUnsignedInteger(System.UInt32,System.UInt32)" />
        </member>
        <member name="M:GDX.Mathematics.Random.WELL1024a.NextUnsignedIntegerExclusive(System.UInt32,System.UInt32)">
            <inheritdoc cref="M:GDX.Mathematics.Random.IRandomProvider.NextUnsignedIntegerExclusive(System.UInt32,System.UInt32)" />
        </member>
        <member name="M:GDX.Mathematics.Random.WELL1024a.Sample">
            <inheritdoc cref="M:GDX.Mathematics.Random.IRandomProvider.Sample" />
        </member>
        <member name="T:GDX.Mathematics.Random.WELL1024a.WellState">
            <summary>
                A complete state of GDX.Mathematics.Random.WELL1024a.
            </summary>
        </member>
        <member name="F:GDX.Mathematics.Random.WELL1024a.WellState.State">
            <summary>
                The internal state array.
            </summary>
        </member>
        <member name="F:GDX.Mathematics.Random.WELL1024a.WellState.Seed">
            <summary>
                The seed used to originally create the GDX.Mathematics.Random.WELL1024a.
            </summary>
        </member>
        <member name="F:GDX.Mathematics.Random.WELL1024a.WellState.Count">
            <summary>
                The internal sample count.
            </summary>
        </member>
        <member name="F:GDX.Mathematics.Random.WELL1024a.WellState.Index">
            <summary>
                The internal state index.
            </summary>
        </member>
        <member name="M:GDX.Mathematics.Random.WELL1024a.Dispose">
            <summary>
                Disposes of the native allocations.
            </summary>
        </member>
        <member name="M:GDX.Mathematics.Random.WELL1024a.Equals(GDX.Mathematics.Random.WELL1024a@)">
            <summary>
                Is one GDX.Mathematics.Random.WELL1024a the same as the other.
            </summary>
            <param name="other">The GDX.Mathematics.Random.WELL1024a to compare with.</param>
            <returns>true/false if they are fundamentally the same.</returns>
        </member>
        <member name="M:GDX.Mathematics.Random.WELL1024a.Equals(GDX.Mathematics.Random.WELL1024a)">
            <summary>
                Is one GDX.Mathematics.Random.WELL1024a the same as the other.
            </summary>
            <remarks>
                Avoid using this format for comparison as it copies the data, where as
                GDX.Mathematics.Random.WELL1024a.Equals(GDX.Mathematics.Random.WELL1024a@) does not.
            </remarks>
            <param name="other">The GDX.Mathematics.Random.WELL1024a to compare with.</param>
            <returns>true/false if they are fundamentally the same.</returns>
        </member>
        <member name="M:GDX.Mathematics.Random.WELL1024a.Equals(System.Object)">
            <summary>
                Determines if the provided obj's hash code is equal to this GDX.Mathematics.Random.WELL1024a's
                GDX.Mathematics.Random.WELL1024a.GetHashCode.
            </summary>
            <remarks>
                This doesnt preclude other objects of different types from having the same hashcode.
            </remarks>
            <param name="obj">The System.Object to compare hash codes with.</param>
            <returns>true/false if the hash codes match.</returns>
        </member>
        <member name="M:GDX.Mathematics.Random.WELL1024a.GetHashCode">
            <summary>
                Generate a hash code value for the given GDX.Mathematics.Random.WELL1024a at its current state.
            </summary>
            <returns>The hash code value.</returns>
        </member>
        <member name="T:GDX.Mathematics.Random.RandomAdaptor">
            <summary>
                Adapter to utilize a GDX.Mathematics.Random.IRandomProvider with System.Random based systems, wrapping the
                provider in a class object with expected overrides.
            </summary>
            <remarks>This will create IL <c>callvert</c> operation codes! Try not to use this.</remarks>
        </member>
        <member name="M:GDX.Mathematics.Random.RandomAdaptor.#ctor(GDX.Mathematics.Random.IRandomProvider)">
            <summary>
                Create an adaptor object which behaves like System.Random.
            </summary>
            <remarks>
                Will cause boxing of struct based types like GDX.Mathematics.Random.WELL1024a.
                This adaptor really should only be used where a method is expecting a System.Random.
            </remarks>
            <param name="provider">A qualified GDX.Mathematics.Random.IRandomProvider.</param>
        </member>
        <member name="M:GDX.Mathematics.Random.RandomAdaptor.HasProvider">
            <summary>
                Is the provider present, and not null?
            </summary>
            <returns>true/false a provider is not null.</returns>
        </member>
        <member name="T:GDX.Mathematics.Rotate">
            <summary>
            A set of functionality to extend on Unity's rotation based methods.
            </summary>
        </member>
        <member name="M:GDX.Mathematics.Rotate.Towards(UnityEngine.Quaternion,UnityEngine.Quaternion,System.Single,System.Single)">
            <summary>
            Create a quaternion based on a rotation from targetQuaternion to otherQuaternion.
            </summary>
            <param name="targetQuaternion">The source UnityEngine.Quaternion.</param>
            <param name="otherQuaternion">The destination UnityEngine.Quaternion.</param>
            <param name="rotationRate">How fast should the rotation occur.</param>
            <param name="elapsedTime">How long has elapsed since the rotation started.</param>
            <returns>A rotational value.</returns>
            <exception cref="T:GDX.UnsupportedRuntimeException">Not supported on DOTS Runtime.</exception>
        </member>
        <member name="T:GDX.Mathematics.Range">
            <summary>
                Some simple logic to pick a value from a range.
            </summary>
        </member>
        <member name="M:GDX.Mathematics.Range.GetDouble(System.Double,System.Double,System.Double)">
            <summary>
                Returns the System.Double between minValue and
                maxValue range at percent.
            </summary>
            <param name="percent">The percentage (0-1) used to find a value in the range provided.</param>
            <param name="minValue">The lowest possible value.</param>
            <param name="maxValue">The highest possible value.</param>
            <returns>A System.Double value.</returns>
        </member>
        <member name="M:GDX.Mathematics.Range.GetInteger(System.Double,System.Int32,System.Int32)">
            <summary>
                Returns the System.Int32 between minValue and
                maxValue range at percent.
            </summary>
            <param name="percent">The percentage (0-1) used to find a value in the range provided.</param>
            <param name="minValue">The lowest possible value.</param>
            <param name="maxValue">The highest possible value.</param>
            <returns>The System.Int32 value.</returns>
        </member>
        <member name="M:GDX.Mathematics.Range.GetSingle(System.Double,System.Single,System.Single)">
            <summary>
                Returns the System.Single between minValue and
                maxValue range at percent.
            </summary>
            <param name="percent">The percentage (0-1) used to find a value in the range provided.</param>
            <param name="minValue">The lowest possible value.</param>
            <param name="maxValue">The highest possible value.</param>
            <returns>A System.Single value.</returns>
        </member>
        <member name="M:GDX.Mathematics.Range.GetUnsignedInteger(System.Double,System.UInt32,System.UInt32)">
            <summary>
                Returns the System.UInt32 between minValue and
                maxValue range at percent.
            </summary>
            <param name="percent">The percentage (0-1) used to find a value in the range provided.</param>
            <param name="minValue">The lowest possible value.</param>
            <param name="maxValue">The highest possible value.</param>
            <returns>A System.UInt32 value.</returns>
        </member>
        <member name="M:GDX.Mathematics.FibonacciHash.GetRightShiftFromPow2Length(System.Int32)">
            <summary>
            Takes a 32-bit length equal to a power of two,
            and returns how many spaces another 32-bit int would need to shift in order to be a valid index within an array of that length.
            </summary>
            <param name="pow2Length">A 32-bit int equal to a power of two.</param>
            <returns>How many spaces a 32-bit int would need to shift in order to be a valid index within pow2Length.</returns>
        </member>
        <member name="M:GDX.Mathematics.FibonacciHash.GetIndexFromHash(System.Int32,System.Byte)">
            <summary>
            Takes the hash and multiplies it by 2^32 divided by the golden ratio,
            then right shifts it by shift to fit within a given power-of-two size.
            </summary>
            <param name="hash">The key to find an index for.</param>
            <param name="shift">How far to right shift in order to fit within a given power-of-two size.</param>
            <returns>The index to store the hash.</returns>
        </member>
        <member name="M:GDX.Mathematics.FibonacciHash.GetIndexFromHash(System.Int32,System.Int32)">
            <summary>
            Takes the hash and finds an index within the provided pow2Length range with Fibonacci hashing.
            </summary>
            <param name="hash">The hash to find an index for.</param>
            <param name="pow2Length">The power-of-two array length to find an index within.</param>
            <returns></returns>
        </member>
        <member name="T:GDX.Mathematics.Byte2">
            <summary>
                A System.Byte vector.
            </summary>
        </member>
        <member name="F:GDX.Mathematics.Byte2.X">
            <summary>
                X System.Byte.
            </summary>
        </member>
        <member name="F:GDX.Mathematics.Byte2.Y">
            <summary>
                Y System.Byte.
            </summary>
        </member>
        <member name="M:GDX.Mathematics.Byte2.#ctor(System.Int32,System.Int32)">
            <summary>
                Create a GDX.Mathematics.Byte2 from two System.Int32 values.
            </summary>
            <param name="x">X value.</param>
            <param name="y">Y value.</param>
        </member>
        <member name="M:GDX.Mathematics.Byte2.#ctor(System.Byte,System.Byte)">
            <summary>
                Constructs a GDX.Mathematics.Byte2 from two System.Byte values.
            </summary>
            <param name="x">X value.</param>
            <param name="y">Y value.</param>
        </member>
        <member name="M:GDX.Mathematics.Byte2.#ctor(GDX.Mathematics.Byte2)">
            <summary>
                Constructs a GDX.Mathematics.Byte2 from a GDX.Mathematics.Byte2 value.
            </summary>
            <param name="xy">The value to copy.</param>
        </member>
        <member name="M:GDX.Mathematics.Byte2.#ctor(System.Byte)">
            <summary>
                Constructs a GDX.Mathematics.Byte2 from a single System.Byte value by assigning it to every component.
            </summary>
            <param name="v">The value to copy to GDX.Mathematics.Byte2.X and GDX.Mathematics.Byte2.Y.</param>
        </member>
        <member name="M:GDX.Mathematics.Byte2.#ctor(System.Boolean)">
            <summary>
                Constructs a GDX.Mathematics.Byte2 from a single System.Boolean value by converting it to System.Byte
                and assigning it to every component.
            </summary>
            <param name="v">The System.Boolean value to transcribe.</param>
        </member>
        <member name="M:GDX.Mathematics.Byte2.#ctor(System.Single)">
            <summary>
                Constructs a GDX.Mathematics.Byte2 from a single System.Single value by converting it to System.Byte
                and assigning it to every component.
            </summary>
            <param name="v">The System.Single value to transcribe.</param>
        </member>
        <member name="M:GDX.Mathematics.Byte2.#ctor(System.Double)">
            <summary>
                Constructs a GDX.Mathematics.Byte2 from a single System.Double value by converting it to System.Byte
                and assigning it to every component.
            </summary>
            <param name="v">The System.Double value to transcribe.</param>
        </member>
        <member name="M:GDX.Mathematics.Byte2.#ctor(Unity.Mathematics.bool2)">
            <summary>
                Constructs a GDX.Mathematics.Byte2 from a Unity.Mathematics.bool2 by conversion.
            </summary>
            <param name="v">The value to transcribe.</param>
        </member>
        <member name="M:GDX.Mathematics.Byte2.#ctor(Unity.Mathematics.float2)">
            <summary>
                Constructs a GDX.Mathematics.Byte2 from a Unity.Mathematics.float2 by conversion.
            </summary>
            <param name="v">The value to transcribe.</param>
        </member>
        <member name="M:GDX.Mathematics.Byte2.#ctor(Unity.Mathematics.double2)">
            <summary>
                Constructs a GDX.Mathematics.Byte2 from a Unity.Mathematics.double2 by conversion.
            </summary>
            <param name="v">The value to transcribe.</param>
        </member>
        <member name="P:GDX.Mathematics.Byte2.XX">
            <summary>
                Get a new GDX.Mathematics.Byte2 created with GDX.Mathematics.Byte2.X as both components.
            </summary>
        </member>
        <member name="P:GDX.Mathematics.Byte2.XY">
            <summary>
                Get a new GDX.Mathematics.Byte2 created with identical components.
            </summary>
        </member>
        <member name="P:GDX.Mathematics.Byte2.YX">
            <summary>
                Get a new GDX.Mathematics.Byte2 created with swapped components.
            </summary>
        </member>
        <member name="P:GDX.Mathematics.Byte2.YY">
            <summary>
                Get a new GDX.Mathematics.Byte2 created with GDX.Mathematics.Byte2.Y as both components.
            </summary>
        </member>
        <member name="P:GDX.Mathematics.Byte2.Item(System.Int32)">
            <summary>
                Get the System.Byte at the provided index.
            </summary>
            <param name="index">Returns the byte element at a specified index.</param>
            <exception cref="T:System.IndexOutOfRangeException">Out of range check.</exception>
        </member>
        <member name="M:GDX.Mathematics.Byte2.Equals(GDX.Mathematics.Byte2)">
            <summary>
                Does the GDX.Mathematics.Byte2 equal another GDX.Mathematics.Byte2.
            </summary>
            <param name="rhs">Target GDX.Mathematics.Byte2 to compare with.</param>
            <returns>Returns true if the GDX.Mathematics.Byte2 is equal to a given GDX.Mathematics.Byte2, false otherwise.</returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.ToString(System.String,System.IFormatProvider)">
            <summary>
                Convert the GDX.Mathematics.Byte2 to a System.String using the provided format.
            </summary>
            <param name="format">Specified format System.String.</param>
            <param name="formatProvider">Culture-specific format information.</param>
            <returns>
                Returns a string representation of the GDX.Mathematics.Byte2 using a specified format and culture-specific
                format information.
            </returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.Equals(System.Object)">
            <summary>
                Does the GDX.Mathematics.Byte2 equal another System.Object (casted).
            </summary>
            <param name="o">Target System.Object to compare with.</param>
            <returns>Returns true if the GDX.Mathematics.Byte2 is equal to a given GDX.Mathematics.Byte2, false otherwise.</returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_Implicit(System.Byte)~GDX.Mathematics.Byte2">
            <summary>
                Implicitly converts a single System.Byte value to a GDX.Mathematics.Byte2 by assigning it to every
                component.
            </summary>
            <param name="v">The System.Byte value to transcribe.</param>
            <returns>A new GDX.Mathematics.Byte2.</returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_Explicit(System.Boolean)~GDX.Mathematics.Byte2">
            <summary>
                Explicitly converts a single System.Boolean value to a GDX.Mathematics.Byte2 by converting it to
                System.Byte and assigning it to every component.
            </summary>
            <param name="v">The System.Boolean value to transcribe.</param>
            <returns>A new GDX.Mathematics.Byte2.</returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_Explicit(System.Single)~GDX.Mathematics.Byte2">
            <summary>
                Explicitly converts a single System.Single value to a GDX.Mathematics.Byte2 by converting it to
                System.Byte and assigning it to every component.
            </summary>
            <param name="v">The System.Single value to transcribe.</param>
            <returns>A new GDX.Mathematics.Byte2.</returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_Explicit(System.Double)~GDX.Mathematics.Byte2">
            <summary>
                Explicitly converts a single System.Double value to a GDX.Mathematics.Byte2 by converting it to
                System.Byte and assigning it to every component.
            </summary>
            <param name="v">The System.Double value to transcribe.</param>
            <returns>A new GDX.Mathematics.Byte2.</returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_Multiply(GDX.Mathematics.Byte2,GDX.Mathematics.Byte2)">
            <summary>
                Multiply two GDX.Mathematics.Byte2.
            </summary>
            <param name="lhs">Left-hand side GDX.Mathematics.Byte2.</param>
            <param name="rhs">Right-hand side GDX.Mathematics.Byte2.</param>
            <returns>Returns the result of a  multiplication operation on two GDX.Mathematics.Byte2.</returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_Multiply(GDX.Mathematics.Byte2,System.Byte)">
            <summary>
                Multiply a GDX.Mathematics.Byte2 by a System.Byte.
            </summary>
            <param name="lhs">Left-hand side GDX.Mathematics.Byte2.</param>
            <param name="rhs">Right-hand side System.Byte.</param>
            <returns>
                Returns the result of a multiplication operation on a GDX.Mathematics.Byte2 and a
                System.Byte value.
            </returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_Multiply(System.Byte,GDX.Mathematics.Byte2)">
            <summary>
                Multiply a System.Byte by a GDX.Mathematics.Byte2.
            </summary>
            <param name="lhs">Left-hand side System.Byte.</param>
            <param name="rhs">Right-hand side GDX.Mathematics.Byte2.</param>
            <returns>
                Returns the result of a multiplication operation on a System.Byte and a
                GDX.Mathematics.Byte2 value.
            </returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_Addition(GDX.Mathematics.Byte2,GDX.Mathematics.Byte2)">
            <summary>
                Add two GDX.Mathematics.Byte2.
            </summary>
            <param name="lhs">Left-hand side GDX.Mathematics.Byte2.</param>
            <param name="rhs">Right-hand side GDX.Mathematics.Byte2.</param>
            <returns>Returns the result of an addition operation on two GDX.Mathematics.Byte2.</returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_Addition(GDX.Mathematics.Byte2,System.Byte)">
            <summary>
                Add a System.Byte to both components of a GDX.Mathematics.Byte2.
            </summary>
            <param name="lhs">Left-hand side GDX.Mathematics.Byte2.</param>
            <param name="rhs">Right-hand side System.Byte.</param>
            <returns>
                Returns the result of an addition operation on an GDX.Mathematics.Byte2 and an System.Byte
                value.
            </returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_Addition(System.Byte,GDX.Mathematics.Byte2)">
            <summary>
                Add a GDX.Mathematics.Byte2 to a System.Byte.
            </summary>
            <param name="lhs">Left-hand side System.Byte.</param>
            <param name="rhs">Right-hand side GDX.Mathematics.Byte2.</param>
            <returns>
                Returns the result of an addition operation on an System.Byte value and an
                GDX.Mathematics.Byte2.
            </returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_Subtraction(GDX.Mathematics.Byte2,GDX.Mathematics.Byte2)">
            <summary>
                Subtract a GDX.Mathematics.Byte2 from another GDX.Mathematics.Byte2.
            </summary>
            <param name="lhs">Left-hand side GDX.Mathematics.Byte2.</param>
            <param name="rhs">Right-hand side GDX.Mathematics.Byte2.</param>
            <returns>Returns the result of a subtraction operation on two GDX.Mathematics.Byte2.</returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_Subtraction(GDX.Mathematics.Byte2,System.Byte)">
            <summary>
                Subtract a System.Byte from both components of a GDX.Mathematics.Byte2.
            </summary>
            <param name="lhs">Left-hand side GDX.Mathematics.Byte2.</param>
            <param name="rhs">Right-hand side System.Byte.</param>
            <returns>
                Returns the result of a subtraction operation on a GDX.Mathematics.Byte2 and a System.Byte
                value.
            </returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_Subtraction(System.Byte,GDX.Mathematics.Byte2)">
            <summary>
                Subtract both components of a GDX.Mathematics.Byte2 from a System.Byte.
            </summary>
            <param name="lhs">Left-hand side System.Byte.</param>
            <param name="rhs">Right-hand side GDX.Mathematics.Byte2.</param>
            <returns>
                Returns the result of a subtraction operation on an System.Byte value and an
                GDX.Mathematics.Byte2.
            </returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_Division(GDX.Mathematics.Byte2,GDX.Mathematics.Byte2)">
            <summary>
                Divide a GDX.Mathematics.Byte2 by another GDX.Mathematics.Byte2.
            </summary>
            <param name="lhs">Left-hand side GDX.Mathematics.Byte2.</param>
            <param name="rhs">Right-hand side GDX.Mathematics.Byte2.</param>
            <returns>Returns the result of a division operation on two GDX.Mathematics.Byte2.</returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_Division(GDX.Mathematics.Byte2,System.Byte)">
            <summary>
                Divide a GDX.Mathematics.Byte2 by a System.Byte.
            </summary>
            <param name="lhs">Left-hand side GDX.Mathematics.Byte2.</param>
            <param name="rhs">Right-hand side System.Byte.</param>
            <returns>
                Returns the result of a division operation on a GDX.Mathematics.Byte2 and System.Byte
                value.
            </returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_Division(System.Byte,GDX.Mathematics.Byte2)">
            <summary>
                Divide a System.Byte by a GDX.Mathematics.Byte2.
            </summary>
            <param name="lhs">Left-hand side System.Byte.</param>
            <param name="rhs">Right-hand side GDX.Mathematics.Byte2.</param>
            <returns>
                Returns the result of a division operation on a System.Byte value and
                GDX.Mathematics.Byte2.
            </returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_Modulus(GDX.Mathematics.Byte2,GDX.Mathematics.Byte2)">
            <summary>
                Modulus a GDX.Mathematics.Byte2 by another GDX.Mathematics.Byte2.
            </summary>
            <param name="lhs">Left-hand side GDX.Mathematics.Byte2.</param>
            <param name="rhs">Right-hand side GDX.Mathematics.Byte2.</param>
            <returns>Returns the result of a modulus operation on two GDX.Mathematics.Byte2.</returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_Modulus(GDX.Mathematics.Byte2,System.Byte)">
            <summary>
                Modulus a GDX.Mathematics.Byte2 by a System.Byte.
            </summary>
            <param name="lhs">Left-hand side GDX.Mathematics.Byte2.</param>
            <param name="rhs">Right-hand side System.Byte.</param>
            <returns>
                Returns the result of a modulus operation on a GDX.Mathematics.Byte2 and System.Byte
                value.
            </returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_Modulus(System.Byte,GDX.Mathematics.Byte2)">
            <summary>
                Modulus a System.Byte by a GDX.Mathematics.Byte2.
            </summary>
            <param name="lhs">Left-hand side System.Byte.</param>
            <param name="rhs">Right-hand side GDX.Mathematics.Byte2.</param>
            <returns>
                Returns the result of a modulus operation on a System.Byte value and
                GDX.Mathematics.Byte2.
            </returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_Increment(GDX.Mathematics.Byte2)">
            <summary>
                Increment GDX.Mathematics.Byte2 values.
            </summary>
            <param name="val">Target GDX.Mathematics.Byte2.</param>
            <returns>Returns the result of an increment operation on a GDX.Mathematics.Byte2.</returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_Decrement(GDX.Mathematics.Byte2)">
            <summary>
                Decrement GDX.Mathematics.Byte2 values.
            </summary>
            <param name="val">Target GDX.Mathematics.Byte2.</param>
            <returns>Returns the result of a decrement operation on a GDX.Mathematics.Byte2.</returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_UnaryNegation(GDX.Mathematics.Byte2)">
            <summary>
                Unary minus GDX.Mathematics.Byte2 values.
            </summary>
            <param name="val">Target GDX.Mathematics.Byte2.</param>
            <returns>Returns the result of an unary minus operation on a GDX.Mathematics.Byte2.</returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_UnaryPlus(GDX.Mathematics.Byte2)">
            <summary>
                Unary plus GDX.Mathematics.Byte2 values.
            </summary>
            <param name="val">Target GDX.Mathematics.Byte2.</param>
            <returns>Returns the result of an unary plus operation on a GDX.Mathematics.Byte2.</returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_OnesComplement(GDX.Mathematics.Byte2)">
            <summary>
                Bitwise NOT GDX.Mathematics.Byte2 values.
            </summary>
            <param name="val">Target GDX.Mathematics.Byte2.</param>
            <returns>Returns the result of a bitwise NOT operation on a GDX.Mathematics.Byte2.</returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_BitwiseAnd(GDX.Mathematics.Byte2,GDX.Mathematics.Byte2)">
            <summary>
                Bitwise AND two GDX.Mathematics.Byte2 values.
            </summary>
            <param name="lhs">Left-hand side GDX.Mathematics.Byte2.</param>
            <param name="rhs">Right-hand side GDX.Mathematics.Byte2.</param>
            <returns>Returns the result of a bitwise AND operation on two GDX.Mathematics.Byte2.</returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_BitwiseAnd(GDX.Mathematics.Byte2,System.Byte)">
            <summary>
                Bitwise AND a GDX.Mathematics.Byte2 and a System.Byte.
            </summary>
            <param name="lhs">Left-hand side GDX.Mathematics.Byte2.</param>
            <param name="rhs">Right-hand side System.Byte.</param>
            <returns>
                Returns the result of a bitwise AND operation on a GDX.Mathematics.Byte2 and a System.Byte
                value.
            </returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_BitwiseAnd(System.Byte,GDX.Mathematics.Byte2)">
            <summary>
                Bitwise AND a System.Byte and a GDX.Mathematics.Byte2.
            </summary>
            <param name="lhs">Left-hand side System.Byte.</param>
            <param name="rhs">Right-hand side GDX.Mathematics.Byte2.</param>
            <returns>
                Returns the result of a bitwise AND operation on a System.Byte and a GDX.Mathematics.Byte2
                value.
            </returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_BitwiseOr(GDX.Mathematics.Byte2,GDX.Mathematics.Byte2)">
            <summary>
                Bitwise OR two GDX.Mathematics.Byte2 values.
            </summary>
            <param name="lhs">Left-hand side GDX.Mathematics.Byte2.</param>
            <param name="rhs">Right-hand side GDX.Mathematics.Byte2.</param>
            <returns>Returns the result of a bitwise OR operation on two GDX.Mathematics.Byte2.</returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_BitwiseOr(GDX.Mathematics.Byte2,System.Byte)">
            <summary>
                Bitwise OR a GDX.Mathematics.Byte2 and a System.Byte.
            </summary>
            <param name="lhs">Left-hand side GDX.Mathematics.Byte2.</param>
            <param name="rhs">Right-hand side System.Byte.</param>
            <returns>
                Returns the result of a bitwise OR operation on a GDX.Mathematics.Byte2 and a System.Byte
                value.
            </returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_BitwiseOr(System.Byte,GDX.Mathematics.Byte2)">
            <summary>
                Bitwise OR a System.Byte and a GDX.Mathematics.Byte2.
            </summary>
            <param name="lhs">Left-hand side System.Byte.</param>
            <param name="rhs">Right-hand side GDX.Mathematics.Byte2.</param>
            <returns>
                Returns the result of a bitwise OR operation on a System.Byte and a GDX.Mathematics.Byte2
                value.
            </returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_ExclusiveOr(GDX.Mathematics.Byte2,GDX.Mathematics.Byte2)">
            <summary>
                Bitwise XOR two GDX.Mathematics.Byte2 values.
            </summary>
            <param name="lhs">Left-hand side GDX.Mathematics.Byte2.</param>
            <param name="rhs">Right-hand side GDX.Mathematics.Byte2.</param>
            <returns>Returns the result of a bitwise EXCLUSIVE OR operation on two GDX.Mathematics.Byte2.</returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_ExclusiveOr(GDX.Mathematics.Byte2,System.Byte)">
            <summary>
                Bitwise XOR a GDX.Mathematics.Byte2 and a System.Byte.
            </summary>
            <param name="lhs">Left-hand side GDX.Mathematics.Byte2.</param>
            <param name="rhs">Right-hand side System.Byte.</param>
            <returns>
                Returns the result of a bitwise XOR operation on a GDX.Mathematics.Byte2 and a System.Byte
                value.
            </returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_ExclusiveOr(System.Byte,GDX.Mathematics.Byte2)">
            <summary>
                Bitwise XOR a System.Byte and a GDX.Mathematics.Byte2.
            </summary>
            <param name="lhs">Left-hand side System.Byte.</param>
            <param name="rhs">Right-hand side GDX.Mathematics.Byte2.</param>
            <returns>
                Returns the result of a bitwise XOR operation on a System.Byte and a GDX.Mathematics.Byte2
                value.
            </returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.GetHashCode">
            <summary>
                Get a hash code from the GDX.Mathematics.Byte2.
            </summary>
            <remarks>
                This loosely based on the Fowler–Noll–Vo (FNV) hash function.
            </remarks>
            <returns>A System.Int32 value.</returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.ToString">
            <summary>
                Returns a System.String representation of the GDX.Mathematics.Byte2.
            </summary>
        </member>
        <member name="T:GDX.Mathematics.Byte2.DebuggerProxy">
            <summary>
                Debug object used by IDEs for visibility of a GDX.Mathematics.Byte2.
            </summary>
        </member>
        <member name="F:GDX.Mathematics.Byte2.DebuggerProxy.X">
            <summary>
                X System.Byte.
            </summary>
        </member>
        <member name="F:GDX.Mathematics.Byte2.DebuggerProxy.Y">
            <summary>
                Y System.Byte.
            </summary>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_Explicit(Unity.Mathematics.bool2)~GDX.Mathematics.Byte2">
            <summary>
                Explicitly converts a Unity.Mathematics.bool2 to a GDX.Mathematics.Byte2 by conversion.
            </summary>
            <param name="v">The value to transcribe.</param>
            <returns>A new GDX.Mathematics.Byte2 created from v.</returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_Explicit(Unity.Mathematics.float2)~GDX.Mathematics.Byte2">
            <summary>
                Explicitly converts a Unity.Mathematics.bool2 to a GDX.Mathematics.Byte2 by conversion.
            </summary>
            <param name="v">The value to transcribe.</param>
            <returns>A new GDX.Mathematics.Byte2 created from v.</returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_Explicit(Unity.Mathematics.double2)~GDX.Mathematics.Byte2">
            <summary>
                Explicitly converts a Unity.Mathematics.double2 to a GDX.Mathematics.Byte2 by
                conversion.
            </summary>
            <param name="v">The value to transcribe.</param>
            <returns>A new GDX.Mathematics.Byte2 created from v.</returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_LessThan(GDX.Mathematics.Byte2,GDX.Mathematics.Byte2)">
            <summary>
                Determine if one GDX.Mathematics.Byte2 is less than another GDX.Mathematics.Byte2.
            </summary>
            <param name="lhs">Left-hand side GDX.Mathematics.Byte2.</param>
            <param name="rhs">Right-hand side GDX.Mathematics.Byte2.</param>
            <returns>Returns the result of a LESS THAN operation on two GDX.Mathematics.Byte2.</returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_LessThan(GDX.Mathematics.Byte2,System.Byte)">
            <summary>
                Determine if GDX.Mathematics.Byte2 is less than a System.Byte.
            </summary>
            <param name="lhs">Left-hand side GDX.Mathematics.Byte2.</param>
            <param name="rhs">Right-hand side System.Byte.</param>
            <returns>
                Returns the result of a LESS THAN operation on a GDX.Mathematics.Byte2 and a System.Byte
                value.
            </returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_LessThan(System.Byte,GDX.Mathematics.Byte2)">
            <summary>
                Determine if System.Byte is less than a GDX.Mathematics.Byte2.
            </summary>
            <param name="lhs">Left-hand side System.Byte.</param>
            <param name="rhs">Right-hand side GDX.Mathematics.Byte2.</param>
            <returns>
                Returns the result of a LESS THAN operation on a System.Byte and a GDX.Mathematics.Byte2
                value.
            </returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_LessThanOrEqual(GDX.Mathematics.Byte2,GDX.Mathematics.Byte2)">
            <summary>
                Determine if one GDX.Mathematics.Byte2 is less than or equal to another GDX.Mathematics.Byte2.
            </summary>
            <param name="lhs">Left-hand side GDX.Mathematics.Byte2.</param>
            <param name="rhs">Right-hand side GDX.Mathematics.Byte2.</param>
            <returns>Returns the result of a LESS THAN OR EQUAL operation on two GDX.Mathematics.Byte2.</returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_LessThanOrEqual(GDX.Mathematics.Byte2,System.Byte)">
            <summary>
                Determine if GDX.Mathematics.Byte2 is less than or equal a System.Byte.
            </summary>
            <param name="lhs">Left-hand side GDX.Mathematics.Byte2.</param>
            <param name="rhs">Right-hand side System.Byte.</param>
            <returns>
                Returns the result of a LESS THAN OR EQUAL operation on a GDX.Mathematics.Byte2 and a
                System.Byte
                value.
            </returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_LessThanOrEqual(System.Byte,GDX.Mathematics.Byte2)">
            <summary>
                Determine if System.Byte is less than or equal a GDX.Mathematics.Byte2.
            </summary>
            <param name="lhs">Left-hand side System.Byte.</param>
            <param name="rhs">Right-hand side GDX.Mathematics.Byte2.</param>
            <returns>
                Returns the result of a LESS THAN OR EQUAL operation on a System.Byte and a
                GDX.Mathematics.Byte2
                value.
            </returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_GreaterThan(GDX.Mathematics.Byte2,GDX.Mathematics.Byte2)">
            <summary>
                Determine if one GDX.Mathematics.Byte2 is less than another GDX.Mathematics.Byte2.
            </summary>
            <param name="lhs">Left-hand side GDX.Mathematics.Byte2.</param>
            <param name="rhs">Right-hand side GDX.Mathematics.Byte2.</param>
            <returns>Returns the result of a LESS THAN operation on two GDX.Mathematics.Byte2.</returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_GreaterThan(GDX.Mathematics.Byte2,System.Byte)">
            <summary>
                Determine if GDX.Mathematics.Byte2 is greater than a System.Byte.
            </summary>
            <param name="lhs">Left-hand side GDX.Mathematics.Byte2.</param>
            <param name="rhs">Right-hand side System.Byte.</param>
            <returns>
                Returns the result of a GREATER THAN operation on a GDX.Mathematics.Byte2 and a System.Byte
                value.
            </returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_GreaterThan(System.Byte,GDX.Mathematics.Byte2)">
            <summary>
                Determine if System.Byte is greater than a GDX.Mathematics.Byte2.
            </summary>
            <param name="lhs">Left-hand side System.Byte.</param>
            <param name="rhs">Right-hand side GDX.Mathematics.Byte2.</param>
            <returns>
                Returns the result of a GREATER THAN operation on a System.Byte and a GDX.Mathematics.Byte2
                value.
            </returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_GreaterThanOrEqual(GDX.Mathematics.Byte2,GDX.Mathematics.Byte2)">
            <summary>
                Determine if GDX.Mathematics.Byte2 is greater than or equal a GDX.Mathematics.Byte2.
            </summary>
            <param name="lhs">Left-hand side GDX.Mathematics.Byte2.</param>
            <param name="rhs">Right-hand side GDX.Mathematics.Byte2.</param>
            <returns>
                Returns the result of a GREATER THAN OR EQUAL operation on a GDX.Mathematics.Byte2 and a
                GDX.Mathematics.Byte2
                value.
            </returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_GreaterThanOrEqual(GDX.Mathematics.Byte2,System.Byte)">
            <summary>
                Determine if GDX.Mathematics.Byte2 is greater than or equal a System.Byte.
            </summary>
            <param name="lhs">Left-hand side GDX.Mathematics.Byte2.</param>
            <param name="rhs">Right-hand side System.Byte.</param>
            <returns>
                Returns the result of a GREATER THAN OR EQUAL operation on a GDX.Mathematics.Byte2 and a
                System.Byte
                value.
            </returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_GreaterThanOrEqual(System.Byte,GDX.Mathematics.Byte2)">
            <summary>
                Determine if System.Byte is greater than or equal a GDX.Mathematics.Byte2.
            </summary>
            <param name="lhs">Left-hand side System.Byte.</param>
            <param name="rhs">Right-hand side GDX.Mathematics.Byte2.</param>
            <returns>
                Returns the result of a GREATER THAN OR EQUAL operation on a System.Byte and a
                GDX.Mathematics.Byte2
                value.
            </returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_Equality(GDX.Mathematics.Byte2,GDX.Mathematics.Byte2)">
            <summary>
                Determine if one GDX.Mathematics.Byte2 is equal to another GDX.Mathematics.Byte2.
            </summary>
            <param name="lhs">Left-hand side GDX.Mathematics.Byte2.</param>
            <param name="rhs">Right-hand side GDX.Mathematics.Byte2.</param>
            <returns>Returns the result of an EQUALITY operation on two GDX.Mathematics.Byte2.</returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_Equality(GDX.Mathematics.Byte2,System.Byte)">
            <summary>
                Determine if both components of a GDX.Mathematics.Byte2 are equal to a System.Byte.
            </summary>
            <param name="lhs">Left-hand side GDX.Mathematics.Byte2.</param>
            <param name="rhs">Right-hand side System.Byte.</param>
            <returns>Returns the result of an EQUALITY operation on a GDX.Mathematics.Byte2 and a System.Byte.</returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_Equality(System.Byte,GDX.Mathematics.Byte2)">
            <summary>
                Determine if both components of a GDX.Mathematics.Byte2 are equal to a System.Byte.
            </summary>
            <param name="lhs">Left-hand side System.Byte.</param>
            <param name="rhs">Right-hand side GDX.Mathematics.Byte2.</param>
            <returns>Returns the result of an EQUALITY operation on a System.Byte and a GDX.Mathematics.Byte2.</returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_Inequality(GDX.Mathematics.Byte2,GDX.Mathematics.Byte2)">
            <summary>
                Determine if one GDX.Mathematics.Byte2 is not equal to another GDX.Mathematics.Byte2.
            </summary>
            <param name="lhs">Left-hand side GDX.Mathematics.Byte2.</param>
            <param name="rhs">Right-hand side GDX.Mathematics.Byte2.</param>
            <returns>Returns the result of a NOT EQUAL operation on two GDX.Mathematics.Byte2.</returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_Inequality(GDX.Mathematics.Byte2,System.Byte)">
            <summary>
                Determine if both components of a GDX.Mathematics.Byte2 are not equal to a System.Byte.
            </summary>
            <param name="lhs">Left-hand side GDX.Mathematics.Byte2.</param>
            <param name="rhs">Right-hand side System.Byte.</param>
            <returns>Returns the result of a NOT EQUAL operation on a GDX.Mathematics.Byte2 and a System.Byte.</returns>
        </member>
        <member name="M:GDX.Mathematics.Byte2.op_Inequality(System.Byte,GDX.Mathematics.Byte2)">
            <summary>
                Determine if both components of a GDX.Mathematics.Byte2 are not equal to a System.Byte.
            </summary>
            <param name="lhs">Left-hand side System.Byte.</param>
            <param name="rhs">Right-hand side GDX.Mathematics.Byte2.</param>
            <returns>Returns the result of a NOT EQUAL operation on a System.Byte and a GDX.Mathematics.Byte2.</returns>
        </member>
        <member name="F:GDX.Jobs.ParallelFor.Color32CompareJob.A">
            <summary>
                The left-hand side Unity.Collections.NativeArray`1 typed as System.Byte.
            </summary>
        </member>
        <member name="F:GDX.Jobs.ParallelFor.Color32CompareJob.B">
            <summary>
                The right-hand side Unity.Collections.NativeArray`1 typed as System.Byte.
            </summary>
        </member>
        <member name="F:GDX.Jobs.ParallelFor.Color32CompareJob.Percentage">
            <summary>
                The percent difference between the two values.
            </summary>
        </member>
        <member name="M:GDX.Jobs.ParallelFor.Color32CompareJob.Execute(System.Int32)">
            <summary>
            Executable work for the provided index.
            </summary>
            <param name="index">The index of the Parallel for loop at which to perform work.</param>
        </member>
        <member name="T:GDX.Jobs.ParallelFor.ColorMatchJob">
            <summary>
                Determines if the UnityEngine.Colors in the provided Unity.Collections.NativeArray`1s match each other in
                parallel.
            </summary>
        </member>
        <member name="F:GDX.Jobs.ParallelFor.ColorMatchJob.A">
            <summary>
                The left-hand side Unity.Collections.NativeArray`1 typed as System.Byte.
            </summary>
        </member>
        <member name="F:GDX.Jobs.ParallelFor.ColorMatchJob.B">
            <summary>
                The right-hand side Unity.Collections.NativeArray`1 typed as System.Byte.
            </summary>
        </member>
        <member name="F:GDX.Jobs.ParallelFor.ColorMatchJob.Match">
            <summary>
                Does the color match?
            </summary>
        </member>
        <member name="M:GDX.Jobs.ParallelFor.ColorMatchJob.Execute(System.Int32)">
            <summary>
            Executable work for the provided index.
            </summary>
            <param name="index">The index of the Parallel for loop at which to perform work.</param>
        </member>
        <member name="T:GDX.Jobs.ParallelFor.IntegerBufferCopyJob">
            <summary>
                Copy one Unity.Collections.NativeArray`1 typed as System.Int32 to another in
                parallel.
            </summary>
        </member>
        <member name="F:GDX.Jobs.ParallelFor.IntegerBufferCopyJob.Destination">
            <summary>
                <para>The destination Unity.Collections.NativeArray`1 typed as System.Int32.</para>
            </summary>
            <remarks>Write-only.</remarks>
        </member>
        <member name="F:GDX.Jobs.ParallelFor.IntegerBufferCopyJob.Source">
            <summary>
                <para>The source Unity.Collections.NativeArray`1 typed as System.Int32.</para>
            </summary>
            <remarks>Read-only.</remarks>
        </member>
        <member name="M:GDX.Jobs.ParallelFor.IntegerBufferCopyJob.Execute(System.Int32)">
            <summary>
            Executable work for the provided index.
            </summary>
            <param name="index">The index of the Parallel for loop at which to perform work.</param>
        </member>
        <member name="F:GDX.Jobs.ParallelFor.ColorCompareJob.A">
            <summary>
                The left-hand side Unity.Collections.NativeArray`1 typed as System.Byte.
            </summary>
        </member>
        <member name="F:GDX.Jobs.ParallelFor.ColorCompareJob.B">
            <summary>
                The right-hand side Unity.Collections.NativeArray`1 typed as System.Byte.
            </summary>
        </member>
        <member name="F:GDX.Jobs.ParallelFor.ColorCompareJob.Percentage">
            <summary>
                The percent difference between the two values.
            </summary>
        </member>
        <member name="M:GDX.Jobs.ParallelFor.ColorCompareJob.Execute(System.Int32)">
            <summary>
            Executable work for the provided index.
            </summary>
            <param name="index">The index of the Parallel for loop at which to perform work.</param>
        </member>
        <member name="T:GDX.Jobs.ParallelFor.IntegerBufferSwapJob">
            <summary>
                Swaps a Unity.Collections.NativeArray`1 typed as System.Int32 with a another
                in parallel.
            </summary>
            <remarks>
                <para>
                    The GDX.Jobs.ParallelFor.IntegerBufferSwapJob relies on the Unity.Jobs.IJobParallelFor which
                    requires UnityEngine.CoreModule.dll.
                </para>
            </remarks>
        </member>
        <member name="F:GDX.Jobs.ParallelFor.IntegerBufferSwapJob.A">
            <summary>
                The left-hand side Unity.Collections.NativeArray`1 typed as System.Int32.
            </summary>
        </member>
        <member name="F:GDX.Jobs.ParallelFor.IntegerBufferSwapJob.B">
            <summary>
                The right-hand side Unity.Collections.NativeArray`1 typed as System.Int32.
            </summary>
        </member>
        <member name="M:GDX.Jobs.ParallelFor.IntegerBufferSwapJob.Execute(System.Int32)">
            <summary>
            Executable work for the provided index.
            </summary>
            <param name="index">The index of the Parallel for loop at which to perform work.</param>
        </member>
        <member name="T:GDX.Jobs.ParallelFor.Color32MatchJob">
            <summary>
                Determines if the UnityEngine.Color32s in the provided Unity.Collections.NativeArray`1s match each other in
                parallel.
            </summary>
        </member>
        <member name="F:GDX.Jobs.ParallelFor.Color32MatchJob.A">
            <summary>
                The left-hand side Unity.Collections.NativeArray`1 typed as System.Byte.
            </summary>
        </member>
        <member name="F:GDX.Jobs.ParallelFor.Color32MatchJob.B">
            <summary>
                The right-hand side Unity.Collections.NativeArray`1 typed as System.Byte.
            </summary>
        </member>
        <member name="F:GDX.Jobs.ParallelFor.Color32MatchJob.Match">
            <summary>
                Does the color match?
            </summary>
        </member>
        <member name="M:GDX.Jobs.ParallelFor.Color32MatchJob.Execute(System.Int32)">
            <summary>
            Executable work for the provided index.
            </summary>
            <param name="index">The index of the Parallel for loop at which to perform work.</param>
        </member>
        <member name="T:GDX.Jobs.ParallelFor.IntegerBufferFillJob">
            <summary>
                Fills a Unity.Collections.NativeArray`1 typed as System.Int32 with a value in
                parallel.
            </summary>
        </member>
        <member name="F:GDX.Jobs.ParallelFor.IntegerBufferFillJob.Buffer">
            <summary>
                <para>The Unity.Collections.NativeArray`1 which is going to be filled.</para>
            </summary>
            <remarks>Write-only.</remarks>
        </member>
        <member name="F:GDX.Jobs.ParallelFor.IntegerBufferFillJob.FillValue">
            <summary>
                <para>The System.Int32 value to fill the native array with.</para>
            </summary>
            <remarks>Read-only.</remarks>
        </member>
        <member name="M:GDX.Jobs.ParallelFor.IntegerBufferFillJob.Execute(System.Int32)">
            <summary>
            Executable work for the provided index.
            </summary>
            <param name="index">The index of the Parallel for loop at which to perform work.</param>
        </member>
        <member name="T:GDX.StringExtensions">
            <summary>
                System.String Based Extension Methods
            </summary>
        </member>
        <member name="F:GDX.StringExtensions.AsciiCaseShift">
            <summary>
                The ASCII decimal value shift required to change the case of a letter.
            </summary>
        </member>
        <member name="F:GDX.StringExtensions.AsciiLowerCaseStart">
            <summary>
                The ASCII decimal value for a.
            </summary>
        </member>
        <member name="F:GDX.StringExtensions.AsciiLowerCaseEnd">
            <summary>
                The ASCII decimal value for lowercase z.
            </summary>
        </member>
        <member name="F:GDX.StringExtensions.AsciiNumberSign">
            <summary>
                The ASCII decimal value for the number sign -.
            </summary>
        </member>
        <member name="F:GDX.StringExtensions.AsciiNumberDecimal">
            <summary>
                The ASCII decimal value for the decimal (.).
            </summary>
        </member>
        <member name="F:GDX.StringExtensions.AsciiNumberSeparator">
            <summary>
                The ASCII decimal value for the , separator.
            </summary>
        </member>
        <member name="F:GDX.StringExtensions.AsciiNumberStart">
            <summary>
                The ASCII decimal value for 0.
            </summary>
        </member>
        <member name="F:GDX.StringExtensions.AsciiNumberEnd">
            <summary>
                The ASCII decimal value for 9.
            </summary>
        </member>
        <member name="F:GDX.StringExtensions.AsciiUpperCaseStart">
            <summary>
                The ASCII decimal value for uppercase A.
            </summary>
        </member>
        <member name="F:GDX.StringExtensions.AsciiUpperCaseEnd">
            <summary>
                The ASCII  decimal value for uppercase Z.
            </summary>
        </member>
        <member name="F:GDX.StringExtensions.EncryptionDefaultKey">
            <summary>
                The default encryption key used when none is provided to the encryption related extensions.
            </summary>
            <remarks>
                You can change this at runtime during some sort of initialization pass to being something unique to your project,
                but it is not absolutely necessary. This must be a multiple of 8 bytes.
            </remarks>
        </member>
        <member name="F:GDX.StringExtensions.EncryptionInitializationVector">
            <summary>
                The IV (Initialization Vector) provided to the System.Security.Cryptography.DESCryptoServiceProvider.
            </summary>
            <remarks>
                You can change this at runtime during some sort of initialization pass to being something unique to your project,
                but it is not absolutely necessary. This must be a multiple of 8 bytes.
            </remarks>
        </member>
        <member name="M:GDX.StringExtensions.Concatenate(System.String[],System.String,System.Boolean)">
            <summary>
                Concatenate an array of strings into one unified string.
            </summary>
            <param name="pieces">An array of strings</param>
            <param name="delimiter">An optional string which to use between pieces when combining.</param>
            <param name="trailingDelimiter">Should a trailing delimiter be appended?</param>
            <returns>A concatenated System.String.</returns>
        </member>
        <member name="M:GDX.StringExtensions.Decrypt(System.String,System.Byte[])">
            <summary>
                Decrypt an encrypted System.String created by GDX.StringExtensions.Encrypt(System.String,System.Byte[]).
            </summary>
            <remarks>This will have quite a few allocations.</remarks>
            <param name="encryptedString">The encrypted System.String.</param>
            <param name="encryptionKey">The key used to encrypt the System.String.</param>
            <returns>The decrypted System.String.</returns>
        </member>
        <member name="M:GDX.StringExtensions.Encrypt(System.String,System.Byte[])">
            <summary>
                Encrypt a System.String utilizing a System.Security.Cryptography.DESCryptoServiceProvider.
            </summary>
            <remarks>This will have quite a few allocations.</remarks>
            <param name="decryptedString">The original System.String.</param>
            <param name="encryptionKey">
                The key to be used when encrypting the System.String.  This must be a
                multiple of 8 bytes.
            </param>
            <returns>The encrypted System.String.</returns>
        </member>
        <member name="M:GDX.StringExtensions.GetAfterFirst(System.String,System.String,System.StringComparison)">
            <summary>
                Get the System.String after the first identified splitString in
                targetString.
            </summary>
            <param name="targetString">The target System.String to look in.</param>
            <param name="splitString">The divider which the targetString should be split on.</param>
            <param name="comparison">Specifies the culture, case, and sort rules to be used.</param>
            <returns>
                The content following the splitString, or <c>null</c> if none is found.
            </returns>
        </member>
        <member name="M:GDX.StringExtensions.GetAfterLast(System.String,System.String,System.StringComparison)">
            <summary>
                Get the System.String after the last identified splitString in
                targetString.
            </summary>
            <param name="targetString">The target System.String to look in.</param>
            <param name="splitString">The divider which the targetString should be split on.</param>
            <param name="comparison">Specifies the culture, case, and sort rules to be used.</param>
            <returns>
                The content following the splitString, or <c>null</c> if none is found.
            </returns>
        </member>
        <member name="M:GDX.StringExtensions.GetBeforeFirst(System.String,System.String,System.StringComparison)">
            <summary>
                Get the System.String before the first identified splitString in
                targetString.
            </summary>
            <param name="targetString">The target System.String to look in.</param>
            <param name="splitString">The divider which the targetString should be split on.</param>
            <param name="comparison">Specifies the culture, case, and sort rules to be used.</param>
            <returns>The content before the splitString, or <c>null</c> if none is found.</returns>
        </member>
        <member name="M:GDX.StringExtensions.GetBeforeLast(System.String,System.String,System.StringComparison)">
            <summary>
                Get the System.String before the last identified splitString in
                targetString.
            </summary>
            <param name="targetString">The target System.String to look in.</param>
            <param name="splitString">The divider which the targetString should be split on.</param>
            <param name="comparison">Specifies the culture, case, and sort rules to be used.</param>
            <returns>The content before the splitString, or <c>null</c> if none is found.</returns>
        </member>
        <member name="M:GDX.StringExtensions.GetStableHashCode(System.String)">
            <summary>
                <para>
                    Get the stable hash code value of targetString.
                </para>
            </summary>
            <remarks>
                This loosely based on the Fowler–Noll–Vo (FNV) hash function. It's value will be identical
                to the value produced natively by processing a System.String with
                System.String.GetHashCode, but with no allocations and no virtual calls.
            </remarks>
            <param name="targetString">The target System.String.</param>
            <returns>A System.Int32 value.</returns>
        </member>
        <member name="M:GDX.StringExtensions.GetStableLowerCaseHashCode(System.String)">
            <summary>
                <para>
                    Get the stable hash code value of targetString (converted to an uppercase
                    System.String).
                </para>
            </summary>
            <remarks>
                This loosely based on the Fowler–Noll–Vo (FNV) hash function. It's value will be identical
                to the value produced natively by processing a System.String with
                System.String.ToLower.System.String.GetHashCode, but with no
                allocations.
            </remarks>
            <param name="targetString">The target System.String.</param>
            <returns>A System.Int32 value.</returns>
        </member>
        <member name="M:GDX.StringExtensions.GetStableUpperCaseHashCode(System.String)">
            <summary>
                <para>
                    Get the stable hash code value of targetString (converted to an uppercase
                    System.String).
                </para>
            </summary>
            <remarks>
                This loosely based on the Fowler–Noll–Vo (FNV) hash function. It's value will be identical
                to the value produced natively by processing a System.String with
                System.String.ToUpper.System.String.GetHashCode, but with no
                allocations.
            </remarks>
            <param name="targetString">The target System.String.</param>
            <returns>A System.Int32 value.</returns>
        </member>
        <member name="M:GDX.StringExtensions.HasLowerCase(System.String)">
            <summary>
                Determine if there are any lowercase letters in the provided targetString.
            </summary>
            <param name="targetString">The target System.String.</param>
            <returns>true/false if lowercase letters were found.</returns>
        </member>
        <member name="M:GDX.StringExtensions.HasUpperCase(System.String)">
            <summary>
                Determine if there are any uppercase letters in the provided targetString.
            </summary>
            <param name="targetString">The target System.String.</param>
            <returns>true/false if uppercase letters were found.</returns>
        </member>
        <member name="M:GDX.StringExtensions.IsBooleanValue(System.String)">
            <summary>
                Determine if the targetString represents a boolean value arrangement.
            </summary>
            <param name="targetString">The target System.String.</param>
            <returns>true/false if the targetString can be evaluated as a boolean value.</returns>
        </member>
        <member name="M:GDX.StringExtensions.IsBooleanPositiveValue(System.String)">
            <summary>
                Determine if the targetString represents a positive boolean value arrangement.
            </summary>
            <example>
                Useful method when trying to parse data for branching.
                <code>
                    if(data["set"].IsBooleanPositiveValue())
                    {
                        ShouldBlueBox();
                    }
                </code>
            </example>
            <param name="targetString">The target System.String.</param>
            <returns>true/false if the targetString can be evaluated as a positive boolean value.</returns>
        </member>
        <member name="M:GDX.StringExtensions.IsIntegerValue(System.String)">
            <summary>
                Determine if the targetString is an System.Int32 value.
            </summary>
            <remarks>
                This method is meant for when you do not actually need the value returned, merely an evaluation if
                the provided targetString is an System.Int32. This does not qualify
                System.Single values positively.
            </remarks>
            <param name="targetString">The target System.String.</param>
            <returns>true/false if it contains an System.Int32.</returns>
        </member>
        <member name="M:GDX.StringExtensions.IsNumeric(System.String)">
            <summary>
                Is the targetString a numeric value.
            </summary>
            <remarks>
                <para>
                    The following requirements must be met to be considered a valid number in this method:
                </para>
                <list type="bullet">
                    <item>
                        <description>
                            The first character may be an indicator of its sign, an explicit acceptance of <c>-</c> is made. If
                            prefixed with <c>+</c>, the number will be found invalid.
                        </description>
                    </item>
                    <item>
                        <description>A single decimal point <c>.</c> may be present in the targetString.</description>
                    </item>
                    <item>
                        <description>No alphabet characters are present in the targetString.</description>
                    </item>
                </list>
            </remarks>
            <param name="targetString">The target System.String.</param>
            <returns>true/false if the targetString qualifies as a numeric value.</returns>
        </member>
        <member name="M:GDX.StringExtensions.CountOccurence(System.String,System.Char)">
            <summary>
                Counts the number of times the needle (targetCharacter) appears in the haystack (targetString).
            </summary>
            <remarks>Specifically created to avoid using LINQ and avoid an allocation.</remarks>
            <param name="targetString">The haystack.</param>
            <param name="targetCharacter">The needle.</param>
            <returns>The number of times targetCharacter is found in targetString.</returns>
        </member>
        <member name="M:GDX.StringExtensions.PartialMatch(System.String[],System.String)">
            <summary>
                Does the haystack partially contain the needle?
            </summary>
            <param name="haystack">An array of System.Strings.</param>
            <param name="needle">The System.String that is being looked for.</param>
            <returns>true/false if found.</returns>
        </member>
        <member name="M:GDX.StringExtensions.PartialMatch(GDX.Collections.Generic.SimpleList{System.String},System.String)">
            <summary>
                Does the haystack partially contain the needle?
            </summary>
            <param name="haystack">A GDX.Collections.Generic.SimpleList`1 of System.Strings.</param>
            <param name="needle">The System.String that is being looked for.</param>
            <returns>true/false if found.</returns>
        </member>
        <member name="M:GDX.StringExtensions.SplitCamelCase(System.String,System.String)">
            <summary>
                Create a new string, splitting an existing string up based on camel case formatting.
            </summary>
            <param name="targetString">The target System.String.</param>
            <param name="divider">The System.String to put in between the split System.String.</param>
            <returns>A new System.String.</returns>
        </member>
        <member name="M:GDX.StringExtensions.StripNonAscii(System.String)">
            <summary>
                Remove non ASCII characters from a System.String.
            </summary>
            <param name="targetString">The System.String to be cleaned.</param>
            <returns>A System.String without ASCII characters.</returns>
        </member>
        <member name="T:GDX.ByteExtensions">
            <summary>
                System.Byte Based Extension Methods
            </summary>
        </member>
        <member name="M:GDX.ByteExtensions.GetStableHashCode(System.Byte[])">
            <summary>
                <para>Get the stable hash code of targetBytes, an array of System.Byte.</para>
            </summary>
            <remarks>Does NOT get the object's hashcode.</remarks>
            <param name="targetBytes">The target array of System.Byte.</param>
            <returns>A System.Int32 value.</returns>
        </member>
        <member name="M:GDX.ByteExtensions.IsSame(System.Byte[],System.Byte[])">
            <summary>
                Are the two provided System.Byte arrays the same.
            </summary>
            <param name="sourceBytes">The left hand side System.Byte array to compare.</param>
            <param name="targetBytes">The right hand side System.Byte array to compare.</param>
            <returns>true if they are identical, will also return true if both are null.</returns>
        </member>
        <member name="T:GDX.Array2DExtensions">
            <summary>
                Array2D Based Extension Methods
            </summary>
        </member>
        <member name="M:GDX.Array2DExtensions.Scale(GDX.Collections.Generic.Array2D{System.Single}@,System.Int32)">
            <summary>
                Generate an array scaled by bilinear interpolation.
            </summary>
            <remarks>Works with System.Single values.</remarks>
            <param name="inputArray">The existing GDX.Collections.Generic.Array2D`1 to scale.</param>
            <param name="scaleFactor">The multiple to scale by.</param>
        </member>
        <member name="T:GDX.Config">
            <summary>
                Project-wide configuration configurable for runtime override.
            </summary>
            <remarks>
                Field order matters to the Config Generator.
            </remarks>
        </member>
        <member name="F:GDX.Config.FormatVersion">
            <summary>
                A reference number to what version the config was generated based off of.
            </summary>
        </member>
        <member name="F:GDX.Config.ConfigOutputPath">
            <summary>
                The asset database relative path of the GDX config override file.
            </summary>
        </member>
        <member name="F:GDX.Config.BuildInfo">
            <summary>
                Should the BuildInfo file be written during builds?
            </summary>
        </member>
        <member name="F:GDX.Config.BuildInfoAssemblyDefinition">
            <summary>
                Ensure that there is an assembly definition wrapping the generated content.
            </summary>
        </member>
        <member name="F:GDX.Config.BuildInfoBuildChangelistArgument">
            <summary>
                The argument key for the build's changelist to be passed to the BuildInfoGenerator.
            </summary>
        </member>
        <member name="F:GDX.Config.BuildInfoBuildDescriptionArgument">
            <summary>
                The argument key for the build description to be passed to the BuildInfoGenerator.
            </summary>
        </member>
        <member name="F:GDX.Config.BuildInfoBuildNumberArgument">
            <summary>
                The argument key for the build number to be passed to the BuildInfoGenerator.
            </summary>
        </member>
        <member name="F:GDX.Config.BuildInfoBuildStreamArgument">
            <summary>
                The argument key for the build's stream to be passed to the BuildInfoGenerator.
            </summary>
        </member>
        <member name="F:GDX.Config.BuildInfoBuildTaskArgument">
            <summary>
                The argument key for the build's task to be passed to the BuildInfoGenerator.
            </summary>
        </member>
        <member name="F:GDX.Config.BuildInfoNamespace">
            <summary>
                The namespace where the BuildInfo should be placed.
            </summary>
        </member>
        <member name="F:GDX.Config.BuildInfoOutputPath">
            <summary>
                The path to output the BuildInfo file.
            </summary>
        </member>
        <member name="F:GDX.Config.CommandLineParserArgumentPrefix">
            <summary>
                What should be used to denote arguments in the command line?
            </summary>
        </member>
        <member name="F:GDX.Config.CommandLineParserArgumentSplit">
            <summary>
                What should be used to split arguments from their values in the command line?
            </summary>
        </member>
        <member name="F:GDX.Config.EditorTaskDirectorSystem">
            <summary>
                Should the Editor Task Director tick the Task Director.
            </summary>
        </member>
        <member name="F:GDX.Config.EditorTaskDirectorSystemTickRate">
            <summary>
                How often should the editor task director tick trigger the task director to tick?
            </summary>
        </member>
        <member name="F:GDX.Config.EnvironmentAlwaysIncludeShaders">
            <summary>
                Should GDX make sure that it's shaders are always included in builds.
            </summary>
        </member>
        <member name="F:GDX.Config.EnvironmentScriptingDefineSymbol">
            <summary>
                Should a GDX scripting define symbol be added to all target build groups.
            </summary>
        </member>
        <member name="F:GDX.Config.EnvironmentToolsMenu">
            <summary>
                Should the GDX tools menu be added in the editor?
            </summary>
        </member>
        <member name="F:GDX.Config.LocalizationDefaultCulture">
            <summary>
                The language to set the default thread culture too.
            </summary>
        </member>
        <member name="F:GDX.Config.LocalizationSetDefaultCulture">
            <summary>
                Should the default thread culture be set?
            </summary>
        </member>
        <member name="F:GDX.Config.PlatformAutomationFolder">
            <summary>
                The project relative path where automation should store its artifacts.
            </summary>
        </member>
        <member name="F:GDX.Config.PlatformCacheFolder">
            <summary>
                The project relative path to use as a cache.
            </summary>
        </member>
        <member name="F:GDX.Config.TaskDirectorSystem">
            <summary>
                Should the Task Director System be added to the player loop during playmode.
            </summary>
        </member>
        <member name="F:GDX.Config.TaskDirectorSystemTickRate">
            <summary>
                How often should the task director tick in playmode?
            </summary>
        </member>
        <member name="F:GDX.Config.TraceDebugLevels">
            <summary>
                What is the level of traces which should be processed and logged by GDX in debug builds?
            </summary>
        </member>
        <member name="F:GDX.Config.TraceDebugOutputToUnityConsole">
            <summary>
                Should GDX based traces output to the Unity console in debug builds?
            </summary>
        </member>
        <member name="F:GDX.Config.TraceDevelopmentLevels">
            <summary>
                What is the level of traces which should be processed and logged by GDX in the editor or development builds?
            </summary>
        </member>
        <member name="F:GDX.Config.TraceDevelopmentOutputToUnityConsole">
            <summary>
                Should GDX based traces output to the Unity console in the editor or development builds?
            </summary>
        </member>
        <member name="F:GDX.Config.TraceReleaseLevels">
            <summary>
                What is the level of traces which should be processed and logged by GDX in release builds?
            </summary>
        </member>
        <member name="F:GDX.Config.UpdateProviderCheckForUpdates">
            <summary>
                Should GDX check for updates at editor time?
            </summary>
        </member>
        <member name="T:GDX.PlayerLoopSystemExtensions">
            <summary>
                UnityEngine.LowLevel.PlayerLoopSystem Based Extension Methods
            </summary>
        </member>
        <member name="M:GDX.PlayerLoopSystemExtensions.AddSubSystem(UnityEngine.LowLevel.PlayerLoopSystem@,UnityEngine.LowLevel.PlayerLoopSystem@)">
            <summary>
                Adds a child (sub) system to the provided parentSystem.
            </summary>
            <param name="parentSystem">The parent system which a child (sub) system should be added too.</param>
            <param name="subSystem">The child (sub) system that is to be added to the parent.</param>
        </member>
        <member name="M:GDX.PlayerLoopSystemExtensions.AddSubSystemToFirstSubSystemOfType(UnityEngine.LowLevel.PlayerLoopSystem@,System.Type,System.Type,UnityEngine.LowLevel.PlayerLoopSystem.UpdateFunction)">
            <summary>
                Adds a child (sub) system to the first found instance of a parentSystemType system in
                rootSystem.
            </summary>
            <param name="rootSystem">The root system which the parentSystemType will be searched recursively for.</param>
            <param name="parentSystemType">The system System.Type that will be searched for as the parent.</param>
            <param name="subSystemType">The type assigned when creating the UnityEngine.LowLevel.PlayerLoopSystem to be added.</param>
            <param name="subSystemUpdateFunction">The method to invoke when the system is updated.</param>
            <returns>true/false if the parentSystemType was found, and therefore the add could occur.</returns>
        </member>
        <member name="M:GDX.PlayerLoopSystemExtensions.AddSubSystemToFirstSubSystemOfType(UnityEngine.LowLevel.PlayerLoopSystem@,System.Type,UnityEngine.LowLevel.PlayerLoopSystem@)">
            <summary>
                Adds a child (sub) system to the first found instance of a parentSystemType system in
                rootSystem.
            </summary>
            <param name="rootSystem">The root system which the parentSystemType will be searched recursively for.</param>
            <param name="parentSystemType">The system System.Type that will be searched for as the parent.</param>
            <param name="subSystem">The child (sub) system that is to be added to the parent.</param>
            <returns>true/false if the parentSystemType was found, and therefore the add could occur.</returns>
        </member>
        <member name="M:GDX.PlayerLoopSystemExtensions.GenerateSystemTree(UnityEngine.LowLevel.PlayerLoopSystem@,GDX.Developer.TextGenerator)">
            <summary>
                Populates a GDX.Developer.TextGenerator with a tree-like structure that represents the
                UnityEngine.LowLevel.PlayerLoopSystem found under the rootSystem.
            </summary>
            <param name="rootSystem">The root system which the tree should be crafted based off of.</param>
            <param name="generator">Optionally, provide a generator to be populated.</param>
            <returns>A GDX.Developer.TextGenerator populated with the system output.</returns>
        </member>
        <member name="M:GDX.PlayerLoopSystemExtensions.RemoveSubSystemsOfType(UnityEngine.LowLevel.PlayerLoopSystem@,System.Type)">
            <summary>
                Removes all child (sub) systems of the specified subSystemType from the provided
                parentSystem.
            </summary>
            <remarks>
                This is NOT recursive, and will not effect the child (sub) systems of the child (sub) systems of the
                parentSystem
            </remarks>
            <param name="parentSystem">The parent system which the child (sub) systems should be removed from.</param>
            <param name="subSystemType">The system System.Type that will be removed.</param>
            <returns>true/false, if a remove was done.</returns>
        </member>
        <member name="M:GDX.PlayerLoopSystemExtensions.RemoveSubSystemsOfTypeFromFirstSubSystemOfType(UnityEngine.LowLevel.PlayerLoopSystem@,System.Type,System.Type)">
            <summary>
                Removes all the child (sub) systems of to the first found instance of a parentSystemType system in rootSystem
            </summary>
            <param name="rootSystem">The root system which the parentSystemType will be searched recursively for.</param>
            <param name="parentSystemType">The system System.Type that will be searched for as the parent.</param>
            <param name="subSystemType">The child (sub) system System.Type that will be removed.</param>
            <returns>true/false, if a remove occured.</returns>
        </member>
        <member name="M:GDX.PlayerLoopSystemExtensions.ReplaceFirstSubSystemOfType(UnityEngine.LowLevel.PlayerLoopSystem@,System.Type,UnityEngine.LowLevel.PlayerLoopSystem@)">
            <summary>
                Replaces the first child (sub) system of the given rootSystem of
                subSystemType with the provided updatedSystem.
            </summary>
            <param name="rootSystem">The root system which the subSystemType will be searched recursively for.</param>
            <param name="subSystemType">The child (sub) system System.Type that will be replaced.</param>
            <param name="updatedSystem">The system to replace the found subSystemType with.</param>
            <returns>true/false if the replace occured.</returns>
        </member>
        <member name="M:GDX.PlayerLoopSystemExtensions.ReplaceSubSystemsOfType(UnityEngine.LowLevel.PlayerLoopSystem@,System.Type,UnityEngine.LowLevel.PlayerLoopSystem@)">
            <summary>
                Replaces all child (sub) systems of the specified subSystemType from the provided
                parentSystem.
            </summary>
            <remarks>
                This is NOT recursive, and will not effect the child (sub) systems of the child (sub) systems of the
                parentSystem
            </remarks>
            <param name="parentSystem">The parent system which the child (sub) systems should be replaced.</param>
            <param name="subSystemType">The system System.Type that will be replaced.</param>
            <param name="updatedSystem">The system to replace the found subSystemType with.</param>
            <returns>true/false if any replacement occured.</returns>
        </member>
        <member name="M:GDX.PlayerLoopSystemExtensions.TryGetFirstSubSystemOfType(UnityEngine.LowLevel.PlayerLoopSystem@,System.Type,System.Boolean@)">
            <summary>
                Searches the provided rootSystem child (sub) systems for the first instance of a
                subSystemType system.
            </summary>
            <param name="rootSystem">
                The root system which the subSystemType will be searched recursively for.
            </param>
            <param name="subSystemType">The child (sub) system System.Type that will be searched for recursively.</param>
            <param name="foundSubSystem">Was an appropriate system found?</param>
            <returns>
                The found system, or the root system. Check foundSubSystem to determine if the system
                was actually found. This pattern is used to preserve the reference.
            </returns>
        </member>
        <member name="M:GDX.PlayerLoopSystemExtensions.TryGetFirstSystemWithSubSystemOfType(UnityEngine.LowLevel.PlayerLoopSystem@,System.Type,System.Boolean@,System.Int32@)">
            <summary>
                Searches the provided rootSystem child (sub) systems for the first instance of a
                subSystemType and returns the parent system, with foundSystemIndex
                of the found child (sub) system.
            </summary>
            <param name="rootSystem">
                The root system which the subSystemType will be searched recursively for.
            </param>
            <param name="subSystemType">The child (sub) system System.Type that will be searched for recursively.</param>
            <param name="foundSubSystem">Was an appropriate child (sub) system found?</param>
            <param name="foundSystemIndex">The index of the found sub (child) system.</param>
            <returns>
                The found parent system, or the root system. Check foundSubSystem to determine if the
                child (sub) system was actually found. This pattern is used to preserve the reference.
            </returns>
        </member>
        <member name="T:GDX.Threading.TaskBase">
            <summary>
                The base of a task used by GDX.Threading.TaskDirector.
            </summary>
        </member>
        <member name="T:GDX.Threading.TaskBase.BlockingModeFlags">
            <summary>
                A set of flags indicating what type of blocking this task does when it comes to other tasks,
                or even user experience.
            </summary>
        </member>
        <member name="F:GDX.Threading.TaskBase.k_DefaultName">
            <summary>
                The default user-friendly name given to GDX.Threading.TaskBase.
            </summary>
        </member>
        <member name="F:GDX.Threading.TaskBase.m_Stopwatch">
            <summary>
                A timing mechanism to measure the duration of execution of the GDX.Threading.TaskBase.
            </summary>
        </member>
        <member name="F:GDX.Threading.TaskBase.completed">
            <summary>
                An event that is triggered when the GDX.Threading.TaskBase has finished its execution.
            </summary>
            <remarks>
                It is <b>super important</b> to remember that subscribed actions will invoke off of the main thread.
                Any logic that requires the main thread will not work. Many of Unity's APIs are not safe for this.
            </remarks>
        </member>
        <member name="F:GDX.Threading.TaskBase.completedMainThread">
            <summary>
                An event that is triggered once the GDX.Threading.TaskBase has finished, during the next tick of the
                GDX.Threading.TaskDirector.
            </summary>
            <remarks>
                This is a safe way to do work which requires being executed on the main thread.
            </remarks>
        </member>
        <member name="F:GDX.Threading.TaskBase.m_Bits">
            <summary>
                The GDX.Threading.TaskBase's descriptive bits.
            </summary>
        </member>
        <member name="F:GDX.Threading.TaskBase.m_BlockingBits">
            <summary>
                A quick set of bits used to describe tasks that should be blocked when
                GDX.Threading.TaskBase.m_BlockingModes contains GDX.Threading.TaskBase.BlockingModeFlags.Bits. The opposing
                GDX.Threading.TaskBase will have its GDX.Threading.TaskBase.m_Bits checked for positives that match.
            </summary>
            <remarks>If any of them are the sam</remarks>
        </member>
        <member name="F:GDX.Threading.TaskBase.m_BlockingModes">
            <summary>
                The GDX.Threading.TaskBase's blocking modes for other tasks.
            </summary>
        </member>
        <member name="F:GDX.Threading.TaskBase.m_Exception">
            <summary>
                The exception that occured.
            </summary>
            <remarks>See GDX.Threading.TaskBase.IsFaulted.</remarks>
        </member>
        <member name="F:GDX.Threading.TaskBase.m_IsLogging">
            <summary>
                Should the task report information to the GDX.Threading.TaskDirector log.
            </summary>
        </member>
        <member name="F:GDX.Threading.TaskBase.m_Name">
            <summary>
                The user-friendly name of the task, used by different feedback systems.
            </summary>
            <remarks>It's important to set this in inherited constructors.</remarks>
        </member>
        <member name="F:GDX.Threading.TaskBase.m_IsFaulted">
            <summary>
                Did an exception occur while executing this GDX.Threading.TaskBase?
            </summary>
        </member>
        <member name="F:GDX.Threading.TaskBase.m_IsDone">
            <summary>
                Has the task finished its execution/work.
            </summary>
        </member>
        <member name="F:GDX.Threading.TaskBase.m_IsExecuting">
            <summary>
                A flag indicating if the task is executing, or if it is still waiting.
            </summary>
        </member>
        <member name="M:GDX.Threading.TaskBase.Complete">
            <summary>
                Forcibly completes the task on the given thread where the method is invoked.
            </summary>
            <remarks>
                This will also forcibly tick the GDX.Threading.TaskDirector upon completion to trigger callbacks. You
                should not be using this unless you have an explicit purpose too.
            </remarks>
        </member>
        <member name="M:GDX.Threading.TaskBase.DoWork">
            <summary>
                The core logic to be defined for a task.
            </summary>
        </member>
        <member name="M:GDX.Threading.TaskBase.Enqueue">
            <summary>
                Enqueue the current GDX.Threading.TaskBase with the GDX.Threading.TaskDirector for execution.
            </summary>
        </member>
        <member name="M:GDX.Threading.TaskBase.GetBits">
            <summary>
                Gets the associated GDX.Collections.BitArray16 with this task.
            </summary>
            <returns>The defined flags.</returns>
        </member>
        <member name="M:GDX.Threading.TaskBase.GetBlockedBits">
            <summary>
                Gets the GDX.Collections.BitArray16 to evaluate other tasks against.
            </summary>
            <returns>The defined bits.</returns>
        </member>
        <member name="M:GDX.Threading.TaskBase.GetBlockingModes">
            <summary>
                Returns the GDX.Threading.TaskBase.BlockingModeFlags used to determine other task execution.
            </summary>
            <returns>A set of flags indicating if other tasks should be able to start execution.</returns>
        </member>
        <member name="M:GDX.Threading.TaskBase.GetException">
            <summary>
                Returns the System.Exception that was created when the task faulted.
            </summary>
            <remarks>See GDX.Threading.TaskBase.IsFaulted.</remarks>
            <returns>An System.Exception object.</returns>
        </member>
        <member name="M:GDX.Threading.TaskBase.GetName">
            <summary>
                Gets the user-friendly name of the task.
            </summary>
            <returns>The defined System.String name of the task.</returns>
        </member>
        <member name="M:GDX.Threading.TaskBase.IsBlockingAllTasks">
            <summary>
                Does this GDX.Threading.TaskBase block all other tasks after it from starting execution?
            </summary>
            <remarks>
                This will keep all tasks after it sitting waiting for this task to complete.
            </remarks>
            <returns>true if this task blocks all after it, otherwise false.</returns>
        </member>
        <member name="M:GDX.Threading.TaskBase.IsBlockingBits">
            <summary>
                Does this GDX.Threading.TaskBase block other tasks from executing based on its
                GDX.Threading.TaskBase.m_BlockingBits?
            </summary>
            <returns>true if this tasks blocks based on bits, otherwise false.</returns>
        </member>
        <member name="M:GDX.Threading.TaskBase.IsBlockingSameName">
            <summary>
                Does this GDX.Threading.TaskBase block all other tasks of the same name from starting during
                its execution?
            </summary>
            <returns>true if this tasks blocks same named tasks, otherwise false.</returns>
        </member>
        <member name="M:GDX.Threading.TaskBase.IsBlockingUserInterface">
            <summary>
                Should the execution of this GDX.Threading.TaskBase prevent the user from providing input to the
                user interface?
            </summary>
            <remarks>
                This directly relates to the GDX.Threading.TaskDirector.inputBlocked, altering the count used
                to trigger that particular event.
            </remarks>
            <returns>true if this task should prevent user input, otherwise false.</returns>
        </member>
        <member name="M:GDX.Threading.TaskBase.IsDone">
            <summary>
                Is the GDX.Threading.TaskBase finished executing?
            </summary>
            <returns>
                Returns true if the execution phase of the task has been completed. This will be
                true if an exception has occured.
            </returns>
        </member>
        <member name="M:GDX.Threading.TaskBase.IsExecuting">
            <summary>
                Is the GDX.Threading.TaskBase currently executing on the thread pool?
            </summary>
            <returns>Returns true if the task is executing, otherwise false.</returns>
        </member>
        <member name="M:GDX.Threading.TaskBase.IsFaulted">
            <summary>
                Did an exception occur while executing off thread?
            </summary>
            <returns>Returns true if an exception occured.</returns>
        </member>
        <member name="M:GDX.Threading.TaskBase.Run">
            <summary>
                Execute task logic.
            </summary>
        </member>
        <member name="F:GDX.Threading.TaskDirectorSystem.s_AddedToPlayerLoop">
            <summary>
                Has the task director been added to the player loop for updating at runtime.
            </summary>
        </member>
        <member name="F:GDX.Threading.TaskDirectorSystem.s_TickRate">
            <summary>
                How often should the GDX.Threading.TaskDirector be ticked?
            </summary>
            <remarks>
                This works by accumulation, when time between the last tick and current time exceeds
                GDX.Threading.TaskDirectorSystem.s_TickRate, a tick will be triggered. Default configured in GDX.Config.
            </remarks>
        </member>
        <member name="F:GDX.Threading.TaskDirectorSystem.s_TimeSinceLastTick">
            <summary>
                An accumulation of time since the last tick.
            </summary>
        </member>
        <member name="F:GDX.Threading.TaskDirectorSystem.ticked">
            <summary>
                Triggered after the GDX.Threading.TaskDirectorSystem has ticked, with the delta time.
            </summary>
        </member>
        <member name="M:GDX.Threading.TaskDirectorSystem.GetTickRate">
            <summary>
                Get the current tick rate used by the GDX.Threading.TaskDirectorSystem.
            </summary>
            <returns>
                A double value representing the elapsed time necessary to trigger an update to the
                GDX.Threading.TaskDirectorSystem.
            </returns>
        </member>
        <member name="M:GDX.Threading.TaskDirectorSystem.SetTickRate(System.Single)">
            <summary>
                Update the rate at which the GDX.Threading.TaskDirectorSystem updates the GDX.Threading.TaskDirector.
            </summary>
            <remarks>
                This will not survive domain reload, please see GDX.Config.TaskDirectorSystemTickRate.
            </remarks>
            <param name="tickRate">The new tick rate.</param>
        </member>
        <member name="M:GDX.Threading.TaskDirectorSystem.Initialize">
            <summary>
                Sets up some default state for the GDX.Threading.TaskDirectorSystem.
            </summary>
        </member>
        <member name="M:GDX.Threading.TaskDirectorSystem.PlayerLoopTick">
            <summary>
                The internal update call to the GDX.Threading.TaskDirector.
            </summary>
        </member>
        <member name="T:GDX.Threading.TaskExtensions">
            <summary>
                System.Threading.Tasks.Task Based Extension Methods
            </summary>
        </member>
        <member name="M:GDX.Threading.TaskExtensions.AsIEnumerator(System.Threading.Tasks.Task)">
            <summary>
                Wraps a System.Threading.Tasks.Task for use in a coroutine.
            </summary>
            <remarks>Don't use coroutines.</remarks>
            <param name="task">An established System.Threading.Tasks.Task.</param>
            <returns>An System.Collections.IEnumerator for use with coroutines.</returns>
        </member>
        <member name="T:GDX.Threading.WaitWhile">
            <summary>
                Some useful wait while methods to control program flow.
            </summary>
        </member>
        <member name="M:GDX.Threading.WaitWhile.GetEnumerator(System.Func{System.Boolean})">
            <summary>
                Wait using an System.Collections.IEnumerator while the conditional is true.
            </summary>
            <param name="conditional">A function evaluated to determine if the wait continues.</param>
            <returns>Yields null values.</returns>
        </member>
        <member name="M:GDX.Threading.WaitWhile.GetTask(System.Func{System.Boolean})">
            <summary>
                Wait asynchronously while the conditional is true.
            </summary>
            <param name="conditional">A function evaluated to determine if the wait continues.</param>
        </member>
        <member name="T:GDX.Threading.TaskDirector">
            <summary>
                A simple control mechanism for distributed GDX.Threading.TaskBase work across the
                thread pool. Tasks should be short-lived and can queue up additional work.
            </summary>
        </member>
        <member name="F:GDX.Threading.TaskDirector.exceptionOccured">
            <summary>
                An event invoked when a GDX.Threading.TaskBase throws an exception.
            </summary>
        </member>
        <member name="F:GDX.Threading.TaskDirector.inputBlocked">
            <summary>
                An event invoked during GDX.Threading.TaskDirector.Tick when user input should be blocked.
            </summary>
        </member>
        <member name="F:GDX.Threading.TaskDirector.logAdded">
            <summary>
                An event invoked during GDX.Threading.TaskDirector.Tick with new log content.
            </summary>
        </member>
        <member name="F:GDX.Threading.TaskDirector.k_BlockedBits">
            <summary>
                A running tally of bits that are blocked by the currently executing tasks.
            </summary>
        </member>
        <member name="F:GDX.Threading.TaskDirector.k_BlockedNames">
            <summary>
                A collection of task names which are currently blocked from beginning to executed based
                on the currently executing tasks.
            </summary>
        </member>
        <member name="F:GDX.Threading.TaskDirector.k_Log">
            <summary>
                An accumulating collection of log content which will be passed to GDX.Threading.TaskDirector.logAdded
                subscribed methods during GDX.Threading.TaskDirector.Tick.
            </summary>
        </member>
        <member name="F:GDX.Threading.TaskDirector.k_LogLock">
            <summary>
                A locking mechanism used for log entries ensuring thread safety.
            </summary>
        </member>
        <member name="F:GDX.Threading.TaskDirector.k_StatusChangeLock">
            <summary>
                A locking mechanism used for changes to task lists ensuring thread safety.
            </summary>
        </member>
        <member name="F:GDX.Threading.TaskDirector.k_TasksBusy">
            <summary>
                A list of tasks currently being executed by the thread pool.
            </summary>
        </member>
        <member name="F:GDX.Threading.TaskDirector.k_TasksFinished">
            <summary>
                A working list of tasks that recently finished, used in GDX.Threading.TaskDirector.Tick to ensure
                callbacks occur on the main thread.
            </summary>
        </member>
        <member name="F:GDX.Threading.TaskDirector.k_TasksProcessed">
            <summary>
                A list of tasks that were moved from waiting state to a working/busy state during
                GDX.Threading.TaskDirector.Tick.
            </summary>
        </member>
        <member name="F:GDX.Threading.TaskDirector.k_TasksQueue">
            <summary>
                A list of tasks currently waiting to start work.
            </summary>
        </member>
        <member name="F:GDX.Threading.TaskDirector.s_BlockAllTasksCount">
            <summary>
                The number of tasks that are busy executing which block all other tasks from executing.
            </summary>
            <remarks>
                This number can be higher then one, when tasks are forcibly started and then added to the
                GDX.Threading.TaskDirector.
            </remarks>
        </member>
        <member name="F:GDX.Threading.TaskDirector.s_BlockInput">
            <summary>
                Is user input blocked?
            </summary>
        </member>
        <member name="F:GDX.Threading.TaskDirector.s_BlockInputCount">
            <summary>
                The number of tasks that are busy executing which block user input.
            </summary>
        </member>
        <member name="F:GDX.Threading.TaskDirector.s_TasksBusyCount">
            <summary>
                A cached count of GDX.Threading.TaskDirector.k_TasksBusy.
            </summary>
        </member>
        <member name="F:GDX.Threading.TaskDirector.s_TasksQueueCount">
            <summary>
                A cached count of GDX.Threading.TaskDirector.k_TasksQueue.
            </summary>
        </member>
        <member name="M:GDX.Threading.TaskDirector.GetBusyCount">
            <summary>
                The number of tasks currently in process or awaiting execution by the thread pool.
            </summary>
            <returns>The number of tasks sitting in GDX.Threading.TaskDirector.k_TasksBusy.</returns>
        </member>
        <member name="M:GDX.Threading.TaskDirector.GetQueueCount">
            <summary>
                The number of tasks waiting in the queue.
            </summary>
            <returns>The number of tasks sitting in GDX.Threading.TaskDirector.k_TasksQueue.</returns>
        </member>
        <member name="M:GDX.Threading.TaskDirector.GetStatus">
            <summary>
                Get the status message for the GDX.Threading.TaskDirector.
            </summary>
            <returns>A pre-formatted status message.</returns>
        </member>
        <member name="M:GDX.Threading.TaskDirector.HasTasks">
            <summary>
                Does the GDX.Threading.TaskDirector have any known busy or queued tasks?
            </summary>
            <remarks>
                It's not performant to poll this.
            </remarks>
            <returns>A true/false value indicating tasks.</returns>
        </member>
        <member name="M:GDX.Threading.TaskDirector.IsBlockingBit(System.Int32)">
            <summary>
                Is the GDX.Threading.TaskDirector blocking tasks with a specific bit?
            </summary>
            <remarks>
                It isn't ideal to constantly poll this method, ideally this could be used to block things outside of
                the GDX.Threading.TaskDirector's control based on tasks running.
            </remarks>
            <returns>A true/false value indicating if a GDX.Collections.BitArray16 index is being blocked.</returns>
        </member>
        <member name="M:GDX.Threading.TaskDirector.Log(System.String)">
            <summary>
                Adds a thread-safe log entry to a queue which will be dispatched to GDX.Threading.TaskDirector.logAdded on
                the GDX.Threading.TaskDirector.Tick invoking thread.
            </summary>
            <param name="message">The log content.</param>
        </member>
        <member name="M:GDX.Threading.TaskDirector.QueueTask(GDX.Threading.TaskBase)">
            <summary>
                Add a task to the queue, to be later started when possible.
            </summary>
            <remarks>
                If the task is already executing it will be added to the known busy list.
            </remarks>
            <param name="task">An established task.</param>
        </member>
        <member name="M:GDX.Threading.TaskDirector.Tick">
            <summary>
                Update the GDX.Threading.TaskDirector, evaluating known tasks for work eligibility and execution.
            </summary>
            <remarks>
                This should occur on the main thread. If the GDX.Threading.TaskDirector is used during play mode,
                something needs to call this every global tick. While in edit mode the EditorTaskDirector triggers this
                method.
            </remarks>
        </member>
        <member name="M:GDX.Threading.TaskDirector.UpdateTask(GDX.Threading.TaskBase)">
            <summary>
                Evaluate the provided task and update its state inside of the GDX.Threading.TaskDirector.
            </summary>
            <remarks>
                This will add a task to the GDX.Threading.TaskDirector if it does not already know about it, regardless
                of the current blocking mode status. Do not use this method to add non executing tasks, they will not
                be added to the GDX.Threading.TaskDirector in this way.
            </remarks>
            <param name="task">An established task.</param>
        </member>
        <member name="M:GDX.Threading.TaskDirector.Wait">
            <summary>
                Wait on the completion of all known tasks, blocking the invoking thread.
            </summary>
            <remarks>
                Useful to force the main thread to wait for completion of tasks.
            </remarks>
        </member>
        <member name="M:GDX.Threading.TaskDirector.WaitAsync">
            <summary>
                Asynchronously wait on the completion of all known tasks.
            </summary>
        </member>
        <member name="M:GDX.Threading.TaskDirector.AddBusyTask(GDX.Threading.TaskBase)">
            <summary>
                Add a GDX.Threading.TaskBase to the known list of working tasks.
            </summary>
            <remarks>
                This will add the blocking mode settings to the current settings.
            </remarks>
            <param name="task">An established task.</param>
        </member>
        <member name="M:GDX.Threading.TaskDirector.IsBlockedByBits(GDX.Collections.BitArray16@)">
            <summary>
                Is the provided bit array blocked by the current blocking settings.
            </summary>
            <param name="bits">A GDX.Threading.TaskBase's bits.</param>
            <returns>true/false if the task should be blocked from executing.</returns>
        </member>
        <member name="M:GDX.Threading.TaskDirector.RemoveBusyTask(GDX.Threading.TaskBase)">
            <summary>
                Remove a GDX.Threading.TaskBase from the known list of working tasks.
            </summary>
            <remarks>
                This will remove the blocking mode settings to the current settings.
            </remarks>
            <param name="task">An established task.</param>
        </member>
        <member name="T:GDX.Threading.WaitFor">
            <summary>
                Some useful wait for methods to control program flow.
            </summary>
        </member>
        <member name="F:GDX.Threading.WaitFor.OneSecond">
            <summary>
                One second worth of milliseconds.
            </summary>
        </member>
        <member name="F:GDX.Threading.WaitFor.TwoSeconds">
            <summary>
                Two seconds worth of milliseconds.
            </summary>
        </member>
        <member name="F:GDX.Threading.WaitFor.FiveSeconds">
            <summary>
                Five seconds worth of milliseconds.
            </summary>
        </member>
        <member name="F:GDX.Threading.WaitFor.TenSeconds">
            <summary>
                Ten seconds worth of milliseconds.
            </summary>
        </member>
        <member name="F:GDX.Threading.WaitFor.ThirtySeconds">
            <summary>
                Thirty seconds worth of milliseconds.
            </summary>
        </member>
        <member name="F:GDX.Threading.WaitFor.OneMinute">
            <summary>
                One minute worth of milliseconds.
            </summary>
        </member>
        <member name="F:GDX.Threading.WaitFor.TenMinutes">
            <summary>
                Ten minutes worth of milliseconds.
            </summary>
        </member>
        <member name="M:GDX.Threading.WaitFor.GetEnumerator(System.Int32)">
            <summary>
                Wait using an System.Collections.IEnumerator.
            </summary>
            <param name="milliseconds">The number of milliseconds to wait for.</param>
            <returns>Yields null values.</returns>
        </member>
        <member name="M:GDX.Threading.WaitFor.GetTask(System.Int32)">
            <summary>
                Wait asynchronously.
            </summary>
            <param name="milliseconds">The number of milliseconds to wait for.</param>
        </member>
        <member name="T:GDX.InspectorMessageBoxAttribute">
            <summary>
                Create a message box of information above the property in the inspector.
            </summary>
        </member>
        <member name="T:GDX.InspectorMessageBoxAttribute.MessageBoxType">
            <summary>
                Valid types of messages.
            </summary>
        </member>
        <member name="T:GDX.IO.CoalesceStream">
            <summary>
                A byte backed stream which combines multiple arrays acting as one uniform stream.
            </summary>
            <remarks>
                Max size being limited to GDX.IO.CoalesceStream.m_Length type limitations.
            </remarks>
        </member>
        <member name="F:GDX.IO.CoalesceStream.k_DefaultBucketSize">
            <summary>
                The default size of each allocated bucket array.
            </summary>
        </member>
        <member name="F:GDX.IO.CoalesceStream.m_Buckets">
            <summary>
                The internal arrays storage of buckets.
            </summary>
        </member>
        <member name="F:GDX.IO.CoalesceStream.m_BucketSize">
            <summary>
                The bucket size used to allocate new arrays.
            </summary>
        </member>
        <member name="F:GDX.IO.CoalesceStream.m_Length">
            <summary>
                The perceived length of the data contained within.
            </summary>
        </member>
        <member name="M:GDX.IO.CoalesceStream.#ctor(System.Int32)">
            <summary>
                Create a GDX.IO.CoalesceStream.
            </summary>
            <param name="bucketSize">The bucket allocation size.</param>
        </member>
        <member name="M:GDX.IO.CoalesceStream.#ctor(System.Byte[],System.Int32)">
            <summary>
                Create a GDX.IO.CoalesceStream and fill it with the data found in source.
            </summary>
            <param name="source">An array used to prefill the GDX.IO.CoalesceStream with.</param>
            <param name="bucketSize">The bucket allocation size.</param>
        </member>
        <member name="M:GDX.IO.CoalesceStream.#ctor(System.Int32,System.Int32)">
            <summary>
                Preallocate a GDX.IO.CoalesceStream at the desired length.
            </summary>
            <param name="length">The desired pre-allocated size.</param>
            <param name="bucketSize">The bucket allocation size.</param>
        </member>
        <member name="M:GDX.IO.CoalesceStream.#ctor(System.Int64,System.Int32)">
            <summary>
                Preallocate a GDX.IO.CoalesceStream at the desired length.
            </summary>
            <param name="length">The desired pre-allocated size.</param>
            <param name="bucketSize">The bucket allocation size.</param>
        </member>
        <member name="P:GDX.IO.CoalesceStream.CanRead">
            <summary>
                Is this System.IO.Stream capable of reading?
            </summary>
        </member>
        <member name="P:GDX.IO.CoalesceStream.CanSeek">
            <summary>
                Is this System.IO.Stream capable of seeking?
            </summary>
        </member>
        <member name="P:GDX.IO.CoalesceStream.CanWrite">
            <summary>
                Is this System.IO.Stream capable of writing?
            </summary>
        </member>
        <member name="P:GDX.IO.CoalesceStream.Length">
            <summary>
                Get the combined length of the internal arrays.
            </summary>
        </member>
        <member name="P:GDX.IO.CoalesceStream.Position">
            <summary>
                Get the current position in the System.IO.Stream.
            </summary>
        </member>
        <member name="P:GDX.IO.CoalesceStream.Bucket">
            <summary>
                Get the current bucket.
            </summary>
        </member>
        <member name="P:GDX.IO.CoalesceStream.BucketIndex">
            <summary>
                Determine the current bucket index based on the position and bucket size.
            </summary>
        </member>
        <member name="P:GDX.IO.CoalesceStream.BucketOffset">
            <summary>
                Determine the current bucket offset based on the position and bucket size.
            </summary>
        </member>
        <member name="M:GDX.IO.CoalesceStream.Flush">
            <summary>
                Flush reading and writing buffers.
            </summary>
            <remarks>
                Does nothing for the GDX.IO.CoalesceStream.
            </remarks>
        </member>
        <member name="M:GDX.IO.CoalesceStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
                Read from the GDX.IO.CoalesceStream into a buffer.
            </summary>
            <param name="buffer">The target buffer to write the read data into.</param>
            <param name="offset">The offset position to start writing into the buffer.</param>
            <param name="count">The number of System.Bytes to read.</param>
            <returns>The number of bytes read.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
                Thrown when a negative amounts of bytes are requested, or a negative offset is provided.
            </exception>
            <exception cref="T:System.ArgumentNullException">
                Thrown when the provided buffer is null.
            </exception>
        </member>
        <member name="M:GDX.IO.CoalesceStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Seek the internal position to a new location.
            </summary>
            <param name="offset">The value to offset the internal position by.</param>
            <param name="origin">The origin of the offset.</param>
            <returns></returns>
        </member>
        <member name="M:GDX.IO.CoalesceStream.SetLength(System.Int64)">
            <summary>
                Arbitrarily set the internal length of the GDX.IO.CoalesceStream
            </summary>
            <param name="value">The new length value.</param>
        </member>
        <member name="M:GDX.IO.CoalesceStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
                Write into the GDX.IO.CoalesceStream at the current position.
            </summary>
            <param name="buffer">The source array to read data from</param>
            <param name="offset">An offset of where to start in the buffer.</param>
            <param name="count">The number of bytes to read from the buffer.</param>
        </member>
        <member name="M:GDX.IO.CoalesceStream.ReadByte">
            <summary>
                Read a singular System.Byte from the current position, incrementing the position.
            </summary>
            <returns>A valid byte as an int, or -1.</returns>
        </member>
        <member name="M:GDX.IO.CoalesceStream.WriteByte(System.Byte)">
            <summary>
                Write a singular System.Byte to the GDX.IO.CoalesceStream, incrementing the position.
            </summary>
            <param name="value">The System.Byte to write to the GDX.IO.CoalesceStream.</param>
        </member>
        <member name="T:GDX.IO.Compression.TarFile">
            <summary>
            Provides static methods for extracting tar files and tarballs.
            </summary>
        </member>
        <member name="M:GDX.IO.Compression.TarFile.ExtractToDirectory(System.String,System.String,System.Boolean)">
            <summary>
                Extracts all the files in the specified tar/tarball to a directory on the file system.
            </summary>
            <example>
                A synchronous approach to extracting the contents of a file, to a folder:
                <code>TarFile.ExtractToDirectory("C:\Temp\DownloadCache.tar.gz", "C:\Saved");</code>
            </example>
            <param name="sourceArchiveFileName">The path to the archive that is to be extracted.</param>
            <param name="destinationDirectoryName">
                The path to the directory in which to place the extracted files, specified as a
                relative or absolute path. A relative path is interpreted as relative to the current working directory.
            </param>
            <param name="forceGZipDataFormat">Enforce inflating the file via a System.IO.Compression.GZipStream.</param>
        </member>
        <member name="M:GDX.IO.Compression.TarFile.ExtractStream(System.IO.Stream,System.String)">
            <summary>
                Extract a tar formatted System.IO.Stream to the destinationDirectoryName.
            </summary>
            <param name="sourceStream">The System.IO.Stream which to extract from.</param>
            <param name="destinationDirectoryName">Output directory to write the files.</param>
        </member>
        <member name="T:GDX.HideFromDocFXAttribute">
            <summary>
                Hide the attributed item from DocFX documentation generation.
            </summary>
            <example>
                <para>
                    For this to work a custom entry in a projects <c>filterConfig.yml</c> is necessary to define the exclusion.
                </para>
                <code>
                - exclude:
                    hasAttribute:
                    uid: GDX.HideFromDocFXAttribute
                </code>
            </example>
        </member>
        <member name="T:GDX.VisualScriptingCompatibleAttribute">
            <summary>
                Indicate that the tagged class should be considered for use with Visual Scripting.
            </summary>
        </member>
        <member name="T:GDX.VisualScriptingCompatibleAttribute.VisualScriptingCategory">
            <summary>
                Predetermined categories used when sorting functionality.
            </summary>
        </member>
        <member name="F:GDX.VisualScriptingCompatibleAttribute.VisualScriptingCategories">
            <summary>
                A specific objects categories.
            </summary>
        </member>
        <member name="M:GDX.VisualScriptingCompatibleAttribute.#ctor(GDX.VisualScriptingCompatibleAttribute.VisualScriptingCategory)">
            <summary>
                Indicate that the target should be part of visualScriptingCategories.
            </summary>
            <param name="visualScriptingCategories">The category flags.</param>
        </member>
        <member name="M:GDX.VisualScriptingCompatibleAttribute.#ctor(System.Int16)">
            <summary>
                Indicate that the target should be part of a specific GDX.VisualScriptingCompatibleAttribute.VisualScriptingCategory.
            </summary>
            <param name="visualScriptingCategory">The value of the intended category.</param>
        </member>
        <member name="M:GDX.VisualScriptingCompatibleAttribute.#ctor">
            <summary>
                Indicate that the target should be part of Visual Scripting, but not defining a category.
            </summary>
        </member>
        <member name="T:GDX.DisableInInspectorAttribute">
            <summary>
                Make the field in the inspector disabled by toggling the GUI.enabled before and after.
            </summary>
        </member>
        <member name="T:GDX.MeshExtensions">
            <summary>
                UnityEngine.Mesh Based Extension Methods
            </summary>
            <exception cref="T:GDX.UnsupportedRuntimeException">Not supported on DOTS Runtime.</exception>
        </member>
        <member name="M:GDX.MeshExtensions.CalculateVolume(UnityEngine.Mesh)">
            <summary>
                Determine the volume of a given mesh.
            </summary>
            <remarks>
                Based off of https://n-e-r-v-o-u-s.com/blog/?p=4415.
            </remarks>
            <param name="targetMesh">The mesh to evaluate for its volume.</param>
            <returns>The meshes volume.</returns>
        </member>
        <member name="T:GDX.RigidbodyExtensions">
            <summary>
                UnityEngine.Rigidbody Based Extension Methods
            </summary>
            <exception cref="T:GDX.UnsupportedRuntimeException">Not supported on DOTS Runtime.</exception>
        </member>
        <member name="M:GDX.RigidbodyExtensions.MomentOfInertia(UnityEngine.Rigidbody,UnityEngine.Vector3)">
            <summary>
                Get a UnityEngine.Rigidbody's moment of inertia for a targetAxis.
            </summary>
            <remarks>
                Provided targetAxis must not be P:UnityEngine.Vector3.zero.
            </remarks>
            <param name="targetRigidbody">The UnityEngine.Rigidbody to evaluate.</param>
            <param name="targetAxis">The axis use to calculate the moment of inertia.</param>
            <returns>The moment of inertia for the targetAxis.</returns>
        </member>
        <member name="T:GDX.Vector2Extensions">
            <summary>
                UnityEngine.Vector2 Based Extension Methods
            </summary>
            <exception cref="T:GDX.UnsupportedRuntimeException">Not supported on DOTS Runtime.</exception>
        </member>
        <member name="M:GDX.Vector2Extensions.Approximately(UnityEngine.Vector2,UnityEngine.Vector2)">
            <summary>
                Is one UnityEngine.Vector2 approximately similar to another UnityEngine.Vector2?
            </summary>
            <remarks>Includes optimized Unity.Mathematics approach.</remarks>
            <param name="targetVector2">Point A</param>
            <param name="otherVector2">Point B</param>
            <returns>Are the two UnityEngine.Vector2 approximately the same?</returns>
        </member>
        <member name="M:GDX.Vector2Extensions.Slope(UnityEngine.Vector2)">
            <summary>
            Get the slope of a UnityEngine.Vector2.
            </summary>
            <param name="targetVector2">The UnityEngine.Vector2 to evaluate.</param>
            <returns>The slope value.</returns>
        </member>
        <member name="M:GDX.Vector2Extensions.Midpoint(UnityEngine.Vector2,UnityEngine.Vector2)">
            <summary>
                Get the midpoint between two UnityEngine.Vector2s.
            </summary>
            <param name="targetVector2">Point A</param>
            <param name="otherVector2">Point B</param>
            <returns>The midpoint between targetVector2 and otherVector2.</returns>
        </member>
        <member name="M:GDX.Vector2Extensions.NearestIndex(UnityEngine.Vector2,UnityEngine.Vector2[])">
            <summary>
                Find the index of the UnityEngine.Vector2 in otherVector2 that is nearest to the
                targetVector2.
            </summary>
            <param name="targetVector2">The UnityEngine.Vector2 to use as the point of reference.</param>
            <param name="otherVector2">An array of UnityEngine.Vector2 positions to evaluate for which one is nearest.</param>
            <returns>
                The index of the nearest otherVector2 element to targetVector2.
                Returning -1 if the the otherVector2 has no elements or is null.
            </returns>
        </member>
        <member name="M:GDX.Vector2Extensions.TryParseVector2(System.String,UnityEngine.Vector2@)">
            <summary>
                Attempt to parse a System.String into a UnityEngine.Vector2.
            </summary>
            <remarks>This isn't great for runtime performance, it should be used predominantly when reconstructing data.</remarks>
            <param name="targetString">The System.String to convert into a UnityEngine.Vector2 if possible.</param>
            <param name="outputVector2">The outputted UnityEngine.Vector2.</param>
            <returns>true/false if the conversion was successful.</returns>
        </member>
        <member name="T:GDX.Reflection">
            <summary>
                A collection of reflection related helper utilities.
            </summary>
            <remarks>Torn about the existence of this utility class, yet alone the conditions dictating it.</remarks>
        </member>
        <member name="F:GDX.Reflection.PrivateFieldFlags">
            <summary>
                System.Reflection.BindingFlags for a private field.
            </summary>
        </member>
        <member name="F:GDX.Reflection.PrivateStaticFlags">
            <summary>
                System.Reflection.BindingFlags for a private static.
            </summary>
        </member>
        <member name="F:GDX.Reflection.PublicStaticFlags">
            <summary>
                System.Reflection.BindingFlags for a public static.
            </summary>
        </member>
        <member name="M:GDX.Reflection.GetDefault(System.Type)">
            <summary>
                Returns the default value for a given type.
            </summary>
            <param name="type">A qualified type.</param>
            <returns>The default value.</returns>
        </member>
        <member name="M:GDX.Reflection.GetType(System.String)">
            <summary>
                Returns a qualified type..
            </summary>
            <param name="type">The full name of a type.</param>
            <returns>A System.Type if found.</returns>
        </member>
        <member name="M:GDX.Reflection.InvokeStaticMethod(System.String,System.String,System.Object[],System.Reflection.BindingFlags)">
            <summary>
                Invokes a known static method.
            </summary>
            <param name="type">The explicit type of the static class.</param>
            <param name="method">The name of the method to invoke.</param>
            <param name="parameters">Any parameters that should be passed to the method?</param>
            <param name="flags">The method's access flags.</param>
            <returns>An System.Object of the return value. This can be null.</returns>
        </member>
        <member name="M:GDX.Reflection.SetFieldOrPropertyValue(System.Object,System.String,System.Object,System.Reflection.BindingFlags,System.Reflection.BindingFlags)">
            <summary>
                Set the field or property value of a specific targetObject, which may not be
                normally accessible.
            </summary>
            <param name="targetObject">The instanced object which will have it's field or property value set.</param>
            <param name="name">The field or property's name to set.</param>
            <param name="value">The value to set the field or property to.</param>
            <param name="fieldFlags">The field's access flags.</param>
            <param name="propertyFlags">The property's access flags.</param>
            <returns>true/false if the value was set.</returns>
        </member>
        <member name="M:GDX.Reflection.SetFieldValue(System.Object,System.Type,System.String,System.Object,System.Reflection.BindingFlags)">
            <summary>
                Set the field value of a specific targetObject, which may not be normally accessible.
            </summary>
            <param name="targetObject">The instanced object which will have it's field value set; use a null value if this is a static field.</param>
            <param name="type">The explicit type of the targetObject.</param>
            <param name="name">The field's name to set.</param>
            <param name="value">The value to set the field to.</param>
            <param name="flags">The field's access flags.</param>
            <returns>true/false if the value was set.</returns>
        </member>
        <member name="M:GDX.Reflection.SetPropertyValue(System.Object,System.Type,System.String,System.Object,System.Reflection.BindingFlags)">
            <summary>
                Set the property value of a specific targetObject, which may not be normally accessible.
            </summary>
            <param name="targetObject">The instanced object which will have it's property value set; use a null value if this is a static property.</param>
            <param name="type">The type of the targetObject.</param>
            <param name="name">The property's name to set.</param>
            <param name="value">The value to set the property to.</param>
            <param name="flags">The property's access flags.</param>
            <returns>true/false if the value was set.</returns>
        </member>
        <member name="M:GDX.Reflection.TryGetFieldValue``1(System.Object,System.Type,System.String,``0@,System.Reflection.BindingFlags)">
            <summary>
                Try to access the field value of a specific targetObject, which may not be normally accessible.
            </summary>
            <remarks></remarks>
            <param name="targetObject">The instanced object which will have it's field value read; use a null value if this is a static field.</param>
            <param name="type">The qualified type of the targetObject.</param>
            <param name="name">The field's name to read.</param>
            <param name="returnValue">The returned value from the field, the default value if the field was unable to be read.</param>
            <param name="flags">The field's access flags.</param>
            <typeparam name="T">The type of data being read from the field.</typeparam>
            <returns>true/false if the process was successful.</returns>
        </member>
        <member name="M:GDX.Reflection.TryGetFieldOrPropertyValue(System.Object,System.String,System.Object@,System.Reflection.BindingFlags,System.Reflection.BindingFlags)">
            <summary>
                Try to access the field or property value of a specific targetObject, which may not
                be normally accessible.
            </summary>
            <remarks>Useful for when you really do not know the System.Type.</remarks>
            <param name="targetObject">The instanced object which will have it's field or property value read.</param>
            <param name="name">The field or property's name to read.</param>
            <param name="returnValue">The returned value from the field or property, the default value if the property was unable to be read.</param>
            <param name="fieldFlags">The field's access flags.</param>
            <param name="propertyFlags">The property's access flags.</param>
            <returns>true/false if a value was found.</returns>
        </member>
        <member name="M:GDX.Reflection.TryGetPropertyValue``1(System.Object,System.Type,System.String,``0@,System.Reflection.BindingFlags)">
            <summary>
                Try to get a property value from targetObject, which may not be normally accessible.
            </summary>
            <param name="targetObject">The instanced object which will have it's property value read; use a null value if this is a static property.</param>
            <param name="type">The explicit type of the targetObject.</param>
            <param name="name">The property's name to read.</param>
            <param name="returnValue">The returned value from the property, the default value if the property was unable to be read.</param>
            <param name="flags">The property's access flags.</param>
            <typeparam name="T">The type of data being read from the property.</typeparam>
            <returns>true/false if the process was successful.</returns>
        </member>
        <member name="T:GDX.ArrayExtensions">
            <summary>
                Array Based Extension Methods
            </summary>
        </member>
        <member name="M:GDX.ArrayExtensions.Clear``1(``0[])">
            <summary>
                Set all elements in an array to the default values.
            </summary>
            <remarks>
                This does not alter the targetArray's length.
            </remarks>
            <param name="targetArray">The array to be defaulted.</param>
            <typeparam name="T">The type of the array.</typeparam>
        </member>
        <member name="M:GDX.ArrayExtensions.ContainsItem``1(``0[],``0)">
            <summary>
                <para>Does targetArray contain targetValue?</para>
            </summary>
            <param name="targetArray">The System.Array to look in.</param>
            <param name="targetValue">The target item to look for.</param>
            <typeparam name="T">The type of the System.Array.</typeparam>
            <returns>true/false</returns>
        </member>
        <member name="M:GDX.ArrayExtensions.ContainsReference``1(``0[],``0)">
            <summary>
                <para>Does targetArray contain targetItem?</para>
            </summary>
            <remarks>Ignores equality check and end up comparing object pointers.</remarks>
            <param name="targetArray">The System.Array to look in.</param>
            <param name="targetItem">The target item to look for.</param>
            <typeparam name="T">The type of the System.Array.</typeparam>
            <returns>true/false</returns>
        </member>
        <member name="M:GDX.ArrayExtensions.ContainsValue``1(``0[],``0)">
            <summary>
                <para>Does targetArray contain targetValue?</para>
            </summary>
            <param name="targetArray">The System.Array to look in.</param>
            <param name="targetValue">The target value to look for.</param>
            <typeparam name="T">The type of the System.Array.</typeparam>
            <returns>true/false</returns>
        </member>
        <member name="M:GDX.ArrayExtensions.FirstIndexOf``1(``0[],``0)">
            <summary>
                Find the first index of targetItem in targetArray.
            </summary>
            <remarks>This will work for System.String comparisons.</remarks>
            <param name="targetArray">The array which to look in.</param>
            <param name="targetItem">The object to be found.</param>
            <typeparam name="T">The type of the array.</typeparam>
            <returns>The index of targetItem in targetArray, or -1 if not found.</returns>
        </member>
        <member name="M:GDX.ArrayExtensions.FirstIndexOfItem``1(``0[],``0)">
            <summary>
                Find the first index of targetItem in targetArray.
            </summary>
            <remarks>Ignores equality check and end up comparing object pointers. Do NOT use this for System.String types.</remarks>
            <param name="targetArray">The array which to look in.</param>
            <param name="targetItem">The object to be found.</param>
            <typeparam name="T">The type of the array.</typeparam>
            <returns>The index of targetItem in targetArray, or -1 if not found.</returns>
        </member>
        <member name="M:GDX.ArrayExtensions.FirstIndexOfValue``1(``0[],``0)">
            <summary>
                Find the first index of targetValue in targetArray.
            </summary>
            <param name="targetArray">The array which to look in.</param>
            <param name="targetValue">The value to be found.</param>
            <typeparam name="T">The type of the array.</typeparam>
            <returns>The index of targetValue in targetArray, or -1 if not found.</returns>
        </member>
        <member name="M:GDX.ArrayExtensions.LastIndexOf``1(``0[],``0)">
            <summary>
                Find the last index of targetItem in targetArray.
            </summary>
            <remarks>This will work for System.String comparisons.</remarks>
            <param name="targetArray">The array which to look in.</param>
            <param name="targetItem">The object to be found.</param>
            <typeparam name="T">The type of the array.</typeparam>
            <returns>The index of targetItem in targetArray, or -1 if not found.</returns>
        </member>
        <member name="M:GDX.ArrayExtensions.LastIndexOfItem``1(``0[],``0)">
            <summary>
                Find the last index of targetItem in targetArray.
            </summary>
            <param name="targetArray">The array which to look in.</param>
            <param name="targetItem">The object to be found.</param>
            <typeparam name="T">The type of the array.</typeparam>
            <returns>The index of targetItem in targetArray, or -1 if not found.</returns>
        </member>
        <member name="M:GDX.ArrayExtensions.LastIndexOfValue``1(``0[],``0)">
            <summary>
                Find the last index of targetValue in targetArray.
            </summary>
            <param name="targetArray">The array which to look in.</param>
            <param name="targetValue">The value to be found.</param>
            <typeparam name="T">The type of the array.</typeparam>
            <returns>The index of targetValue in targetArray, or -1 if not found.</returns>
        </member>
        <member name="T:GDX.Vector3Extensions">
            <summary>
                UnityEngine.Vector3 Based Extension Methods
            </summary>
            <exception cref="T:GDX.UnsupportedRuntimeException">Not supported on DOTS Runtime.</exception>
        </member>
        <member name="M:GDX.Vector3Extensions.Approximately(UnityEngine.Vector3,UnityEngine.Vector3)">
            <summary>
                Is one UnityEngine.Vector3 approximately similar to another UnityEngine.Vector3?
            </summary>
            <remarks>Includes optimized Unity.Mathematics approach.</remarks>
            <param name="targetVector3">Point A</param>
            <param name="otherVector3">Point B</param>
            <returns>Are the two UnityEngine.Vector3 approximately the same?</returns>
        </member>
        <member name="M:GDX.Vector3Extensions.DistanceSqr(UnityEngine.Vector3,UnityEngine.Vector3)">
            <summary>
                Calculate the squared distance between two UnityEngine.Vector3.
            </summary>
            <remarks>
                <para>Based on https://en.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance.</para>
            </remarks>
            <param name="targetVector3">Point A</param>
            <param name="otherVector3">Point B</param>
            <returns>The squared distance.</returns>
        </member>
        <member name="M:GDX.Vector3Extensions.HorizontalDistance(UnityEngine.Vector3,UnityEngine.Vector3)">
            <summary>
                Get the horizontal distance between two UnityEngine.Vector3 points.
            </summary>
            <remarks>Ignores the Y-axis completely.</remarks>
            <param name="targetVector3">Point A</param>
            <param name="otherVector3">Point B</param>
            <returns>The horizontal distance.</returns>
        </member>
        <member name="M:GDX.Vector3Extensions.DistanceToRay(UnityEngine.Vector3,UnityEngine.Ray)">
            <summary>
            Calculate the distance from a UnityEngine.Vector3 to a UnityEngine.Ray.
            </summary>
            <param name="targetVector3">The position.</param>
            <param name="targetRay">The line.</param>
            <returns>The distance.</returns>
        </member>
        <member name="M:GDX.Vector3Extensions.Midpoint(UnityEngine.Vector3,UnityEngine.Vector3)">
            <summary>
                Get the midpoint between two UnityEngine.Vector3s.
            </summary>
            <param name="targetVector3">Point A</param>
            <param name="otherVector3">Point B</param>
            <returns>The midpoint between targetVector3 and otherVector3.</returns>
        </member>
        <member name="M:GDX.Vector3Extensions.NearestIndex(UnityEngine.Vector3,UnityEngine.Vector3[])">
            <summary>
                Find the index of the UnityEngine.Vector3 in otherVector3 that is nearest to the
                targetVector3.
            </summary>
            <param name="targetVector3">The UnityEngine.Vector3 to use as the point of reference.</param>
            <param name="otherVector3">An array of UnityEngine.Vector3 positions to evaluate for which one is nearest.</param>
            <returns>
                The index of the nearest otherVector3 element to targetVector3.
                Returning -1 if the the otherVector3 has no elements or is null.
            </returns>
        </member>
        <member name="M:GDX.Vector3Extensions.TryParseVector3(System.String,UnityEngine.Vector3@)">
            <summary>
                Attempt to parse a System.String into a UnityEngine.Vector3.
            </summary>
            <remarks>This isn't great for runtime performance, it should be used predominantly when reconstructing data.</remarks>
            <param name="targetString">The System.String to convert into a UnityEngine.Vector3 if possible.</param>
            <param name="outputVector3">The outputted UnityEngine.Vector3.</param>
            <returns>true/false if the conversion was successful.</returns>
        </member>
        <member name="T:GDX.Localization">
            <summary>
                A collection of localization related helper utilities.
            </summary>
        </member>
        <member name="F:GDX.Localization.ByteSizes">
            <summary>
                An array of strings representative for file size formats.
            </summary>
        </member>
        <member name="T:GDX.Localization.Language">
            <summary>
                A list of supported languages.
            </summary>
            <remarks>
                This does not differentiate between things like French Canadian and French.
            </remarks>
        </member>
        <member name="F:GDX.Localization.UtcTimestampFormat">
            <summary>
                The UTC ISO 8601 compliant System.DateTime.ToString(System.String).
            </summary>
        </member>
        <member name="F:GDX.Localization.LocalTimestampFormat">
            <summary>
                The local ISO 8601 compliant System.DateTime.ToString(System.String).
            </summary>
        </member>
        <member name="M:GDX.Localization.GetHumanReadableFileSize(System.Int64)">
            <summary>
                Creates a more human readable System.String of a byte size.
            </summary>
            <example>
                A byte size of 1024, will return a string of 1 KB.
            </example>
            <param name="base2Size">The number of bytes (binary) to measure.</param>
            <returns>A human readable version of the provided base2Size.</returns>
        </member>
        <member name="M:GDX.Localization.GetISO639_1(GDX.Localization.Language)">
            <summary>
                <para>Get the ISO 639-1 language code for targetLanguage.</para>
            </summary>
            <remarks>Two additional non-compliant values may be returned DEV or DEFAULT.</remarks>
            <param name="targetLanguage">The target GDX.Localization.Language.</param>
            <returns>The language code.</returns>
        </member>
        <member name="M:GDX.Localization.GetIETF_BCP47(GDX.Localization.Language)">
            <summary>
                <para>Get the IETF BCP 47 language code for targetLanguage.</para>
            </summary>
            <remarks>Two additional non-compliant values may be returned DEV or DEFAULT.</remarks>
            <param name="targetLanguage">The target GDX.Localization.Language.</param>
            <returns>The language code.</returns>
        </member>
        <member name="M:GDX.Localization.GetSystemLanguage">
            <summary>
                Get the GDX.Localization.Language equivalent of the UnityEngine.SystemLanguage.
            </summary>
            <returns>The appropriate GDX.Localization.Language, or default.</returns>
        </member>
        <member name="M:GDX.Localization.GetTimestampFormat(GDX.Localization.Language)">
            <summary>
                Get the localized System.DateTime.System.DateTime.ToString(System.String) for
                targetLanguage.
            </summary>
            <param name="targetLanguage">The target GDX.Localization.Language.</param>
            <returns>The format System.String.</returns>
        </member>
        <member name="M:GDX.Localization.SetDefaultCulture">
            <summary>
                Sets the current threads culture to a defined setting in GDX.Config.
            </summary>
            <remarks>
                Can be used to avoid issues with culture settings without a Gregorian Calendar. Configurable to automatically
                execute after assemblies are loaded.
            </remarks>
        </member>
        <member name="T:GDX.UnsupportedRuntimeException">
            <summary>
            An exception used to indicate when a method is unavailable on a specific runtime.
            </summary>
        </member>
        <member name="T:GDX.Display">
            <summary>
                A collection of display related helper utilities.
            </summary>
        </member>
        <member name="M:GDX.Display.GetScreenHeight">
            <summary>
                <para>Returns the actual screen height being rendered on the current platform.</para>
            </summary>
            <remarks>This resolves issues with scaled rendering.</remarks>
            <returns>The pixel height of the screen resolution.</returns>
            <exception cref="T:GDX.UnsupportedRuntimeException">Not supported on DOTS Runtime.</exception>
        </member>
        <member name="M:GDX.Display.GetScreenWidth">
            <summary>
                <para>Returns the actual screen width being rendered on the current platform.</para>
            </summary>
            <remarks>This resolves issues with scaled rendering.</remarks>
            <returns>The pixel width of the screen resolution.</returns>
            <exception cref="T:GDX.UnsupportedRuntimeException">Not supported on DOTS Runtime.</exception>
        </member>
        <member name="M:GDX.Display.IsHDRSupported">
            <summary>
                Does the current display device support HDR output?
            </summary>
            <returns>true/false</returns>
            <exception cref="T:GDX.UnsupportedRuntimeException">Not supported on DOTS Runtime.</exception>
        </member>
        <member name="M:GDX.Display.IsHDREnabled">
            <summary>
                Is HDR output currently enabled (and actively being used)?
            </summary>
            <returns>true/false</returns>
            <exception cref="T:GDX.UnsupportedRuntimeException">Not supported on DOTS Runtime.</exception>
        </member>
        <member name="T:GDX.EnumExtensions">
            <summary>
                Enumeration Based Extension Methods
            </summary>
        </member>
        <member name="M:GDX.EnumExtensions.HasFlags``1(``0*,``0*)">
            <summary>
                Determine if the provide flags (needles) are found in the haystack.
            </summary>
            <param name="haystack">A predefined flag based enumeration.</param>
            <param name="needles">A set of flags to search for in the predefined enumeration.</param>
            <typeparam name="T">The enumeration's type.</typeparam>
            <returns>true if the needles are found in the haystack, otherwise false.</returns>
        </member>
        <member name="M:GDX.EnumExtensions.HasFlags``1(``0,``0)">
            <summary>
                Determine if the provide flags (needles) are found in the haystack.
            </summary>
            <remarks>Faster then System.Enum.HasFlag(System.Enum).</remarks>
            <param name="haystack">A predefined flag based enumeration.</param>
            <param name="needles">A set of flags to search for in the predefined enumeration.</param>
            <typeparam name="T">The enumeration's type.</typeparam>
            <returns>true if the needles are found in the haystack, otherwise false.</returns>
        </member>
        <member name="T:GDX.Memory">
            <summary>
                A collection of memory related helper utilities.
            </summary>
        </member>
        <member name="M:GDX.Memory.CleanUp">
            <summary>
                <para>Cleanup Memory</para>
                <list type="bullet">
                    <item>
                        <description>Mono Heap (Garbage Collection)</description>
                    </item>
                    <item>
                        <description>Unity Resources (when not deployed on DOTS Runtime.</description>
                    </item>
                </list>
            </summary>
        </member>
        <member name="M:GDX.Memory.CleanUpAsync">
            <inheritdoc cref="M:GDX.Memory.CleanUp" />
            <exception cref="T:GDX.UnsupportedRuntimeException">Not supported on DOTS Runtime.</exception>
        </member>
        <member name="T:GDX.SimpleListExtensions">
            <summary>
                GDX.Collections.Generic.SimpleList`1 Based Extension Methods
            </summary>
            <remarks>
                Methods found in this extensions class are less performant then the included methods in
                GDX.Collections.Generic.SimpleList`1. They are seperated out to clearly delineate this
                performance regression.
            </remarks>
        </member>
        <member name="M:GDX.SimpleListExtensions.AddUncheckedUniqueItem``1(GDX.Collections.Generic.SimpleList{``0}@,``0)">
            <summary>
                Add an item to the GDX.Collections.Generic.SimpleList`1 without checking the internal size,
                making sure that the item is not already contained in the GDX.Collections.Generic.SimpleList`1.
            </summary>
            <param name="targetSimpleList">The target GDX.Collections.Generic.SimpleList`1 to add to.</param>
            <param name="targetItem">The target class object to add.</param>
            <typeparam name="T">The type of the GDX.Collections.Generic.SimpleList`1.</typeparam>
            <returns>true/false if the operation was able to add the item successfully.</returns>
        </member>
        <member name="M:GDX.SimpleListExtensions.AddUncheckedUniqueReference``1(GDX.Collections.Generic.SimpleList{``0}@,``0)">
            <summary>
                Add an object reference to the GDX.Collections.Generic.SimpleList`1 without checking the internal size,
                making sure that the reference is not already contained in the GDX.Collections.Generic.SimpleList`1.
                Does not prevent addition of different objects for which Equals returns true.
            </summary>
            <param name="targetSimpleList">The target GDX.Collections.Generic.SimpleList`1 to add to.</param>
            <param name="targetReference">The target class object to add.</param>
            <typeparam name="T">The type of the GDX.Collections.Generic.SimpleList`1.</typeparam>
            <returns>true/false if the operation was able to add the reference successfully.</returns>
        </member>
        <member name="M:GDX.SimpleListExtensions.AddWithExpandCheckUniqueItem``1(GDX.Collections.Generic.SimpleList{``0}@,``0)">
            <summary>
                Add an item to the GDX.Collections.Generic.SimpleList`1 with checking the internal size (expanding as necessary),
                making sure that the item is not already contained in the GDX.Collections.Generic.SimpleList`1.
            </summary>
            <param name="targetSimpleList">The target GDX.Collections.Generic.SimpleList`1 to add to.</param>
            <param name="targetItem">The target class object to add.</param>
            <typeparam name="T">The type of the GDX.Collections.Generic.SimpleList`1.</typeparam>
            <returns>true/false if the operation was able to add the item successfully.</returns>
        </member>
        <member name="M:GDX.SimpleListExtensions.AddWithExpandCheckUniqueValue``1(GDX.Collections.Generic.SimpleList{``0}@,``0)">
            <summary>
                Add an item to the GDX.Collections.Generic.SimpleList`1 with checking the internal size (expanding as necessary),
                making sure that the item is not already contained in the GDX.Collections.Generic.SimpleList`1.
            </summary>
            <param name="targetSimpleList">The target GDX.Collections.Generic.SimpleList`1 to add to.</param>
            <param name="targetItem">The target class object to add.</param>
            <typeparam name="T">The type of the GDX.Collections.Generic.SimpleList`1.</typeparam>
            <returns>true/false if the operation was able to add the item successfully.</returns>
        </member>
        <member name="M:GDX.SimpleListExtensions.AddWithExpandCheckUniqueReference``1(GDX.Collections.Generic.SimpleList{``0}@,``0)">
            <summary>
                Add an object reference to the GDX.Collections.Generic.SimpleList`1 with checking the internal size (expanding as necessary),
                making sure that the reference is not already contained in the GDX.Collections.Generic.SimpleList`1.
                Does not prevent addition of different objects for which Equals returns true.
            </summary>
            <param name="targetSimpleList">The target GDX.Collections.Generic.SimpleList`1 to add to.</param>
            <param name="targetReference">The target class object to add.</param>
            <typeparam name="T">The type of the GDX.Collections.Generic.SimpleList`1.</typeparam>
            <returns>true/false if the operation was able to add the reference successfully.</returns>
        </member>
        <member name="M:GDX.SimpleListExtensions.Contains``1(GDX.Collections.Generic.SimpleList{``0}@,``0)">
            <summary>
                <para>Does targetSimpleList contain targetItem?</para>
            </summary>
            <param name="targetSimpleList">The GDX.Collections.Generic.SimpleList`1 to look in.</param>
            <param name="targetItem">The target class object to look for.</param>
            <typeparam name="T">The type of the GDX.Collections.Generic.SimpleList`1.</typeparam>
            <returns>true/false</returns>
        </member>
        <member name="M:GDX.SimpleListExtensions.ContainsItem``1(GDX.Collections.Generic.SimpleList{``0}@,``0)">
            <summary>
                <para>Does targetSimpleList contain targetItem?</para>
            </summary>
            <remarks>Avoids using System.Collections.Generic.EqualityComparer`1.</remarks>
            <param name="targetSimpleList">The GDX.Collections.Generic.SimpleList`1 to look in.</param>
            <param name="targetItem">The target class object to look for.</param>
            <typeparam name="T">The type of the GDX.Collections.Generic.SimpleList`1.</typeparam>
            <returns>true/false</returns>
        </member>
        <member name="M:GDX.SimpleListExtensions.ContainsValue``1(GDX.Collections.Generic.SimpleList{``0}@,``0)">
            <summary>
                <para>Does targetSimpleList contain targetItem?</para>
            </summary>
            <remarks>Avoids using System.Collections.Generic.EqualityComparer`1.</remarks>
            <param name="targetSimpleList">The GDX.Collections.Generic.SimpleList`1 to look in.</param>
            <param name="targetItem">The target class object to look for.</param>
            <typeparam name="T">The type of the GDX.Collections.Generic.SimpleList`1.</typeparam>
            <returns>true/false</returns>
        </member>
        <member name="M:GDX.SimpleListExtensions.ContainsReference``1(GDX.Collections.Generic.SimpleList{``0}@,``0)">
            <summary>
                <para>Does targetSimpleList contain targetItem?</para>
            </summary>
            <remarks>Ignores equality check and end up comparing object pointers.</remarks>
            <param name="targetSimpleList">The GDX.Collections.Generic.SimpleList`1 to look in.</param>
            <param name="targetItem">The target class object to look for.</param>
            <typeparam name="T">The type of the GDX.Collections.Generic.SimpleList`1.</typeparam>
            <returns>true/false</returns>
        </member>
        <member name="M:GDX.SimpleListExtensions.FirstIndexOf``1(GDX.Collections.Generic.SimpleList{``0}@,``0)">
            <summary>
                Find the first index of targetItem in targetSimpleList.
            </summary>
            <remarks>This will work for System.String comparisons.</remarks>
            <param name="targetSimpleList">The GDX.Collections.Generic.SimpleList`1 to look in.</param>
            <param name="targetItem">The object to be found.</param>
            <typeparam name="T">The type of the array.</typeparam>
            <returns>The index of targetItem in targetSimpleList backing array, or -1 if not found.</returns>
        </member>
        <member name="M:GDX.SimpleListExtensions.FirstIndexOfItem``1(GDX.Collections.Generic.SimpleList{``0}@,``0)">
            <summary>
                Find the first index of targetItem in targetSimpleList.
            </summary>
            <remarks>Ignores equality check and end up comparing object pointers. Do NOT use this for System.String types.</remarks>
            <param name="targetSimpleList">The GDX.Collections.Generic.SimpleList`1 to look in.</param>
            <param name="targetItem">The object to be found.</param>
            <typeparam name="T">The type of the array.</typeparam>
            <returns>The index of targetItem in targetSimpleList backing array, or -1 if not found.</returns>
        </member>
        <member name="M:GDX.SimpleListExtensions.FirstIndexOfValue``1(GDX.Collections.Generic.SimpleList{``0}@,``0)">
            <summary>
                Find the first index of targetValue in targetSimpleList.
            </summary>
            <param name="targetSimpleList">The GDX.Collections.Generic.SimpleList`1 to look in.</param>
            <param name="targetValue">The value to be found.</param>
            <typeparam name="T">The type of the array.</typeparam>
            <returns>The index of targetValue in targetSimpleList backing array, or -1 if not found.</returns>
        </member>
        <member name="M:GDX.SimpleListExtensions.LastIndexOf``1(GDX.Collections.Generic.SimpleList{``0}@,``0)">
            <summary>
                Find the last index of targetItem in targetSimpleList.
            </summary>
            <remarks>This will work for System.String comparisons.</remarks>
            <param name="targetSimpleList">The GDX.Collections.Generic.SimpleList`1 to look in.</param>
            <param name="targetItem">The object to be found.</param>
            <typeparam name="T">The type of the array.</typeparam>
            <returns>The index of targetItem in targetSimpleList backing array, or -1 if not found.</returns>
        </member>
        <member name="M:GDX.SimpleListExtensions.LastIndexOfItem``1(GDX.Collections.Generic.SimpleList{``0}@,``0)">
            <summary>
                Find the last index of targetItem in targetSimpleList.
            </summary>
            <param name="targetSimpleList">The GDX.Collections.Generic.SimpleList`1 to look in.</param>
            <param name="targetItem">The object to be found.</param>
            <typeparam name="T">The type of the array.</typeparam>
            <returns>The index of targetItem in targetSimpleList backing array, or -1 if not found.</returns>
        </member>
        <member name="M:GDX.SimpleListExtensions.LastIndexOfValue``1(GDX.Collections.Generic.SimpleList{``0}@,``0)">
            <summary>
                Find the last index of targetValue in targetSimpleList.
            </summary>
            <param name="targetSimpleList">The GDX.Collections.Generic.SimpleList`1 to look in.</param>
            <param name="targetValue">The value to be found.</param>
            <typeparam name="T">The type of the array.</typeparam>
            <returns>The index of targetValue in targetSimpleList backing array, or -1 if not found.</returns>
        </member>
        <member name="M:GDX.SimpleListExtensions.RemoveFirstItem``1(GDX.Collections.Generic.SimpleList{``0}@,``0)">
            <summary>
                <para>Removes the first targetItem from the provided targetSimpleList.</para>
            </summary>
            <remarks>Avoids using System.Collections.Generic.EqualityComparer`1.</remarks>
            <param name="targetSimpleList">The target GDX.Collections.Generic.SimpleList`1.</param>
            <param name="targetItem">The target object to remove from the targetSimpleList.</param>
            <typeparam name="T">The type of the GDX.Collections.Generic.SimpleList`1.</typeparam>
            <returns>true/false if an item was removed.</returns>
        </member>
        <member name="M:GDX.SimpleListExtensions.RemoveFirstReference``1(GDX.Collections.Generic.SimpleList{``0}@,``0)">
            <summary>
                <para>Removes the first targetReference from the provided targetSimpleList.</para>
                Only removes direct object references, i.e. equivalent strings at different memory addresses would not be removed.
            </summary>
            <remarks>Avoids using System.Collections.Generic.EqualityComparer`1.</remarks>
            <param name="targetSimpleList">The target GDX.Collections.Generic.SimpleList`1.</param>
            <param name="targetReference">The target object to remove from the targetSimpleList.</param>
            <typeparam name="T">The type of the GDX.Collections.Generic.SimpleList`1.</typeparam>
            <returns>true/false if an object reference was removed.</returns>
        </member>
        <member name="M:GDX.SimpleListExtensions.RemoveItems``1(GDX.Collections.Generic.SimpleList{``0}@,``0)">
            <summary>
                <para>Removes all targetItem from the provided targetSimpleList.</para>
            </summary>
            <remarks>Avoids using System.Collections.Generic.EqualityComparer`1.</remarks>
            <param name="targetSimpleList">The target GDX.Collections.Generic.SimpleList`1.</param>
            <param name="targetItem">The item to remove from the targetSimpleList.</param>
            <typeparam name="T">The type of the GDX.Collections.Generic.SimpleList`1.</typeparam>
            <returns>true/false if items were removed.</returns>
        </member>
        <member name="M:GDX.SimpleListExtensions.RemoveReferences``1(GDX.Collections.Generic.SimpleList{``0}@,``0)">
            <summary>
                <para>Removes all instances of references to targetReference from the provided targetSimpleList.</para>
                Only removes direct object references, i.e. equivalent strings at different memory addresses would not be removed.
            </summary>
            <remarks>Avoids using System.Collections.Generic.EqualityComparer`1.</remarks>
            <param name="targetSimpleList">The target GDX.Collections.Generic.SimpleList`1.</param>
            <param name="targetReference">The object reference to remove from the targetSimpleList.</param>
            <typeparam name="T">The type of the GDX.Collections.Generic.SimpleList`1.</typeparam>
            <returns>true/false if any references were removed.</returns>
        </member>
        <member name="M:GDX.SimpleListExtensions.RemoveLastItem``1(GDX.Collections.Generic.SimpleList{``0}@,``0)">
            <summary>
                <para>Removes the last targetItem from the provided targetSimpleList.</para>
            </summary>
            <remarks>Avoids using System.Collections.Generic.EqualityComparer`1.</remarks>
            <param name="targetSimpleList">The target GDX.Collections.Generic.SimpleList`1.</param>
            <param name="targetItem">The target object to remove from the targetSimpleList.</param>
            <typeparam name="T">The type of the GDX.Collections.Generic.SimpleList`1.</typeparam>
            <returns>true/false if an item was removed.</returns>
        </member>
        <member name="M:GDX.SimpleListExtensions.RemoveLastReference``1(GDX.Collections.Generic.SimpleList{``0}@,``0)">
            <summary>
                <para>Removes the last reference to targetReference from the provided targetSimpleList.</para>
                Only removes direct object references, i.e. equivalent strings at different memory addresses would not be removed.
            </summary>
            <remarks>Avoids using System.Collections.Generic.EqualityComparer`1.</remarks>
            <param name="targetSimpleList">The target GDX.Collections.Generic.SimpleList`1.</param>
            <param name="targetReference">The target object reference to remove from the targetSimpleList.</param>
            <typeparam name="T">The type of the GDX.Collections.Generic.SimpleList`1.</typeparam>
            <returns>true/false if an object reference was removed.</returns>
        </member>
        <member name="T:GDX.CapsuleColliderExtensions">
            <summary>
                UnityEngine.CapsuleCollider Based Extension Methods
            </summary>
            <exception cref="T:GDX.UnsupportedRuntimeException">Not supported on DOTS Runtime.</exception>
        </member>
        <member name="M:GDX.CapsuleColliderExtensions.Direction(UnityEngine.CapsuleCollider)">
            <summary>
                Get a UnityEngine.Vector3 based orientation of the targetCapsuleCollider.
            </summary>
            <param name="targetCapsuleCollider">The capsule collider</param>
            <returns>The direction of a UnityEngine.CapsuleCollider in its local space.</returns>
        </member>
        <member name="M:GDX.CapsuleColliderExtensions.OutSphereCenters(UnityEngine.CapsuleCollider,UnityEngine.Vector3@,UnityEngine.Vector3@)">
            <summary>
                Return into topPosition and bottomPosition, the respective world-space position of a UnityEngine.CapsuleCollider's spheres centers.
            </summary>
            <param name="targetCapsuleCollider">The UnityEngine.CapsuleCollider having its spheres evaluated.</param>
            <param name="topPosition">The determined top spheres center position in world-space.</param>
            <param name="bottomPosition">The determined bottom spheres center position in world-space.</param>
        </member>
        <member name="T:GDX.AddressablesExtensions">
            <summary>
                Addressables Based Extension Methods
            </summary>
            <remarks>
                <para>Requires UnityEngine.CoreModule.dll to function correctly.</para>
                <para>Requires <c>com.unity.addressables</c> Package.</para>
            </remarks>
        </member>
        <member name="F:GDX.AddressablesExtensions.k_EmptyAssetReference">
            <summary>
                An empty instance of an UnityEngine.AddressableAssets.AssetReference to be used for comparison.
            </summary>
        </member>
        <member name="M:GDX.AddressablesExtensions.CanInstantiate(UnityEngine.AddressableAssets.AssetReference)">
            <summary>
                <para>Can targetAssetReference be instantiated at runtime?</para>
            </summary>
            <remarks>Checks that it is not empty, has a runtime key, and makes sure the key is valid.</remarks>
            <param name="targetAssetReference">The target UnityEngine.AddressableAssets.AssetReference.</param>
            <returns>true/false</returns>
        </member>
        <member name="M:GDX.AddressablesExtensions.CanRelease(UnityEngine.ResourceManagement.AsyncOperations.AsyncOperationHandle{UnityEngine.GameObject},System.Boolean)">
            <summary>
                Can the targetAsyncOperationHandle be released?
            </summary>
            <param name="targetAsyncOperationHandle">
                A target UnityEngine.ResourceManagement.AsyncOperations.AsyncOperationHandle`1
                typed as UnityEngine.GameObject.
            </param>
            <param name="autoRelease">If it can, should the handle release?</param>
            <returns>true/false</returns>
        </member>
        <member name="M:GDX.AddressablesExtensions.HasRuntimeKey(UnityEngine.AddressableAssets.AssetReference)">
            <summary>
                <para>Does targetAssetReference have a runtime key?</para>
            </summary>
            <remarks>Will return false if the reference is null.</remarks>
            <param name="targetAssetReference">The target UnityEngine.AddressableAssets.AssetReference.</param>
            <returns>true/false</returns>
        </member>
        <member name="M:GDX.AddressablesExtensions.IsEmpty(UnityEngine.AddressableAssets.AssetReference)">
            <summary>
                Is targetAssetReference empty?
            </summary>
            <param name="targetAssetReference">The target UnityEngine.AddressableAssets.AssetReference.</param>
            <returns>true/false</returns>
        </member>
        <member name="T:GDX.TransformExtensions">
            <summary>
                UnityEngine.Transform Based Extension Methods
            </summary>
            <exception cref="T:GDX.UnsupportedRuntimeException">Not supported on DOTS Runtime.</exception>
        </member>
        <member name="M:GDX.TransformExtensions.DestroyChildren(UnityEngine.Transform,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
                Destroy child UnityEngine.Transform.
            </summary>
            <param name="targetTransform">The parent UnityEngine.Transform to look at.</param>
            <param name="deactivateBeforeDestroy">
                Should the targetTransform children's
                UnityEngine.GameObjects be deactivated before destroying? This can be used to immediately hide an object, that
                will be destroyed at the end of the frame.
            </param>
            <param name="destroyInactive">Should inactive UnityEngine.GameObject be destroyed as well?</param>
            <param name="immediateMode">Should the destroy be done immediately? This is useful for author time calls.</param>
        </member>
        <member name="M:GDX.TransformExtensions.GetActiveChildCount(UnityEngine.Transform)">
            <summary>
                Get the number of immediate children active.
            </summary>
            <param name="targetTransform">The transform to look at's children.</param>
            <returns>The number of active children transforms.</returns>
        </member>
        <member name="M:GDX.TransformExtensions.GetFirstComponentInChildrenComplex``1(UnityEngine.Transform,System.Boolean,System.Int32,System.Int32)">
            <summary>
                Search recursively for a UnityEngine.Component on the targetTransform.
            </summary>
            <param name="targetTransform">The target UnityEngine.Transform to use as the base for the search.</param>
            <param name="includeInactive">
                Include inactive child UnityEngine.GameObjects when looking for the
                UnityEngine.Component.
            </param>
            <param name="currentDepth">Current level of recursion.</param>
            <param name="maxLevelsOfRecursion">
                The maximum levels of recursion when looking for a UnityEngine.Component, -1 for
                infinite recursion.
            </param>
            <typeparam name="T">The target UnityEngine.Component type that is being looked for.</typeparam>
            <returns>The first found UnityEngine.Component.</returns>
        </member>
        <member name="M:GDX.TransformExtensions.GetScenePath(UnityEngine.Transform)">
            <summary>
                Get an in scene path to the targetTransform.
            </summary>
            <param name="targetTransform">The UnityEngine.Transform which to derive a path from.</param>
            <returns>A created path System.String.</returns>
        </member>
        <member name="T:GDX.Platform">
            <summary>
                A collection of platform related helper utilities.
            </summary>
        </member>
        <member name="F:GDX.Platform.FilenameTimestampFormat">
            <summary>
                A filename safe version of the timestamp format.
            </summary>
        </member>
        <member name="M:GDX.Platform.EnsureFolderHierarchyExists(System.String)">
            <summary>
                Validate that all directories are created for a given folderPath.
            </summary>
            <param name="folderPath">The path to process and validate.</param>
        </member>
        <member name="M:GDX.Platform.EnsureFileFolderHierarchyExists(System.String)">
            <summary>
                Validate that all parent directories are created for a given filePath.
            </summary>
            <param name="filePath">The path to process and validate.</param>
        </member>
        <member name="M:GDX.Platform.EnsureFileWritable(System.String)">
            <summary>
                Validate that the file path is writable, making the necessary folder structure and setting permissions.
            </summary>
            <param name="filePath">The absolute path to validate.</param>
        </member>
        <member name="M:GDX.Platform.ForceDeleteFile(System.String)">
            <summary>
                Use our best attempt to remove a file at the designated filePath.
            </summary>
            <param name="filePath">The file path to remove forcefully.</param>
        </member>
        <member name="M:GDX.Platform.GetHardwareGeneration">
            <summary>
                Gets the current platforms hardware generation number?
            </summary>
            <returns>Returns 0 for base hardware, 1 for updates.</returns>
        </member>
        <member name="M:GDX.Platform.GetOutputFolder(System.String)">
            <summary>
                Returns a runtime writable folder.
            </summary>
            <param name="folderName">An optional additional folder under the provided path that will be created if necessary.</param>
            <returns>The full path to a writable folder at runtime.</returns>
            <remarks>
                Depending on the platform, different routes are taken to finding a writable folder.
                <list type="table">
                    <item>
                        <term>Editor</term>
                        <description>The project's root folder is used in this case.</description>
                    </item>
                    <item>
                        <term>Standard Player</term>
                        <description>Utilizes P:UnityEngine.Application.persistentDataPath to find a suitable place.</description>
                    </item>
                    <item>
                        <term>DOTS Runtime</term>
                        <description>Uses System.IO.Directory.GetCurrentDirectory.</description>
                    </item>
                </list>
                The path can be overridden by assigning GDX_OUTPUT_FOLDER in the launching arguments.
            </remarks>
        </member>
        <member name="M:GDX.Platform.IsFocused">
            <summary>
                Is the application focused?
            </summary>
            <remarks>
                There are issues on some platforms with getting an accurate reading.
            </remarks>
            <returns>true/false if the application has focus.</returns>
            <exception cref="T:GDX.UnsupportedRuntimeException">Not supported on DOTS Runtime.</exception>
        </member>
        <member name="M:GDX.Platform.IsFileWritable(System.String)">
            <summary>
            Is it safe to write to the indicated filePath?
            </summary>
            <param name="filePath">The file path to check if it can be written.</param>
            <returns>true/false if the path can be written too.</returns>
        </member>
        <member name="M:GDX.Platform.IsHeadless">
            <summary>
            Is the application running in headless mode?.
            </summary>
            <remarks>Useful for detecting running a server.</remarks>
            <returns>true/false if the application is without an initialized graphics device.</returns>
            <exception cref="T:GDX.UnsupportedRuntimeException">Not supported on DOTS Runtime.</exception>
        </member>
        <member name="T:GDX.Trace">
            <summary>
                Trace logging functionality.
            </summary>
        </member>
        <member name="T:GDX.Trace.TraceLevel">
            <summary>
            Trace Levels
            </summary>
        </member>
        <member name="F:GDX.Trace.TraceLevel.Info">
            <summary>
                A trivial informational entry.
            </summary>
        </member>
        <member name="F:GDX.Trace.TraceLevel.Log">
            <summary>
                An entry indicating something which might be useful to provide context.
            </summary>
        </member>
        <member name="F:GDX.Trace.TraceLevel.Warning">
            <summary>
                An issue has been found but handled.
            </summary>
        </member>
        <member name="F:GDX.Trace.TraceLevel.Error">
            <summary>
                An error has occurred which may be recoverable, but notification is required.
            </summary>
        </member>
        <member name="F:GDX.Trace.TraceLevel.Exception">
            <summary>
                An exception has occured and needs to be flagged up for resolution. The should never happen in a release
                environment.
            </summary>
        </member>
        <member name="F:GDX.Trace.TraceLevel.Assertion">
            <summary>
                An assertion based event has occured and has some sort of messaging to be recorded.
            </summary>
        </member>
        <member name="F:GDX.Trace.TraceLevel.Fatal">
            <summary>
                A fatal error has occured which needs to be logged, and the program will subsequently crash.
            </summary>
        </member>
        <member name="M:GDX.Trace.Output(GDX.Trace.TraceLevel,System.Object,UnityEngine.Object,System.String,System.String,System.Int32)">
            <summary>
                Log a trace message to the appropriate subscribers and the Unity console where applicable with additional context on invoke location.
            </summary>
            <param name="level">The GDX.Trace.TraceLevel of the particular message.</param>
            <param name="traceObject">An System.Object representing the message to be recorded.</param>
            <param name="contextObject">An UnityEngine.Object indicating context for the given message.</param>
            <param name="memberName">Automatically filled out member name which invoked this method.</param>
            <param name="sourceFilePath">Automatically filled out source code path of the invoking method.</param>
            <param name="sourceLineNumber">Automatically filled out line number of the invoking method.</param>
        </member>
        <member name="T:GDX.BoxColliderExtensions">
            <summary>
                UnityEngine.BoxCollider Based Extension Methods
            </summary>
            <exception cref="T:GDX.UnsupportedRuntimeException">Not supported on DOTS Runtime.</exception>
        </member>
        <member name="M:GDX.BoxColliderExtensions.ContainsPosition(UnityEngine.BoxCollider,UnityEngine.Vector3)">
            <summary>
                Is the worldPosition inside of the targetBoxCollider?
            </summary>
            <param name="targetBoxCollider">The UnityEngine.BoxCollider to use for evaluation.</param>
            <param name="worldPosition">A UnityEngine.Vector3 point in world space.</param>
            <returns>true/false if the world position is contained within the targetBoxCollider.</returns>
        </member>
        <member name="T:GDX.SegmentedString">
            <summary>
                A segmented collection of System.Char.
            </summary>
        </member>
        <member name="F:GDX.SegmentedString.m_Characters">
            <summary>
                The initial array of characters.
            </summary>
        </member>
        <member name="F:GDX.SegmentedString.m_Segments">
            <summary>
                Datastore of word segment information.
            </summary>
            <remarks>
                <list type="table">
                    <listheader>
                        <term>Axis</term>
                        <description>Typical Usage</description>
                    </listheader>
                    <item>
                        <term>x</term>
                        <description>The start offset in GDX.SegmentedString.m_Characters of a word.</description>
                    </item>
                    <item>
                        <term>y</term>
                        <description>The length of the word.</description>
                    </item>
                    <item>
                        <term>z</term>
                        <description>The calculated GDX.StringExtensions.GetStableHashCode(System.String) for the word.</description>
                    </item>
                </list>
            </remarks>
        </member>
        <member name="F:GDX.SegmentedString.m_Count">
            <summary>
                The number of words.
            </summary>
        </member>
        <member name="F:GDX.SegmentedString.m_HashCode">
            <summary>
                The calculated GDX.StringExtensions.GetStableHashCode(System.String) for the entirety of GDX.SegmentedString.m_Characters.
            </summary>
        </member>
        <member name="M:GDX.SegmentedString.AsCharArray">
            <summary>
                Get the GDX.SegmentedString.m_Characters array.
            </summary>
            <returns>A System.Char array.</returns>
        </member>
        <member name="T:GDX.GameObjectExtensions">
            <summary>
                UnityEngine.GameObject Based Extension Methods
            </summary>
            <exception cref="T:GDX.UnsupportedRuntimeException">Not supported on DOTS Runtime.</exception>
        </member>
        <member name="M:GDX.GameObjectExtensions.DestroyChildren(UnityEngine.GameObject,System.Boolean,System.Boolean)">
            <summary>
                Destroy child UnityEngine.GameObject.
            </summary>
            <param name="targetGameObject">The parent UnityEngine.GameObject to look at.</param>
            <param name="deactivateBeforeDestroy">
                Should the targetGameObject's children be deactivated before
                destroying? This can be used to immediately hide an object, that will be destroyed at the end of the frame.
            </param>
            <param name="destroyInactive">Should inactive UnityEngine.GameObject be destroyed as well?</param>
        </member>
        <member name="M:GDX.GameObjectExtensions.GetFirstComponentInChildrenComplex``1(UnityEngine.GameObject,System.Boolean,System.Boolean,System.Int32)">
            <summary>
                A slightly more complex version of UnityEngine.Component.GetComponentInChildren``1(System.Boolean) which allows for
                different hinted search options.
            </summary>
            <remarks>
                <para>
                    If the maxLevelsOfRecursion is set to 1; this will search the
                    targetGameObject and its immediate children only.
                </para>
                <para>
                    The internal UnityEngine.Component.GetComponentInChildren``1(System.Boolean) has optimizations internally in engine
                    code which make it faster in different scenarios.
                </para>
            </remarks>
            <param name="targetGameObject">The target UnityEngine.GameObject to use as the base for the search.</param>
            <param name="lookInChildrenFirst">
                Should children UnityEngine.GameObject be searched before the
                targetGameObject's UnityEngine.GameObject.
            </param>
            <param name="includeInactive">
                Include inactive child UnityEngine.GameObjects when looking for the
                UnityEngine.Component.
            </param>
            <param name="maxLevelsOfRecursion">
                The maximum levels of recursion when looking for a UnityEngine.Component, -1 for
                infinite recursion.
            </param>
            <typeparam name="T">The target UnityEngine.Component type that is being looked for.</typeparam>
            <returns>The first found UnityEngine.Component.</returns>
        </member>
        <member name="M:GDX.GameObjectExtensions.GetOrAddComponent``1(UnityEngine.GameObject)">
            <summary>
                Get a component by type from a targetGameObject, if it is not found add and return it.
            </summary>
            <remarks>Adding a component at runtime is a performance nightmare. Use with caution!</remarks>
            <param name="targetGameObject">The UnityEngine.GameObject that we should query for the component.</param>
            <typeparam name="T">The type of component.</typeparam>
            <returns>The component on the targetGameObject.</returns>
        </member>
        <member name="M:GDX.GameObjectExtensions.GetScenePath(UnityEngine.GameObject)">
            <summary>
                Get an in scene path to the targetGameObject.
            </summary>
            <param name="targetGameObject">The UnityEngine.GameObject which to derive a path from.</param>
            <returns>A created path System.String.</returns>
        </member>
        <member name="T:GDX.CameraExtensions">
            <summary>
                UnityEngine.Camera Based Extension Methods
            </summary>
            <exception cref="T:GDX.UnsupportedRuntimeException">Not supported on DOTS Runtime.</exception>
        </member>
        <member name="M:GDX.CameraExtensions.RenderToTexture(UnityEngine.Camera,System.Int32,System.Int32,System.Int32)">
            <summary>
                Forces a UnityEngine.Camera to render it's view into a texture.
            </summary>
            <param name="targetCamera">The target UnityEngine.Camera to use.</param>
            <param name="width">The desired width of the rendered texture.</param>
            <param name="height">The desired height of the rendered texture.</param>
            <param name="depthBuffer">The desired depth of the rendered texture.</param>
            <remarks>This behaves differently then using UnityEngine.ScreenCapture.</remarks>
            <returns>The rendered view.</returns>
        </member>
        <member name="M:GDX.CameraExtensions.RenderToPNG(UnityEngine.Camera,System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
                Forces a UnityEngine.Camera through GDX.CameraExtensions.RenderToTexture(UnityEngine.Camera,System.Int32,System.Int32,System.Int32) encoding to PNG.
            </summary>
            <param name="targetCamera">The target UnityEngine.Camera to use.</param>
            <param name="outputPath">The full path to output the PNG bytes.</param>
            <param name="width">The desired width of the rendered texture.</param>
            <param name="height">The desired height of the rendered texture.</param>
            <param name="depthBuffer">The desired depth of the rendered texture.</param>
            <returns>true/false if the capture was successful.</returns>
            <remarks>This does not indicate if the writing of the PNG was successful.</remarks>
        </member>
        <member name="T:GDX.MonoBehaviourExtensions">
            <summary>
                UnityEngine.MonoBehaviour Based Extension Methods
            </summary>
            <exception cref="T:GDX.UnsupportedRuntimeException">Not supported on DOTS Runtime.</exception>
        </member>
        <member name="M:GDX.MonoBehaviourExtensions.GetFirstComponentInChildrenComplex``1(UnityEngine.MonoBehaviour,System.Boolean,System.Boolean,System.Int32)">
            <summary>
                A slightly more complex version of UnityEngine.Component.GetComponentInChildren``1(System.Boolean) which allows for
                different hinted search options.
            </summary>
            <remarks>
                <para>
                    If the maxLevelsOfRecursion is set to 1; this will search the
                    targetMonoBehaviour and its immediate children only.
                </para>
                <para>
                    The internal UnityEngine.Component.GetComponentInChildren``1(System.Boolean) has optimizations internally in engine
                    code which make it faster in different scenarios.
                </para>
            </remarks>
            <typeparam name="T">The target UnityEngine.Component type that is being looked for.</typeparam>
            <param name="targetMonoBehaviour">The target UnityEngine.MonoBehaviour to use as the base for the search.</param>
            <param name="lookInChildrenFirst">
                Should children UnityEngine.GameObject be searched before the
                targetMonoBehaviour's UnityEngine.GameObject.
            </param>
            <param name="includeInactive">
                Include inactive child UnityEngine.GameObjects when looking for the
                UnityEngine.Component.
            </param>
            <param name="maxLevelsOfRecursion">
                The maximum levels of recursion when looking for a UnityEngine.Component, -1 for
                infinite recursion.
            </param>
            <returns>The first found UnityEngine.Component.</returns>
        </member>
        <member name="F:GDX.Core.EmptyObjectArray">
            <summary>
                An empty System.Object array useful when things require it.
            </summary>
        </member>
        <member name="F:GDX.Core.Random">
            <summary>
                A pseudorandom number generated seeded with GDX.Core.StartTicks.
            </summary>
            <remarks>Useful for generic randomness where determinism is not required.</remarks>
        </member>
        <member name="F:GDX.Core.StartTicks">
            <summary>
                The point in tick based time when the core was initialized.
            </summary>
        </member>
        <member name="F:GDX.Core.s_InitializedMainThread">
            <summary>
                Has the GDX.Core main thread initialization happened?
            </summary>
        </member>
        <member name="M:GDX.Core.#cctor">
            <summary>
                Static constructor.
            </summary>
            <remarks>Nothing in here can reference the Unity engine and must be thread-safe.</remarks>
        </member>
        <member name="M:GDX.Core.InitializeOnMainThread">
            <summary>
                Main-thread initializer.
            </summary>
        </member>
        <member name="T:GDX.Rendering.ShaderProvider">
            <summary>
                A provider of GDX built-in shader references and properties.
            </summary>
        </member>
        <member name="F:GDX.Rendering.ShaderProvider.s_DottedLineShader">
            <summary>
                The cached reference to the dotted line shader.
            </summary>
        </member>
        <member name="F:GDX.Rendering.ShaderProvider.s_UnlitColorShader">
            <summary>
                The cached reference to the unlit colored shader.
            </summary>
        </member>
        <member name="F:GDX.Rendering.ShaderProvider.ColorPropertyID">
            <summary>
                The cached "_Color" property ID.
            </summary>
        </member>
        <member name="P:GDX.Rendering.ShaderProvider.DottedLine">
            <summary>
                A reference to a clip-space sin wave discard based shader, which cheaply provides a dotted line effect.
            </summary>
        </member>
        <member name="P:GDX.Rendering.ShaderProvider.UnlitColor">
            <summary>
                A reference to a unlit single color shader.
            </summary>
        </member>
        <member name="M:GDX.Rendering.ShaderProvider.GetProvidedShaders">
            <summary>
                Get all shaders which GDX.Rendering.ShaderProvider is aware of.
            </summary>
            <returns>An array of the known shaders to GDX.Rendering.ShaderProvider.</returns>
        </member>
    </members>
</doc>
